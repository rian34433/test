<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Form Input Toko</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f5f5;
            padding: 0;
            margin: 0;
            width: 100%;
            overflow-x: hidden;
        }

        html {
            width: 100%;
            overflow-x: hidden;
        }

        .container {
            max-width: 100%;
            width: 100%;
            margin: 0;
            padding: 0;
            background-color: white;
            border-radius: 0;
            box-shadow: none;
            overflow: hidden;
            box-sizing: border-box;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 5px;
            text-align: center;
            position: relative;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
        }

        .header h1 {
            font-size: 24px;
            font-weight: 600;
        }
        
        .header-controls {
            position: absolute;
            top: 8px;
            right: 15px;
            display: flex;
            gap: 8px;
        }
        
        .header-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }
        
        .header-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .form-container {
            padding: 30px;
            position: relative;
            max-width: 1400px;
            width: 100%;
            margin: 0 auto;
            box-sizing: border-box;
        }

        .main-layout {
            display: flex;
            gap: 5px;
            align-items: flex-start;
            flex-direction: row;
            width: 100%;
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        .left-section {
            flex: 1 1 calc(50% - 2.5px);
            min-width: 0;
            background: white;
            border-radius: 16px;
            padding: 25px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            border: 1px solid #e9ecef;
            box-sizing: border-box;
        }

        .right-section {
            flex: 1 1 calc(50% - 2.5px);
            min-width: 0;
            background: white;
            border-radius: 16px;
            padding: 25px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            border: 1px solid #e9ecef;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
        }

        /* Ensure log container takes available space */
        .log-container {
            flex: 1;
            min-height: 0;
            overflow-y: auto;
        }

        /* Ensure log actions stay at bottom */
        .log-actions {
            margin-top: auto;
            flex-shrink: 0;
        }

        .form-row {
            display: flex;
            gap: 30px;
            margin-bottom: 20px;
        }

        .form-column {
            flex: 1;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
            font-size: 14px;
        }

        .form-group input, .form-group textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s ease;
            font-family: inherit;
        }

        .form-group input:focus, .form-group textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .form-group input::placeholder, .form-group textarea::placeholder {
            color: #999;
        }

        .form-group textarea {
            resize: none;
            min-height: 80px;
            transition: all 0.3s ease;
        }

        .form-group textarea.auto-resize {
            min-height: 80px;
            height: auto;
            overflow: hidden;
        }



        /* Popup styles */
        .popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .popup {
            background: white;
            border-radius: 12px;
            padding: 25px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            position: relative;
        }

        .popup-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #f0f0f0;
        }

        .popup-title {
            font-size: 20px;
            font-weight: 600;
            color: #333;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #999;
            padding: 5px;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .close-btn:hover {
            background-color: #f0f0f0;
            color: #333;
        }

        .toko-list {
            display: grid;
            gap: 15px;
        }

        .toko-item {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            transition: all 0.3s ease;
        }

        .toko-item:hover {
            background: #e9ecef;
            border-color: #667eea;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .toko-nama {
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
            font-size: 16px;
        }

        .toko-alamat {
            color: #666;
            line-height: 1.5;
            white-space: pre-line;
            font-size: 14px;
        }

        .show-list-btn {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            border: none;
            padding: 15px 25px;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 0;
            min-width: 180px;
            position: relative;
            overflow: hidden;
        }

        .show-list-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }

        .show-list-btn:hover::before {
            left: 100%;
        }

        .show-list-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(40, 167, 69, 0.4);
        }

        .show-list-btn:active {
            transform: translateY(-1px);
        }

        .show-list-btn.hidden {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
        }

        .show-list-btn.hidden:hover {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
        }

        .btn-add {
            background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
            color: white;
            border: none;
            padding: 15px 25px;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 180px;
            position: relative;
            overflow: hidden;
        }

        .btn-add::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }

        .btn-add:hover::before {
            left: 100%;
        }

        .btn-add:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 123, 255, 0.4);
        }

        .btn-add:active {
            transform: translateY(-1px);
        }

        .btn-add.hidden {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
        }

        .btn-add.hidden:hover {
            background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
        }

        .toggle-buttons-btn {
            background: linear-gradient(135deg, #6f42c1 0%, #5a32a3 100%);
            color: white;
            border: none;
            padding: 10px 18px;
            border-radius: 25px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(111, 66, 193, 0.3);
        }

        .toggle-buttons-btn.right-section {
            position: relative;
            top: auto;
            right: auto;
            margin-bottom: 20px;
            width: 100%;
        }

        .toggle-buttons-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(111, 66, 193, 0.4);
        }

        .toggle-buttons-btn:active {
            transform: translateY(0);
        }



        /* Container baru untuk tombol utama */
        .main-actions-container {
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            border: 2px solid #e9ecef;
            border-radius: 16px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            transition: all 0.3s ease;
        }

        .main-actions-container.hidden {
            display: none;
        }

        .main-actions-container:not(.hidden) {
            display: block;
            animation: slideIn 0.3s ease-out;
        }



        .main-actions-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Action buttons styles */
        .action-buttons {
            display: flex;
            gap: 8px;
            margin-top: 15px;
            justify-content: center;
        }

        .btn-edit {
            background: linear-gradient(135deg, #ffc107 0%, #e0a800 100%);
            color: #212529;
            border: none;
            padding: 10px 18px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 80px;
            height: 38px;
            box-sizing: border-box;
        }

        .btn-delete {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
            color: white;
            border: none;
            padding: 10px 18px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 80px;
            height: 38px;
            box-sizing: border-box;
        }

        .btn-edit:hover, .btn-delete:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.25);
        }

        .btn-edit:active, .btn-delete:active {
            transform: translateY(0);
        }

        /* Autocomplete styles */
        .autocomplete-container {
            position: relative;
            width: 100%;
        }

        .autocomplete-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-top: none;
            border-radius: 0 0 8px 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            max-height: 200px;
            overflow-y: auto;
            display: none;
        }

        .autocomplete-item {
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
            transition: background-color 0.2s ease;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .autocomplete-item:last-child {
            border-bottom: none;
        }

        .autocomplete-item:hover {
            background-color: #f8f9fa;
        }

        .autocomplete-item.selected {
            background-color: #e3f2fd;
            color: #1976d2;
        }

        .autocomplete-item-icon {
            font-size: 16px;
            color: #666;
        }

        .autocomplete-item-text {
            flex: 1;
        }

        .autocomplete-item-name {
            font-weight: 600;
            color: #333;
            margin-bottom: 4px;
        }

        .autocomplete-item-address {
            font-size: 12px;
            color: #666;
            line-height: 1.3;
        }

        .no-results {
            padding: 16px;
            text-align: center;
            color: #666;
            font-style: italic;
        }

        /* Input field dengan icon */
        .input-with-icon {
            position: relative;
            width: 100%;
        }

        .input-with-icon input {
            padding-right: 45px;
        }

        .input-icon,
        button.input-icon,
        button.input-icon[type="button"] {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            background: transparent !important;
            background-color: transparent !important;
            border: none !important;
            cursor: pointer;
            padding: 6px !important;
            border-radius: 50% !important;
            transition: all 0.3s ease;
            color: #667eea !important;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: normal !important;
        }

        .input-icon svg {
            width: 18px;
            height: 18px;
            transition: all 0.3s ease;
        }

        .input-icon svg {
            transform-origin: center;
        }

        .input-icon svg {
            transform-origin: center;
        }

        .input-icon svg line {
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            transform-origin: center;
        }

        .input-icon svg line:nth-child(1) {
            transform: rotate(0deg);
        }

        .input-icon svg line:nth-child(2) {
            transform: rotate(0deg);
        }

        .input-icon:hover,
        button.input-icon:hover,
        button.input-icon[type="button"]:hover {
            background: transparent !important;
            background-color: transparent !important;
            color: #dc3545 !important;
            transform: translateY(-50%) scale(1.1);
        }

        .input-icon:hover svg line:nth-child(1) {
            transform: rotate(140deg);
            transform-origin: center;
        }

        .input-icon:hover svg line:nth-child(2) {
            transform: rotate(-45deg);
            transform-origin: center;
        }

        .input-icon:hover svg {
            stroke-width: 2.5;
        }

        .input-icon:active,
        button.input-icon:active,
        button.input-icon[type="button"]:active,
        .input-icon:focus,
        button.input-icon:focus,
        button.input-icon[type="button"]:focus {
            transform: translateY(-50%) scale(0.95);
            background: transparent !important;
            background-color: transparent !important;
            outline: none !important;
            box-shadow: none !important;
        }

        /* Form modal styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        /* Ensure Edit Toko modal overlays above Quick Add modal */
        #quickAddModalOverlay {
            z-index: 2000; /* base */
        }
        #modalOverlay {
            z-index: 3000; /* above quick add */
        }

        .modal {
            background: white;
            border-radius: 12px;
            padding: 25px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            position: relative;
        }

        .modal.quick-add {
            max-width: 500px;
            width: 90%;
            padding: 20px;
        }

        .modal.quick-add .modal-title {
            font-size: 18px;
            margin-bottom: 20px;
        }

        .modal.quick-add .modal-form {
            gap: 15px;
        }

        .modal.quick-add .modal-form input,
        .modal.quick-add .modal-form textarea {
            padding: 12px;
            font-size: 14px;
            width: 100%;
            box-sizing: border-box;
        }

        .modal.quick-add .modal-actions {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .modal.quick-add .btn-save,
        .modal.quick-add .btn-cancel {
            padding: 10px 20px;
            font-size: 14px;
            min-width: 80px;
        }

        /* Quick Tabs Styles */
        .quick-tabs {
            display: flex;
            gap: 2px;
            margin-bottom: 25px;
            background: #f8f9fa;
            border-radius: 8px;
            padding: 4px;
        }

        .tab-btn {
            flex: 1;
            background: none;
            border: none;
            padding: 12px 20px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            color: #666;
        }

        .tab-btn.active {
            background: white;
            color: #333;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .tab-btn:hover:not(.active) {
            background: #e9ecef;
            color: #333;
        }

        .tab-content {
            position: relative;
        }

        .tab-pane {
            display: none;
        }

        .tab-pane.active {
            display: block;
            animation: fadeIn 0.3s ease-in;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Quick List Styles */
        .quick-list-container {
            max-height: 300px;
            overflow-y: auto;
        }

        .quick-list-header {
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #e9ecef;
        }

        .quick-list-header h4 {
            margin: 0 0 8px 0;
            color: #333;
            font-size: 16px;
        }

        .quick-list-header p {
            margin: 0;
            color: #666;
            font-size: 13px;
        }

        .quick-toko-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .quick-toko-item {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .quick-toko-item:hover {
            background: #e9ecef;
            border-color: #007bff;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 123, 255, 0.15);
        }

        .quick-toko-name {
            font-weight: 600;
            color: #333;
            margin-bottom: 6px;
            font-size: 14px;
        }

        .quick-toko-address {
            color: #666;
            font-size: 12px;
            line-height: 1.4;
            white-space: pre-line;
        }

        /* Actions inside quick list items */
        .quick-toko-actions {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }

        .quick-toko-item .btn-edit,
        .quick-toko-item .btn-delete {
            padding: 6px 10px;
            min-width: auto;
            font-size: 12px;
            height: 38px;
            box-sizing: border-box;
        }

        /* Quick list export/import actions */
        .quick-list-actions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
            flex-wrap: wrap;
			flex-direction: column;
        }
        .btn-export-toko {
            background: linear-gradient(135deg, #6f42c1 0%, #5a32a3 100%);
            color: #fff;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
        }
        .btn-import-toko {
            background: linear-gradient(135deg, #0d6efd 0%, #0b5ed7 100%);
            color: #fff;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
        }

        /* Inline field warning (e.g., for duplicate No. SJ) */
        .field-warning {
            color: #dc3545;
            font-size: 12px;
            margin-top: 6px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .has-warning {
            border-color: #dc3545 !important;
            box-shadow: 0 0 0 3px rgba(220, 53, 69, 0.1);
        }

        /* Container Data Kaca Styles */
        .kaca-data-container {
            background: white;
            border-radius: 16px;
            padding: 10px;
            margin-bottom: 30px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            border: 1px solid #e9ecef;
            width: 100%;
        }

        .kaca-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 6px;
            border-bottom: 2px solid #f0f0f0;
        }

        .kaca-header h3 {
            margin: 0;
            color: #333;
            font-size: 18px;
            font-weight: 600;
        }

        .btn-refresh-page {
            background: linear-gradient(135deg, #0dcaf0 0%, #0d6efd 100%);
            color: #fff;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            height: 38px;
            box-sizing: border-box;
        }
        .btn-refresh-page:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(13, 110, 253, 0.25);
        }

        .kaca-controls {
            display: flex;
            gap: 10px;
        }

        .btn-add-row, .btn-remove-row {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            height: 38px;
            box-sizing: border-box;
        }

        .btn-print {
            background: linear-gradient(135deg, #17a2b8 0%, #138496 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            height: 38px;
            box-sizing: border-box;
        }
        .kaca-controls .btn-print-now {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            height: 38px;
            box-sizing: border-box;
        }

        .btn-remove-row {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
        }

        .btn-add-row:hover, .btn-remove-row:hover, .btn-print:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .kaca-table-container {
            overflow-x: auto;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }

        .kaca-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
        }

        .kaca-table th {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            color: #333;
            font-weight: 600;
            padding: 15px 12px;
            text-align: center;
            border-bottom: 2px solid #dee2e6;
            font-size: 14px;
        }

        .kaca-table td {
            padding: 12px;
            border-bottom: 1px solid #f0f0f0;
            text-align: center;
            vertical-align: middle;
        }

        .kaca-table tbody tr:hover {
            background-color: #f8f9fa;
        }

        .kaca-table tbody tr {
            transition: background-color 0.3s ease;
        }

        .kaca-table input {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 13px;
            text-align: left;
            transition: border-color 0.3s ease;
        }

        .kaca-table input[type="number"] {
            -moz-appearance: textfield;
            appearance: textfield;
        }

        .kaca-table input[type="number"]::-webkit-outer-spin-button,
        .kaca-table input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        /* Tooltip untuk harga beli */
        .harga-tooltip {
            position: fixed;
            background: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            z-index: 10000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            pointer-events: none;
            white-space: nowrap;
            animation: tooltipFadeIn 0.2s ease;
        }

        @keyframes tooltipFadeIn {
            from {
                opacity: 0;
                transform: translateY(-5px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .kaca-table .box-input {
            position: relative;
        }

        .kaca-table .box-input input {
            padding-right: 25px;
        }

        .kaca-table .box-input::after {
            content: "";
            position: absolute;
            right: 70px;
            top: 49%;
            transform: translateY(-50%);
            color: #666;
            font-size: 12px;
            font-weight: 500;
            pointer-events: none;
        }

        .kaca-table .lbr-input {
            position: relative;
        }

        .kaca-table .lbr-input input {
            padding-right: 25px;
        }

        .kaca-table .lbr-input::after {
            content: "";
            position: absolute;
            right: 70px;
            top: 49%;
            transform: translateY(-50%);
            color: #666;
            font-size: 12px;
            font-weight: 500;
            pointer-events: none;
        }

        .kaca-table .total-lbr-input {
            position: relative;
        }

        .kaca-table .total-lbr-input input {
            padding-right: 25px;
        }

        .kaca-table .total-lbr-input::after {
            content: "";
            position: absolute;
            right: 95px;
            top: 49%;
            transform: translateY(-50%);
            color: #666;
            font-size: 12px;
            font-weight: 500;
            pointer-events: none;
        }

        /* Total row styles */
        .kaca-table tfoot {
            border-top: 2px solid #dee2e6;
        }

        .kaca-table .total-row {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
        }

        .kaca-table .total-row:hover {
            background: linear-gradient(135deg, #e9ecef 0%, #dee2e6 100%);
        }



        .kaca-table .grand-total {
            background: #f8f9fa;
            border-radius: 6px;
            margin: 2px;
        }

        .kaca-table .grand-total input {
            background: transparent;
            color: #333;
            font-weight: 600;
            font-size: 14px;
            border: none;
        }

        .kaca-table .grand-total::after {
            color: #666;
            font-weight: 600;
        }

        /* Total inputs styling */
        .kaca-table .total-inputs {
            padding: 8px 12px;
        }

        .kaca-table .total-input-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .kaca-table .cont-input,
        .kaca-table .seal-input {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 12px;
            text-align: left;
            transition: border-color 0.3s ease;
            background: white;
        }

        .kaca-table .cont-input:focus,
        .kaca-table .seal-input:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.1);
        }

        .kaca-table .cont-input::placeholder,
        .kaca-table .seal-input::placeholder {
            color: #999;
            font-size: 11px;
        }

        /* PWD column styling */
        .kaca-table .pwd-input {
            width: 60px;
            min-width: 60px;
            max-width: 60px;
        }

        .kaca-table .pwd-input input {
            width: 100%;
            padding: 8px 4px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 11px;
            text-align: center;
            text-transform: uppercase;
            transition: border-color 0.3s ease;
            background: white;
        }

        .kaca-table .pwd-input input:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.1);
        }

        .kaca-table .pwd-input input::placeholder {
            color: #999;
            font-size: 10px;
        }

        /* No DO column styling */
        .kaca-table .no-do-input {
            width: 100px;
            min-width: 100px;
            max-width: 100px;
        }

        .kaca-table .no-do-input input {
            width: 100%;
            padding: 8px 6px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 11px;
            text-align: left;
            transition: border-color 0.3s ease;
            background: white;
        }

        .kaca-table .no-do-input input:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.1);
        }

        .kaca-table .no-do-input input::placeholder {
            color: #999;
            font-size: 10px;
        }

        .kaca-table input:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.1);
        }

        .kaca-table .total-lbr {
            background-color: #f8f9fa;
            font-weight: 600;
            color: #333;
        }

        .kaca-table .total-lbr input {
            background-color: transparent;
            font-weight: 600;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #f0f0f0;
        }

        .modal-title {
            font-size: 16px;
            font-weight: 600;
            color: #333;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: #999;
            padding: 4px;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .modal-close:hover {
            background-color: #f0f0f0;
            color: #333;
        }

        .modal-form {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .modal-form input, .modal-form textarea {
            padding: 12px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 14px;
            font-family: inherit;
        }

        .modal-form input:focus, .modal-form textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .modal-form textarea {
            resize: vertical;
            min-height: 80px;
        }

        .modal-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }

        .btn-save {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-cancel {
            background: #6c757d;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-save:hover, .btn-cancel:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        
        /* Responsive untuk mobile */
        @media (max-width: 768px) {
            .form-container {
                padding: 20px;
                max-width: 100%;
                width: 100%;
                box-sizing: border-box;
            }

            .main-layout {
                flex-direction: column;
                gap: 20px;
                align-items: stretch;
                width: 100%;
            }

            .left-section, .right-section {
                width: 100% !important;
                padding: 20px;
                min-height: auto;
                box-sizing: border-box;
            }

            .right-section {
                display: flex;
                flex-direction: column;
            }

            .log-container {
                flex: 1;
                min-height: 300px;
                max-height: 400px;
            }

            .log-actions {
                margin-top: 20px;
                flex-shrink: 0;
            }

            .form-row {
                flex-direction: column;
                gap: 20px;
            }

            .popup {
                width: 95%;
                padding: 20px;
            }

            .toggle-buttons-btn {
                top: 15px;
                right: 15px;
                padding: 6px 12px;
                font-size: 11px;
            }

            .toggle-buttons-btn.right-section {
                position: relative;
                top: auto;
                right: auto;
                margin-bottom: 20px;
                width: 100%;
            }

            .main-actions-container {
                padding: 20px;
                margin-bottom: 20px;
            }

            .main-actions-buttons {
                flex-direction: column;
                gap: 15px;
            }

            /* Print modal responsive */
            .print-modal {
                width: 98%;
                max-width: none;
                margin: 10px;
            }

            .print-textarea-container {
                width: 100%;
                max-width: 813px; /* F4 width */
                height: auto;
                min-height: 600px;
            }

            .print-actions {
                flex-direction: column;
                gap: 10px;
            }

            .btn-lock-position, .btn-print-now {
                min-width: 100%;
            }
        }

        @media (max-width: 1200px) {
            .form-container {
                max-width: 95%;
                padding: 25px;
            }
        }

        @media (max-width: 1400px) {
            .form-container {
                max-width: 95%;
            }
        }

        /* Print Modal Styles */
        .print-modal {
            max-width: 1000px;
            width: 95%;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
        }

        .print-content {
            display: flex;
            flex-direction: column;
            gap: 15px;
            height: 100%;
            overflow: hidden;
        }

        .print-textarea-container {
            flex: 1;
            min-height: 300px;
            max-height: 50vh;
            position: relative;
            overflow: auto;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            background: #fafafa;
            background-image: 
                linear-gradient(rgba(0,0,0,0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0,0,0,0.1) 1px, transparent 1px);
            background-size: 20px 20px;
            /* F4 dimensions */
            width: 813px;
            height: 1247px;
            margin: 0 auto;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }

        /* Custom scrollbar styling */
        .print-textarea-container::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }

        .print-textarea-container::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 6px;
        }

        .print-textarea-container::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 6px;
        }

        .print-textarea-container::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }

        .print-textarea-container::-webkit-scrollbar-corner {
            background: #f1f1f1;
        }

        .print-textarea-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 813px; /* F4 width */
            height: 1247px; /* F4 height */
            background-image: 
                linear-gradient(rgba(0,0,0,0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0,0,0,0.05) 1px, transparent 1px);
            background-size: 5px 5px;
            pointer-events: none;
            z-index: 1;
        }

        .print-text-content {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 20px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-family: 'Roboto Mono', 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
            user-select: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            min-width: 300px;
            max-width: 600px;
            white-space: pre-wrap;
            transition: box-shadow 0.2s ease;
        }

        .draggable-text-item {
            position: absolute;
            background: white;
            padding: 4px 8px;
            border: 1px solid #e1e5e9;
            border-radius: 4px;
            font-family: 'Roboto Mono', 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.2;
            cursor: move;
            user-select: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: box-shadow 0.2s ease, border-color 0.2s ease, transform 0.15s ease;
            z-index: 10;
            max-width: none;
            white-space: nowrap;
            overflow: visible;
            text-overflow: clip;
            min-height: auto;
            height: auto;
            display: inline-flex;
            align-items: flex-start;
            touch-action: none;
            width: fit-content;
        }

        .draggable-text-item.selected {
            border: 2px solid #667eea;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
            background-color: #f0f4ff;
            z-index: 20;
        }

        /* Ensure selected draggable text is black in print modal */
        #printModalOverlay .draggable-text-item.selected,
        #printModalOverlay .draggable-text-item.selected .text-content {
            color: #000 !important;
        }

        /* Force 8th draggable item (index 7) text to black and neutral background/border */
        #printModalOverlay .print-textarea-container .draggable-text-item[data-index="7"],
        #printModalOverlay .print-textarea-container .draggable-text-item[data-index="7"] .text-content {
            color: #000 !important;
        }
        #printModalOverlay .print-textarea-container .draggable-text-item[data-index="7"] {
            border-color: #e1e5e9 !important;
            background-color: #fff !important;
        }

        /* Ensure kaca-data (index 6) preserves newlines and wraps lines */
        #printModalOverlay .print-textarea-container .draggable-text-item[data-index="6"],
        #printModalOverlay .print-textarea-container .draggable-text-item[data-index="6"] .text-content {
            white-space: pre-wrap !important;
        }

        /* Make left column narrower on desktop */
        @media (min-width: 1024px) {
            .left-section { flex: 0 0 42%; max-width: 42%; }
            .right-section { flex: 1 1 58%; max-width: 58%; }
        }

        .draggable-text-item:hover {
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
            border-color: #667eea;
            transform: translateY(-1px);
        }

        .draggable-text-item.dragging {
            cursor: grabbing;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            transition: none;
            border-color: #667eea;
            background-color: #f8f9ff;
            transform: scale(1.02) rotate(1deg);
        }

        .draggable-text-item:active {
            cursor: grabbing;
            transform: scale(0.98);
        }

        .draggable-text-item::before {
            content: '⋮⋮';
            position: absolute;
            left: 4px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 12px;
            color: #999;
            pointer-events: none;
            font-weight: bold;
            transition: color 0.2s ease;
        }

        .draggable-text-item:hover::before {
            color: #667eea;
        }

        .draggable-text-item.dragging::before {
            color: #667eea;
            animation: pulse 0.5s ease-in-out infinite alternate;
        }

        .draggable-text-item.locked::before {
            color: #28a745;
        }

        @keyframes pulse {
            from {
                opacity: 0.7;
                transform: translateY(-50%) scale(1);
            }
            to {
                opacity: 1;
                transform: translateY(-50%) scale(1.1);
            }
        }

        .draggable-text-item .text-content {
            margin-left: 16px;
            flex: 1;
            white-space: nowrap;
            overflow: visible;
            min-width: 0;
        }

        /* Override for address element text content */
        .draggable-text-item.address-element .text-content {
            white-space: pre-wrap !important;
            word-wrap: break-word !important;
            margin-left: 16px;
            flex: 1;
            overflow: visible;
            min-width: 0;
        }

        /* Ensure print actions are always visible */
        .print-actions {
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding: 15px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 12px;
            border: 1px solid #dee2e6;
            margin-top: 0px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            max-height: 70vh;
            overflow-y: auto;
            flex-shrink: 0;
        }

        /* Custom scrollbar for print actions */
        .print-actions::-webkit-scrollbar {
            width: 8px;
        }

        .print-actions::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }

        .print-actions::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 4px;
        }

        .print-actions::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }

        /* Ensure modal content is properly sized */
        .modal.print-modal {
            max-height: 90vh;
            overflow: hidden;
        }

        .modal.print-modal .modal-header {
            flex-shrink: 0;
        }

        .modal.print-modal .print-content {
            flex: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .modal.print-modal .print-textarea-container {
            flex: 1;
            min-height: 200px;
            max-height: 40vh;
        }

        .modal.print-modal .print-actions {
            flex-shrink: 0;
            max-height: 45vh;
        }

        .btn-print-now {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            border: none;
            padding: 14px 24px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 150px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(40, 167, 69, 0.3);
            height: 38px;
            box-sizing: border-box;
        }

        /* Make save/export/import buttons match print-now style with color variations */
        .btn-save-positions,
        .btn-export-positions,
        .btn-import-positions {
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 130px;
            position: relative;
            overflow: hidden;
        }

        .btn-save-positions {
            background: linear-gradient(135deg, #007bff 0%, #17a2b8 100%);
            box-shadow: 0 4px 15px rgba(0, 123, 255, 0.3);
        }
        .btn-save-positions:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 123, 255, 0.4);
        }

        .btn-export-positions {
            background: linear-gradient(135deg, #6f42c1 0%, #5a32a3 100%);
            box-shadow: 0 4px 15px rgba(111, 66, 193, 0.3);
        }
        .btn-export-positions:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(111, 66, 193, 0.4);
        }

        .btn-import-positions {
            background: linear-gradient(135deg, #fd7e14 0%, #ffc107 100%);
            color: #212529;
            box-shadow: 0 4px 15px rgba(253, 126, 20, 0.3);
        }
        .btn-import-positions:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(253, 126, 20, 0.4);
        }

        .btn-print-now::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }

        .btn-print-now:hover::before {
            left: 100%;
        }

        .btn-print-now:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(40, 167, 69, 0.4);
        }

        .btn-cancel {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
            color: white;
            border: none;
            padding: 14px 24px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 120px;
            box-shadow: 0 4px 15px rgba(108, 117, 125, 0.3);
        }

        .btn-cancel:hover {
            background: linear-gradient(135deg, #5a6268 0%, #343a40 100%);
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(108, 117, 125, 0.4);
        }

        .btn-lock-position {
            background: linear-gradient(135deg, #6f42c1 0%, #5a32a3 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 130px;
            box-shadow: 0 4px 15px rgba(111, 66, 193, 0.3);
        }

        .btn-lock-position:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(111, 66, 193, 0.4);
        }

        .btn-lock-position.locked {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            box-shadow: 0 3px 10px rgba(40, 167, 69, 0.3);
        }

        .btn-reset-positions {
            background: linear-gradient(135deg, #ffc107, #fd7e14);
            color: #212529;
            border: 2px solid #ffc107;
            padding: 12px 20px;
            border-radius: 8px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 13px;
            min-width: 130px;
            box-shadow: 0 4px 15px rgba(255, 193, 7, 0.3);
        }
        
        .btn-reset-positions:hover {
            background: linear-gradient(135deg, #fd7e14, #e55a00);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(255, 193, 7, 0.4);
        }

        .draggable-text-item.locked {
            opacity: 0.8;
            border-color: #28a745;
            background-color: #f8fff9 !important;
        }

        .draggable-text-item.locked:hover {
            box-shadow: 0 4px 8px rgba(40, 167, 69, 0.2);
        }

        .draggable-text-item.locked::before {
            color: #28a745;
        }

        .position-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 0, 0.1);
            pointer-events: none;
            z-index: 9999;
        }

        /* Special styling for long text elements */
        .draggable-text-item[data-type="kaca-data"] {
            padding: 4px 8px;
            max-width: 400px;
            width: auto;
            white-space: pre-wrap !important;
            word-wrap: break-word !important;
            line-height: 1.2;
            height: auto;
            min-height: auto;
            overflow: visible;
        }

        .draggable-text-item[data-type="data"] {
            padding: 4px 8px;
            width: fit-content;
        }

        .draggable-text-item[data-type="total"] {
            padding: 4px 8px;
            width: fit-content;
            font-weight: bold;
        }

        /* Special styling for address element */
        .draggable-text-item[data-index="1"] {
            white-space: pre-wrap !important;
            word-wrap: break-word !important;
            max-width: 300px !important;
            width: auto !important;
            height: auto !important;
            min-height: auto !important;
            line-height: 1.3 !important;
            padding: 6px 10px !important;
            overflow: visible !important;
        }

        /* Alternative selector for address element */
        .draggable-text-item.address-element {
            white-space: pre-wrap !important;
            word-wrap: break-word !important;
            max-width: 300px !important;
            width: auto !important;
            height: auto !important;
            min-height: auto !important;
            line-height: 1.3 !important;
            padding: 6px 10px !important;
            overflow: visible !important;
        }

        /* Font Controls Styling */
        .font-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .font-controls label {
            font-size: 12px;
            font-weight: 600;
            color: #333;
            white-space: nowrap;
            min-width: 70px;
        }

        .font-controls select {
            padding: 8px 12px;
            border: 2px solid #e1e5e9;
            border-radius: 6px;
            font-size: 12px;
            background: white;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 120px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
        }

        .font-controls select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1), 0 4px 12px rgba(102, 126, 234, 0.15);
        }

        .font-controls select:hover {
            border-color: #667eea;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        /* Kaca-data fixed columns layout across fonts */
        .kd-block { display: block; }
        .kd-row { white-space: nowrap; line-height: 1.2; }
        .kd-cell {
            display: inline-block;
            font-family: 'Roboto Mono', 'Courier New', monospace; /* measurement font for width */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: clip;
            vertical-align: top;
        }
        .kd-cell.left { text-align: left; }
        .kd-cell.center { text-align: center; }
        .kd-cell.right { text-align: right; }
        .kd-text { display: inline; }

        /* Ensure kaca-data container allows multi-line content */
        .draggable-text-item[data-type="kaca-data"] { white-space: pre-wrap !important; align-items: stretch; }
        .draggable-text-item[data-type="kaca-data"] .text-content { white-space: pre-wrap !important; display: block; }

        .print-kaca-data {
            font-size: 8px;
            max-width: 400px;
            white-space: pre-wrap;
            word-wrap: break-word;
            line-height: 1.2;
            overflow: visible;
        }

        /* Column Spacing Controls Styling */
        .column-spacing-controls {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #e9ecef;
            margin-right: 10px;
        }

        .column-spacing-controls label {
            font-size: 13px;
            font-weight: 600;
            color: #333;
            white-space: nowrap;
            min-width: 80px;
        }

        .column-spacing-controls select {
            padding: 6px 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 12px;
            background: white;
            cursor: pointer;
            transition: border-color 0.3s ease;
        }

        .column-spacing-controls select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
        }

        .column-spacing-controls select:hover {
            border-color: #667eea;
        }

        /* Individual Column Controls */
        .individual-column-controls {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .column-controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 10px;
        }

        .column-control-item {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .column-control-item label {
            font-size: 12px;
            font-weight: 600;
            color: #555;
            margin: 0;
        }

        .column-control-item input {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 12px;
            text-align: center;
            transition: all 0.3s ease;
            background: white;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }

        .column-control-item input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1), 0 4px 12px rgba(102, 126, 234, 0.15);
        }

        .column-control-item input:hover {
            border-color: #667eea;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        /* Quick Preset Buttons */
        .spacing-presets {
            display: flex;
            align-items: center;
            gap: 6px;
            flex-wrap: wrap;
            padding-top: 6px;
            border-top: 1px solid #f0f0f0;
        }

        .preset-label {
            font-size: 11px;
            font-weight: 600;
            color: #666;
            margin-right: 4px;
        }

        .preset-btn {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border: 2px solid #e9ecef;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            color: #666;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
        }

        .preset-btn:hover {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: #667eea;
            transform: translateY(-1px);
            box-shadow: 0 4px 10px rgba(102, 126, 234, 0.3);
        }

        .preset-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: #667eea;
            box-shadow: 0 3px 8px rgba(102, 126, 234, 0.3);
        }

        /* Special styling for kaca-data elements */
        .draggable-text-item[data-type="kaca-data"] {
            padding: 6px 10px !important;
            max-width: none !important;
            width: auto !important;
            white-space: pre-wrap !important;
            word-wrap: break-word !important;
            line-height: 1.3 !important;
            height: auto !important;
            min-height: auto !important;
            overflow: visible !important;
            background-color: #f8f9ff !important;
        }

        .draggable-text-item[data-type="kaca-data"] .text-content {
            white-space: pre-wrap !important;
            word-wrap: break-word !important;
            overflow: visible !important;
            min-width: 0 !important;
        }

        /* Position Controls */
        .position-controls {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .btn-lock-position {
            background: linear-gradient(135deg, #6f42c1 0%, #5a32a3 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 110px;
            box-shadow: 0 3px 10px rgba(111, 66, 193, 0.3);
        }

        .btn-reset-positions {
            background: linear-gradient(135deg, #ffc107, #fd7e14);
            color: #212529;
            border: 2px solid #ffc107;
            padding: 8px 16px;
            border-radius: 6px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
            min-width: 110px;
            box-shadow: 0 3px 10px rgba(255, 193, 7, 0.3);
        }

        /* Action Controls */
        .action-controls {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .btn-print-now {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 130px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 3px 10px rgba(40, 167, 69, 0.3);
            height: 38px;
            box-sizing: border-box;
        }

        .btn-cancel {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 100px;
            box-shadow: 0 3px 10px rgba(108, 117, 125, 0.3);
        }

        /* Print Controls Sections */
        .print-controls-section {
            background: white;
            border-radius: 8px;
            padding: 12px;
            border: 1px solid #e9ecef;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
            transition: all 0.3s ease;
        }
        .controls-section-header {
            display: flex;
            align-items: center;
            justify-content: start;
            gap: 5px;
            margin-bottom: 5px;
        }

        .print-controls-section:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .controls-section-title {
            margin: 0 0 10px 0;
            font-size: 13px;
            font-weight: 700;
            color: #2c3e50;
            padding-bottom: 6px;
            border-bottom: 2px solid #667eea;
            position: relative;
        }

        .controls-section-title::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            width: 25px;
            height: 2px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 1px;
        }

        /* Individual Column Controls Styling */
        .individual-column-controls {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .column-controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 10px;
        }

        .column-control-item {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .column-control-item label {
            font-size: 12px;
            font-weight: 600;
            color: #555;
            margin: 0;
        }

        .column-control-item input {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 12px;
            text-align: center;
            transition: all 0.3s ease;
            background: white;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }

        .column-control-item input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1), 0 4px 12px rgba(102, 126, 234, 0.15);
        }

        .column-control-item input:hover {
            border-color: #667eea;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        /* Responsive Design for Print Actions */
        @media (max-width: 768px) {
            .print-actions {
                padding: 12px;
                gap: 10px;
                max-height: 60vh;
            }

            .print-controls-section {
                padding: 10px;
            }

            .controls-section-title {
                font-size: 12px;
                margin-bottom: 8px;
            }

            .font-controls {
                flex-direction: column;
                align-items: flex-start;
                gap: 6px;
            }

            .font-controls select {
                min-width: 100%;
            }

            .column-controls-grid {
                grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
                gap: 5px;
            }

            .spacing-presets {
                flex-direction: column;
                align-items: flex-start;
                gap: 4px;
            }

            .preset-label {
                margin-bottom: 2px;
            }

            .position-controls,
            .action-controls {
                flex-direction: column;
                gap: 6px;
            }

            .btn-lock-position,
            .btn-reset-positions,
            .btn-print-now,
            .btn-cancel {
                min-width: 100%;
                text-align: center;
                padding: 8px 16px;
            }
        }

        @media (max-width: 480px) {
            .print-actions {
                padding: 8px;
                gap: 8px;
                max-height: 50vh;
            }

            .print-controls-section {
                padding: 8px;
            }

            .column-controls-grid {
                grid-template-columns: 1fr;
                gap: 4px;
            }

            .controls-section-title {
                font-size: 11px;
            }

            .btn-lock-position,
            .btn-reset-positions,
            .btn-print-now,
            .btn-cancel {
                padding: 6px 12px;
                font-size: 12px;
            }
        }

        /* Font Controls Styling */
        .font-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .font-controls label {
            font-size: 12px;
            font-weight: 600;
            color: #333;
            white-space: nowrap;
            min-width: 70px;
        }

        .font-controls select {
            padding: 8px 12px;
            border: 2px solid #e1e5e9;
            border-radius: 6px;
            font-size: 12px;
            background: white;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 120px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
        }

        /* Individual Column Controls Styling */
        .individual-column-controls {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .column-controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 6px;
        }

        .column-control-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .column-control-item label {
            font-size: 11px;
            font-weight: 600;
            color: #555;
            margin: 0;
        }

        .column-control-item input {
            width: 100%;
            padding: 6px 8px;
            border: 2px solid #e1e5e9;
            border-radius: 6px;
            font-size: 11px;
            text-align: center;
            transition: all 0.3s ease;
            background: white;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
        }

        /* Smooth transitions for column spacing updates */
        .print-textarea-container {
            transition: all 0.3s ease;
        }

        .controls-section-title {
            transition: color 0.3s ease;
        }

        /* Visual feedback for column spacing changes */
        .column-control-item input {
            transition: all 0.3s ease;
        }

        .column-control-item input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1), 0 4px 12px rgba(102, 126, 234, 0.15);
            transform: translateY(-1px);
        }

        /* Loading indicator for column spacing updates */
        .column-spacing-loading {
            position: relative;
        }

        .column-spacing-loading::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 6px;
            pointer-events: none;
            animation: pulse 1s ease-in-out infinite;
        }

        @keyframes pulse {
            0% { opacity: 0.3; }
            50% { opacity: 0.6; }
            100% { opacity: 0.3; }
        }

        /* Special styling for kaca-data elements with TOTAL LBR column */
        .draggable-text-item[data-type="kaca-data"] {
            padding: 6px 10px !important;
            max-width: none !important;
            width: auto !important;
            white-space: pre-wrap !important;
            word-wrap: break-word !important;
            line-height: 1.3 !important;
            height: auto !important;
            min-height: auto !important;
            overflow: visible !important;
            background-color: #f8f9ff !important;
            border: 1px solid #e1e5e9 !important;
        }

        .draggable-text-item[data-type="kaca-data"] .text-content {
            white-space: pre-wrap !important;
            word-wrap: break-word !important;
            overflow: visible !important;
            min-width: 0 !important;
            font-size: inherit !important;
        }

        /* Highlight TOTAL LBR column in kaca-data */
        .draggable-text-item[data-type="kaca-data"] .text-content {
            position: relative;
        }

        /* Add visual separator for columns in kaca-data */
        .draggable-text-item[data-type="kaca-data"] .text-content::before {
            content: '';
            position: absolute;
            top: 0;
            bottom: 0;
            left: 0;
            width: 100%;
            background: linear-gradient(90deg, 
                transparent 0%, 
                transparent calc(100% - 80px), 
                rgba(102, 126, 234, 0.1) calc(100% - 80px), 
                rgba(102, 126, 234, 0.1) 100%);
            pointer-events: none;
            z-index: -1;
        }

        /* Log System Styles */
        .log-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #f0f0f0;
        }

        .log-header h3 {
            margin: 0;
            color: #333;
            font-size: 18px;
            font-weight: 600;
        }

        .btn-clear-log {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            height: 38px;
            box-sizing: border-box;
        }

        .btn-clear-log:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(220, 53, 69, 0.3);
        }

        .log-container {
            max-height: 400px;
            overflow-y: auto;
            margin-bottom: 0px;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            background: #f8f9fa;
        }

        .log-search-input {
            height: 40px;
            padding: 8px 12px;
            border: 1px solid #ced4da;
            border-radius: 8px;
            min-width: 220px;
            font-size: 14px;
            outline: none;
            transition: box-shadow 0.2s ease, border-color 0.2s ease;
        }
        .log-search-input:focus {
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.15);
        }

        /* Duplicate warning styles */
        .search-with-warning {
            border-color: #dc3545 !important;
            box-shadow: 0 0 0 3px rgba(220, 53, 69, 0.15) !important;
        }

        /* Editing mode indicator */
        .editing-mode {
            background: linear-gradient(45deg, #fff3cd, #ffeaa7) !important;
            border: 2px solid #ffc107 !important;
            box-shadow: 0 0 0 3px rgba(255, 193, 7, 0.25) !important;
        }

        .editing-indicator {
            position: fixed;
            top: 3px;
            left: 10px;
            background: #ffc107;
            color: #000;
            padding: 8px 12px;
            border-radius: 6px;
            font-weight: bold;
            font-size: 12px;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .no-log-message {
            text-align: center;
            padding: 40px 20px;
            color: #666;
        }

        .no-log-message p {
            margin: 5px 0;
        }

        .log-hint {
            font-size: 12px;
            font-style: italic;
            color: #999;
        }

        /* FAB to toggle log action buttons */
        .right-section { position: relative; }
        .log-header-actions { gap: 10px; align-items: center; }
        .log-action-buttons { display: none; gap: 10px; align-items: center; }
        .right-section.log-fab-open .log-action-buttons { display: flex; }
        .log-fab,
        button.log-fab,
        button.log-fab[type="button"] {
            position: absolute !important;
            right: -16px !important;
            bottom: 326px !important;
            width: 35px !important;
            height: 35px !important;
            min-width: 35px !important;
            min-height: 35px !important;
            max-width: 35px !important;
            max-height: 35px !important;
            padding: 0 !important;
            border-radius: 50% !important;
            border: none !important;
            color: white !important;
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%) !important;
            box-shadow: 0 10px 20px rgba(0,0,0,0.15) !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            font-size: 22px !important;
            cursor: pointer !important;
            transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease !important;
            z-index: 10 !important;
            overflow: hidden !important;
            aspect-ratio: 1 / 1 !important;
            box-sizing: border-box !important;
            font-weight: normal !important;
        }
        .log-fab:hover { 
            transform: translateY(-2px);
            box-shadow: 0 14px 28px rgba(0,0,0,0.18);
        }
        .right-section.log-fab-open .log-fab,
        .right-section.log-fab-open button.log-fab,
        .right-section.log-fab-open button.log-fab[type="button"] { 
            background: linear-gradient(135deg, #17a2b8 0%, #0d6efd 100%) !important; 
        }
        .log-fab .icon-plus { transition: transform 0.2s ease; display: inline-block; }
        .right-section.log-fab-open .log-fab .icon-plus { transform: rotate(45deg); }

        .log-entry {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 3px;
            margin: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .log-entry:hover {
            border-color: #667eea;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.15);
            transform: translateY(-2px);
        }

        .log-entry:active {
            transform: translateY(0);
        }

        .log-entry-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .log-timestamp {
            font-size: 11px;
            color: #666;
            background: #f8f9fa;
            padding: 4px 8px;
            border-radius: 4px;
        }

        .log-toggle-icon {
            font-size: 16px;
            color: #667eea;
            transition: transform 0.3s ease;
            cursor: pointer;
        }

        .log-content-default {
            display: block;
        }

        .log-content-detailed {
            display: none;
        }

        /* Make detailed log items show as "Label : Value" on one line */
        .log-content-detailed .log-item {
            display: flex;
            flex-direction: row;
            align-items: baseline;
            gap: 6px;
        }
        .log-content-detailed .log-label {
            min-width: 130px; /* keep colon aligned vertically */
            font-size: 1em;
            font-weight: 600; /* bold label */
        }
        .log-content-detailed .log-sep {
            display: inline-block;
            width: 12px;
            text-align: center;
        }
        .log-content-detailed .log-value {
            font-size: 1em;
            font-weight: 400;
            white-space: pre-wrap;
        }

        .log-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            font-size: 13px;
        }

        .log-item {
            display: flex;
            flex-direction: column;
        }

        .log-label {
            font-weight: 600;
            color: #333;
            margin-bottom: 2px;
            font-size: 11px;
            text-transform: uppercase;
        }

        .log-value {
            color: #555;
            word-break: break-word;
        }

        .log-actions-detailed {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid #e9ecef;
        }

        .btn-load-data {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 120px;
            height: 38px;
            box-sizing: border-box;
        }

        .btn-load-data:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(40, 167, 69, 0.3);
        }

        /* removed .btn-save-log styles */

        .btn-export-log {
            background: linear-gradient(135deg, #17a2b8 0%, #138496 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            flex: 1;
            min-width: 120px;
            height: 38px;
            box-sizing: border-box;
        }

        .btn-export-log:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(23, 162, 184, 0.3);
        }

        .btn-import-log {
            background: linear-gradient(135deg, #0d6efd 0%, #0b5ed7 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            flex: 1;
            min-width: 120px;
            height: 38px;
            box-sizing: border-box;
        }

        .btn-import-log:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(13, 110, 253, 0.3);
        }

        .btn-restore-log {
            background: linear-gradient(135deg, #fd7e14 0%, #e8650e 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            flex: 1;
            margin: 0 4px;
            min-width: 120px;
            height: 38px;
            box-sizing: border-box;
        }

        .btn-restore-log:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(253, 126, 20, 0.3);
        }

        /* New buttons for log actions */
        .btn-edit-log {
            background: linear-gradient(135deg, #6f42c1 0%, #5a32a3 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 110px;
            height: 38px;
            box-sizing: border-box;
        }
        .btn-edit-log:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(111, 66, 193, 0.3);
        }
        .btn-delete-log {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 110px;
            height: 38px;
            box-sizing: border-box;
        }
        .btn-delete-log:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(220, 53, 69, 0.3);
        }

        /* Responsive design for log system */
        @media (max-width: 768px) {
            .log-content {
                grid-template-columns: 1fr;
                gap: 8px;
            }
            
            .log-actions {
                flex-direction: column;
            }
            
            .btn-export-log, .btn-edit-log, .btn-delete-log {
                min-width: 100%;
            }
        }

        .log-content-default {
            display: block;
        }

        .log-content-detailed {
            display: none;
        }

        /* Compact line styling */
        .log-compact-line {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            line-height: 1.4;
            padding: 8px 0;
        }

        .log-compact-item {
            display: flex;
            align-items: center;
            gap: 4px;
            flex: 1;
            min-width: 0;
        }

        .log-compact-label {
            font-size: 14px;
            color: #667eea;
            flex-shrink: 0;
        }

        .log-compact-value {
            color: #333;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 150px;
        }

        .log-compact-separator {
            color: #ccc;
            font-weight: bold;
            font-size: 12px;
            flex-shrink: 0;
            margin: 0 4px;
        }

        /* Responsive for compact view */
        @media (max-width: 768px) {
            .log-compact-line {
                flex-direction: column;
                align-items: flex-start;
                gap: 4px;
            }
            
            .log-compact-separator {
                display: none;
            }
            
            .log-compact-item {
                width: 100%;
            }
            
            .log-compact-value {
                max-width: none;
            }
        }
    </style>
<style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: 'Poppins', sans-serif;
    }

    body {
      background-color: #f5f7fa;
      color: #333;
      line-height: 1.6;
    }

    .container {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      padding: 20px;
      max-width: 1400px;
      margin: 0 auto;
    }

    .left-column, .right-column {
      flex: 0;
      min-width: 350px;
      background: white;
      border-radius: 10px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      padding: 10px;
    }

    .right-column {
      flex: 1;
      min-width: 300px;
      background: white;
      border-radius: 10px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      padding: 10px;
    }

    .toggle-section-btn {
      background-color: #4a6fa5;
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 5px;
      cursor: pointer;
      margin-bottom: 15px;
      font-weight: 600;
      width: 100%;
      text-align: left;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .toggle-section-btn:hover {
      background-color: #3a5a80;
    }

    .toggle-section-btn i {
      transition: transform 0.3s;
    }

    .toggle-section-btn.collapsed i {
      transform: rotate(-90deg);
    }

    form {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    input {
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 5px;
      font-size: 14px;
    }

    input:focus {
      outline: none;
      border-color: #4a6fa5;
    }

    button[type="button"]:not(.input-icon) {
      background-color: #4CAF50;
      color: white;
      border: none;
      padding: 12px;
      border-radius: 5px;
      cursor: pointer;
      font-weight: 600;
      transition: background-color 0.3s;
    }

    button[type="button"]:not(.input-icon):hover {
      background-color: #3e8e41;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 15px;
    }

    th, td {
      padding: 12px;
      text-align: left;
      border-bottom: 1px solid #ddd;
    }

    th {
      background-color: #4a6fa5;
      color: white;
      font-weight: 600;
      position: sticky;
      top: 0;
      z-index: 100;
    }

    tr:nth-child(even) {
      background-color: #f2f2f2;
    }

    tr:hover {
      background-color: #e9e9e9;
    }

    .sisa, .masuk {
      font-weight: 600;
      color: #4CAF50;
    }

    .keluar {
      font-weight: 600;
      color: #cc0000;
    }

    .footer {
      text-align: center;
      padding: 20px;
      background-color: #4a6fa5;
      color: white;
      margin-top: 20px;
    }

    .footer a {
      color: white;
      text-decoration: none;
    }

    .footer a:hover {
      text-decoration: underline;
    }

    /* Scrollable Tables */
    .total-sisa-container {
      overflow-x: auto;
      max-height: 400px;
      overflow-y: auto;
      display: block;
    }

    .riwayat-stok-container {
      overflow-x: auto;
      max-height: 600px;
      overflow-y: auto;
      display: block;
    }

    /* Input Tebal Kaca dengan Satuan */
    .input-with-unit {
      display: flex;
      align-items: center;
    }

    .input-with-unit input {
      flex: 1;
      border-top-right-radius: 0;
      border-bottom-right-radius: 0;
    }

    .unit-label {
      background-color: #e9ecef;
      padding: 10px 15px;
      border: 1px solid #ddd;
      border-left: none;
      border-top-right-radius: 5px;
      border-bottom-right-radius: 5px;
      font-size: 14px;
    }

    /* Action Menu Styles */
    .action-menu {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0;
      flex-wrap: wrap;
      gap: 10px;
      flex-direction: row-reverse;
    }

    .action-group {
      display: flex;
      gap: 10px;
    }

    .action-btn {
      padding: 8px 15px;
      border-radius: 5px;
      cursor: pointer;
      font-weight: 500;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 5px;
      transition: all 0.3s;
    }

    .export-btn {
      background-color: #28a745;
      color: white;
      border: none;
    }

    .export-btn:hover {
      background-color: #218838;
    }

    .import-btn {
      background-color: #17a2b8;
      color: white;
      border: none;
    }

    .import-btn:hover {
      background-color: #138496;
    }

    .clear-btn {
      background-color: #dc3545;
      color: white;
      border: none;
    }

    .clear-btn:hover {
      background-color: #c82333;
    }

    .filter-toggle-btn {
      background-color: #6f42c1;
      color: white;
      border: none;
    }

    .filter-toggle-btn:hover {
      background-color: #5a32a3;
    }

    .action-btn i {
      font-size: 14px;
    }

    /* Form Mode Toggle Styles */
    .form-mode-toggle {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
      border-radius: 8px;
      overflow: hidden;
      background: #f0f0f0;
      padding: 4px;
    }

    .mode-btn {
      flex: 1;
      padding: 10px 15px;
      border: none;
      border-radius: 6px;
      background: transparent;
      color: #666;
      font-weight: 600;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    .mode-btn:hover {
      background: rgba(74, 111, 165, 0.1);
      color: #4a6fa5;
    }

    .mode-btn.active {
      background: #4a6fa5;
      color: white;
      box-shadow: 0 2px 4px rgba(74, 111, 165, 0.3);
    }

    .mode-btn i {
      font-size: 16px;
    }

    /* Hide fields based on mode */
    .field-pembelian.hide,
    .field-penjualan.hide {
      display: none;
    }

    /* Search Styles */
    .search-container {
      flex: 1;
      min-width: 250px;
      margin-left: 10px;
    }

    .search-box {
      position: relative;
      display: flex;
      align-items: center;
      background: white;
      border: 2px solid #ddd;
      border-radius: 8px;
      padding: 0;
      transition: border-color 0.3s;
    }

    .search-box:focus-within {
      border-color: #4a6fa5;
    }

    .search-box i.fa-search {
      position: absolute;
      left: 12px;
      color: #6c757d;
      font-size: 14px;
    }

    .search-box input {
      flex: 1;
      padding: 8px 40px 8px 35px;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      outline: none;
    }

    .search-clear-btn {
      position: absolute;
      right: 10px;
      background: transparent;
      border: none;
      color: #6c757d;
      cursor: pointer;
      padding: 5px 8px;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background-color 0.3s;
    }

    .search-clear-btn:hover {
      background-color: #e9ecef;
      color: #dc3545;
    }

    /* Table Action Buttons */
    .row-action-btn {
      padding: 5px 0px;
      color: white;
      border: none;
      border-radius: 0px;
      cursor: pointer;
      margin: 1px;
      box-shadow: none;
    }

    .row-action-btn[disabled],
    .row-action-btn:disabled,
    .row-action-btn[style*="opacity: 0.3"],
    .row-action-btn[style*="opacity:0.3"] {
      box-shadow: none !important;
      pointer-events: none;
    }

    .edit-btn {
      background-color: #007bff;
    }

    .edit-btn:hover {
      background-color: #0069d9;
    }

    .delete-btn {
      background-color: #dc3545;
    }

    .delete-btn:hover {
      background-color: #c82333;
    }

    .action-buttons-container {
      display: flex;
      gap: 0px;
      flex-direction: column-reverse;
    }

    /* Edit Form Styles */
    .edit-form {
      background-color: #e3f2fd;
      padding: 15px;
      border-radius: 5px;
      margin-top: 10px;
      border-left: 4px solid #2196F3;
    }

    .edit-mode {
      background-color: #fffde7;
    }

    .cancel-edit-btn {
      background-color: #dc3545;
      margin-top: 0;
    }

    /* Status Bar */
    .status-bar {
      padding: 8px;
      margin: 10px 0;
      border-radius: 4px;
      text-align: center;
      font-size: 14px;
    }

    .status-saving {
      background-color: #d4edda;
      color: #155724;
    }

    .status-error {
      background-color: #f8d7da;
      color: #721c24;
    }

    .status-loading {
      background-color: #cce5ff;
      color: #004085;
    }

    /* Hidden file input */
    .hidden-file-input {
      display: none;
    }

    @media (max-width: 768px) {
      .container {
        flex-direction: column;
      }
      
      .left-column, .right-column {
        width: 100%;
      }
      
      .action-menu {
        flex-direction: column;
        align-items: flex-start;
      }
      
      .action-group {
        width: 100%;
        flex-wrap: wrap;
      }
      
      .action-btn {
        flex: 1;
        min-width: 120px;
      }

      .search-container {
        width: 100%;
        margin-left: 0;
        margin-top: 10px;
      }

      .total-sisa-container,
      .riwayat-stok-container {
        max-height: 300px;
      }
    }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: 'Poppins', sans-serif;
    }

    body {
      background-color: #f5f7fa;
      color: #333;
      line-height: 1.6;
    }

    .container {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      padding: 20px;
      max-width: 1400px;
      margin: 0 auto;
    }

    .left-column, .right-column {
      flex: 0;
      min-width: 350px;
      background: white;
      border-radius: 10px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      padding: 10px;
    }

    .right-column {
      flex: 1;
      min-width: 300px;
      background: white;
      border-radius: 10px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      padding: 10px;
    }

    .toggle-section-btn {
      background-color: #4a6fa5;
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 5px;
      cursor: pointer;
      margin-bottom: 15px;
      font-weight: 600;
      width: 100%;
      text-align: left;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .toggle-section-btn:hover {
      background-color: #3a5a80;
    }

    .toggle-section-btn i {
      transition: transform 0.3s;
    }

    .toggle-section-btn.collapsed i {
      transform: rotate(-90deg);
    }

    form {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    input {
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 5px;
      font-size: 14px;
    }

    input:focus {
      outline: none;
      border-color: #4a6fa5;
    }

    button[type="button"]:not(.input-icon) {
      background-color: #4CAF50;
      color: white;
      border: none;
      padding: 12px;
      border-radius: 5px;
      cursor: pointer;
      font-weight: 600;
      transition: background-color 0.3s;
    }

    button[type="button"]:not(.input-icon):hover {
      background-color: #3e8e41;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 0px;
    }

    th, td {
      padding: 12px;
      text-align: left;
      border-bottom: 1px solid #ddd;
    }

    th {
      background-color: #4a6fa5;
      color: white;
      font-weight: 600;
      position: sticky;
      top: 0;
      z-index: 100;
    }

    tr:nth-child(even) {
      background-color: #f2f2f2;
    }

    tr:hover {
      background-color: #e9e9e9;
    }

    .sisa, .masuk {
      font-weight: 600;
      color: #4CAF50;
    }

    .keluar {
      font-weight: 600;
      color: #cc0000;
    }

    .footer {
      text-align: center;
      padding: 20px;
      background-color: #4a6fa5;
      color: white;
      margin-top: 20px;
    }

    .footer a {
      color: white;
      text-decoration: none;
    }

    .footer a:hover {
      text-decoration: underline;
    }

    /* Scrollable Tables */
    .total-sisa-container {
      overflow-x: auto;
      max-height: 400px;
      overflow-y: auto;
      display: block;
    }

    .riwayat-stok-container {
      overflow-x: auto;
      max-height: 600px;
      overflow-y: auto;
      display: block;
    }

    /* Input Tebal Kaca dengan Satuan */
    .input-with-unit {
      display: flex;
      align-items: center;
    }

    .input-with-unit input {
      flex: 1;
      border-top-right-radius: 0;
      border-bottom-right-radius: 0;
    }

    .unit-label {
      background-color: #e9ecef;
      padding: 10px 15px;
      border: 1px solid #ddd;
      border-left: none;
      border-top-right-radius: 5px;
      border-bottom-right-radius: 5px;
      font-size: 14px;
    }

    /* Action Menu Styles */
    .action-menu {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0;
      flex-wrap: wrap;
      gap: 10px;
    }

    .action-group {
      display: flex;
      gap: 10px;
    }

    .action-btn {
      padding: 8px 15px;
      border-radius: 5px;
      cursor: pointer;
      font-weight: 500;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 5px;
      transition: all 0.3s;
    }

    .export-btn {
      background-color: #28a745;
      color: white;
      border: none;
    }

    .export-btn:hover {
      background-color: #218838;
    }

    .import-btn {
      background-color: #17a2b8;
      color: white;
      border: none;
    }

    .import-btn:hover {
      background-color: #138496;
    }

    .clear-btn {
      background-color: #dc3545;
      color: white;
      border: none;
    }

    .clear-btn:hover {
      background-color: #c82333;
    }

    .filter-toggle-btn {
      background-color: #6f42c1;
      color: white;
      border: none;
    }

    .filter-toggle-btn:hover {
      background-color: #5a32a3;
    }

    .action-btn i {
      font-size: 14px;
    }

    /* Form Mode Toggle Styles */
    .form-mode-toggle {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
      border-radius: 8px;
      overflow: hidden;
      background: #f0f0f0;
      padding: 4px;
    }

    .mode-btn {
      flex: 1;
      padding: 10px 15px;
      border: none;
      border-radius: 6px;
      background: transparent;
      color: #666;
      font-weight: 600;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    .mode-btn:hover {
      background: rgba(74, 111, 165, 0.1);
      color: #4a6fa5;
    }

    .mode-btn.active {
      background: #4a6fa5;
      color: white;
      box-shadow: 0 2px 4px rgba(74, 111, 165, 0.3);
    }

    .mode-btn i {
      font-size: 16px;
    }

    /* Hide fields based on mode */
    .field-pembelian.hide,
    .field-penjualan.hide {
      display: none;
    }

    /* Search Styles */
    .search-container {
      flex: 1;
      min-width: 250px;
      margin-left: 10px;
    }

    .search-box {
      position: relative;
      display: flex;
      align-items: center;
      background: white;
      border: 2px solid #ddd;
      border-radius: 8px;
      padding: 0;
      transition: border-color 0.3s;
    }

    .search-box:focus-within {
      border-color: #4a6fa5;
    }

    .search-box i.fa-search {
      position: absolute;
      left: 12px;
      color: #6c757d;
      font-size: 14px;
    }

    .search-box input {
      flex: 1;
      padding: 8px 40px 8px 35px;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      outline: none;
    }

    .search-clear-btn {
      position: absolute;
      right: 10px;
      background: transparent;
      border: none;
      color: #6c757d;
      cursor: pointer;
      padding: 5px 8px;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background-color 0.3s;
    }

    .search-clear-btn:hover {
      background-color: #e9ecef;
      color: #dc3545;
    }

    /* Table Action Buttons */
    .row-action-btn {
      padding: 5px 0px;
      color: white;
      border: none;
      border-radius: 0px;
      cursor: pointer;
      margin: 1px;
      box-shadow: none;
    }

    .row-action-btn[disabled],
    .row-action-btn:disabled,
    .row-action-btn[style*="opacity: 0.3"],
    .row-action-btn[style*="opacity:0.3"] {
      box-shadow: none !important;
      pointer-events: none;
    }

    .edit-btn {
      background-color: #007bff;
    }

    .edit-btn:hover {
      background-color: #0069d9;
    }

    .delete-btn {
      background-color: #dc3545;
    }

    .delete-btn:hover {
      background-color: #c82333;
    }

    .action-buttons-container {
      display: flex;
      gap: 0px;
      flex-direction: column-reverse;
    }

    /* Edit Form Styles */
    .edit-form {
      background-color: #e3f2fd;
      padding: 15px;
      border-radius: 5px;
      margin-top: 10px;
      border-left: 4px solid #2196F3;
    }

    .edit-mode {
      background-color: #fffde7;
    }

    .cancel-edit-btn {
      background-color: #dc3545;
      margin-top: 0;
    }

    /* Status Bar */
    .status-bar {
      padding: 8px;
      margin: 10px 0;
      border-radius: 4px;
      text-align: center;
      font-size: 14px;
    }

    .status-saving {
      background-color: #d4edda;
      color: #155724;
    }

    .status-error {
      background-color: #f8d7da;
      color: #721c24;
    }

    .status-loading {
      background-color: #cce5ff;
      color: #004085;
    }

    /* Hidden file input */
    .hidden-file-input {
      display: none;
    }

    @media (max-width: 768px) {
      .container {
        flex-direction: column;
      }
      
      .left-column, .right-column {
        width: 100%;
      }
      
      .action-menu {
        flex-direction: column;
        align-items: flex-start;
      }
      
      .action-group {
        width: 100%;
        flex-wrap: wrap;
      }
      
      .action-btn {
        flex: 1;
        min-width: 120px;
      }

      .search-container {
        width: 100%;
        margin-left: 0;
        margin-top: 10px;
      }

      .total-sisa-container,
      .riwayat-stok-container {
        max-height: 300px;
      }
    }
  </style>
</head><body>
    <div class="container">
        <div class="header">
            <h1>SURAT JALAN</h1>
            <div class="header-controls">
                <button id="backupBtn" class="header-btn" title="Backup Data">💾 Backup</button>
                <button id="restoreBtn" class="header-btn" title="Restore Data">📁 Restore</button>
                <input type="file" id="restoreFile" accept=".json" style="display: none;">
            </div>
        </div>
        
        <div class="form-container"style="padding-top: 0px;">
            <div class="main-layout">
                <!-- Sebelah Kiri - Form Input Data Toko -->
                <div class="left-section" style="
						   height: 352px;
   						   margin-bottom: 5px;">
                    
                    <form id="tokoForm">
                        <div class="form-row">
                            <!-- Kolom Kiri -->
                            <div class="form-column">
                                <div class="form-group">
                                    <div class="autocomplete-container">
                                        <div class="input-with-icon">
                                            <input 
                                                type="text" 
                                                id="namaToko" 
                                                name="namaToko" 
                                                placeholder="Nama Toko"
                                                required
                                                autocomplete="off"
                                            >
                                            <button type="button" class="input-icon" onclick="showQuickAddModal()" title="Tambah Toko Baru">
                                                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                                                    <line x1="12" y1="5" x2="12" y2="19"></line>
                                                    <line x1="5" y1="12" x2="19" y2="12"></line>
                                                </svg>
                                            </button>
                                        </div>
                                        <div class="autocomplete-dropdown" id="autocompleteDropdown">
                                            <!-- Autocomplete items will be generated here -->
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="form-group">
                                    <textarea 
                                        id="alamat" 
                                        name="alamat" 
                                        placeholder="Alamat"
                                        readonly
                                        class="auto-resize"
                                    ></textarea>
                                </div>

                                <div class="form-group">
                                    <input 
                                        type="text" 
                                        id="alias" 
                                        name="alias" 
                                        placeholder="Alias"
                                        autocomplete="off"
                                    >
                                </div>
                            </div>
                            
                            <!-- Kolom Kanan -->
                            <div class="form-column">
                                <div class="form-group">
                                    <input 
                                        type="date" 
                                        id="tanggal" 
                                        name="tanggal" 
                                        placeholder="Tanggal"
                                        required
                                    >
                                </div>
                                
                                <div class="form-group" id="nomorSJGroup">
                                    <input 
                                        type="text" 
                                        id="nomorSJ" 
                                        name="nomorSJ" 
                                        placeholder="No. SJ"
                                        inputmode="numeric"
                                        pattern="\\d{7}"
                                        minlength="7"
                                        maxlength="7"
                                        required
                                        aria-describedby="nomorSJWarning"
                                    >
                                    <div id="nomorSJWarning" class="field-warning" style="display:none;" role="alert" aria-live="polite">
                                        ⚠️ No. SJ sama dengan input sebelumnya
                                    </div>
                                </div>
                                
                                <div class="form-group">
                                    <input 
                                        type="text" 
                                        id="supir" 
                                        name="supir" 
                                        placeholder="Nama Supir"
                                        list="datalistSupir"
                                        autocomplete="off"
                                        required
                                    >
                                    <datalist id="datalistSupir"></datalist>
                                </div>
                                
                                <div class="form-group">
                                    <input 
                                        type="text" 
                                        id="noKendaraan" 
                                        name="noKendaraan" 
                                        placeholder="No. Kendaraan"
                                        list="datalistNoKendaraan"
                                        autocomplete="off"
                                        required
                                    >
                                    <datalist id="datalistNoKendaraan"></datalist>
                                </div>
                            </div>
                        </div>
                    </form>
                </div>
                
                <!-- Sebelah Kanan - Log Input History -->
                <div class="right-section" style="
								height: 352px;
								margin-bottom: 5px;
								padding-top: 5px;
								padding-left: 20px;
								padding-bottom: 20px;">
                    <div class="log-header" aria-expanded="true" aria-controls="inputLogContainer" style="padding-bottom: 5px;">
                        <h3>📝 LOG SJ</h3>
                        <div class="log-header-actions" role="group" aria-label="Log actions" style="display: flex; gap: 10px; align-items: stretch; opacity: 1; flex-flow: column wrap-reverse; place-content: flex-end center;">
                            <input type="text" id="logSearchInput" class="log-search-input" placeholder="Search" oninput="applyLogSearch()" title="Ketik untuk mencari di log">
                            <div class="log-action-buttons">
                                <button type="button" class="btn-export-log" onclick="exportInputLogToCSV()" title="Export ke CSV (Excel)">⬇️ Export Log</button>
                                <button type="button" class="btn-import-log" onclick="document.getElementById('importLogFileInput').click()" title="Import dari CSV (Excel)">⬆️ Import Log</button>
                                <input type="file" id="importLogFileInput" accept=".csv" style="display:none" onchange="handleImportLogFile(event)">
                                <button type="button" class="btn-restore-log" onclick="triggerRestoreFileSelection()" title="Restore dari beberapa file backup (CSV/JSON)">🔄Restore Log</button>
                                <input type="file" id="restoreLogFileInput" accept=".csv,.json" multiple="multiple" style="display:none" onchange="handleRestoreLogFiles(event)">
                                <button type="button" class="btn-clear-log" onclick="clearInputLog()" title="Hapus semua log">🗑️ Clear Log</button>
                            </div>
                        </div>
                    </div>
                    
                    <div class="log-container" id="inputLogContainer" style="display:block;">
                        <!-- Log entries will be generated here -->
                        <div class="no-log-message">
                            <p>Belum ada log input</p>
                            <p class="log-hint">Log akan tersimpan otomatis saat Anda menekan Print Sekarang</p>
                        </div>
                    </div>
                    <div class="log-actions" style="display:none; gap:0px; margin-top:0px;"></div>
                    <button type="button" class="log-fab" onclick="event.stopPropagation(); toggleLogFab(this)" title="Tampilkan/sembunyikan tombol log"><span class="icon-plus">＋</span></button>
                    
                    
                </div>
            </div>
            

            
            <!-- Container Data Kaca -->
            <div class="kaca-data-container">
                <div class="kaca-header" style="margin-bottom: 6px;">
                    <button type="button" class="btn-refresh-page" onclick="refreshPage()">🔄 Refresh Halaman</button>
                    <div class="kaca-controls">
                            <button type="button" class="btn-print-now" onclick="handleQuickPrint()">🖨️ Print Sekarang</button>
                            <button type="button" class="btn-print" onclick="showPrintModal()">🖨️ Print Setting</button>
                        <button type="button" class="btn-add-row" onclick="addKacaRow()">➕ Tambah Baris</button>
                        <button type="button" class="btn-remove-row" onclick="removeKacaRow()">➖ Hapus Baris</button>
                    </div>
                </div>
                
                <div class="kaca-table-container">
                    <table class="kaca-table" id="kacaTable">
                        <thead>
                            <tr>
                                <th>JENIS KACA</th>
                                <th>PWD</th>
                                <th>NO DO</th>
                                <th>UKURAN</th>
                                <th>HARGA</th>
                                <th>BOX</th>
                                <th>LBR</th>
                                <th>TOTAL LBR</th>
                            </tr>
                        </thead>
                        <tbody id="kacaTableBody">
                            <!-- Baris default akan di-generate oleh JavaScript -->
                        </tbody>
                        <tfoot>
                            <tr class="total-row">
                                <td class="total-inputs">
                                    <div class="total-input-group">
                                        <input type="text" placeholder="CONT" class="cont-input">
                                        <input type="text" placeholder="SEAL" class="seal-input">
                                    </div>
                                </td>
                                <td></td>
                                <td></td>
                                <td></td>
                                <td></td>
                                <td></td>
                                <td></td>
                                <td class="total-lbr grand-total">
                                    <input type="text" placeholder="0 LBR" class="grand-total-input" readonly>
                                </td>
                            </tr>
                        </tfoot>
                    </table>
                    <!-- Datalists for auto-fill suggestions -->
                    <datalist id="datalistJenisKaca"></datalist>
                    <datalist id="datalistUkuran"></datalist>
                </div>
            </div>
        </div>
    </div>

    <!-- Popup Daftar Toko -->
    <div class="popup-overlay" id="popupOverlay">
        <div class="popup">
            <div class="popup-header">
                <h3 class="popup-title">📋 Daftar Toko dan Alamat</h3>
                <button class="close-btn" onclick="hideTokoList()">&times;</button>
            </div>
            <div class="toko-list" id="tokoList">
                <!-- Daftar toko akan di-generate oleh JavaScript -->
            </div>
        </div>
    </div>

    <!-- Modal Tambah/Edit Toko -->
    <div class="modal-overlay" id="modalOverlay">
        <div class="modal" id="mainModal">
            <div class="modal-header">
                <h3 class="modal-title" id="modalTitle">➕ Tambah Toko Baru</h3>
                <button class="modal-close" onclick="hideModal()">&times;</button>
            </div>
            <form class="modal-form" id="modalForm">
                <input type="hidden" id="editIndex" value="">
                <div>
                    <input 
                        type="text" 
                        id="modalNamaToko" 
                        placeholder="Nama Toko"
                        required style="border-right-width: 2px;height: 47px;width: 450px;"
                    >
                </div>
                <div>
                    <textarea 
                        id="modalAlamat" 
                        placeholder="Alamat Toko (gunakan Enter untuk baris baru)"
                        required style="width: 453px;"
                    ></textarea>
                </div>
                <div class="modal-actions">
                    <button type="button" class="btn-cancel" onclick="hideModal()">Batal</button>
                    <button type="submit" class="btn-save" id="saveBtn">Simpan</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Quick Add Modal -->
    <div class="modal-overlay" id="quickAddModalOverlay">
        <div class="modal quick-add">
            <div class="modal-header">
                <h3 class="modal-title">➕ Tambah Toko Cepat</h3>
                <button class="modal-close" onclick="hideQuickAddModal()">&times;</button>
            </div>
            
            <!-- Quick Actions Tabs -->
            <div class="quick-tabs">
                <button type="button" class="tab-btn active" onclick="showQuickAddTab()">➕ Tambah Baru</button>
                <button type="button" class="tab-btn" onclick="showQuickListTab()">📋 Lihat Daftar</button>
            </div>
            
            <!-- Tab Content -->
            <div class="tab-content">
                <!-- Tab 1: Form Tambah Toko -->
                <div class="tab-pane active" id="quickAddTab">
                    <form class="modal-form" id="quickAddForm">
                        <div>
                            <input 
                                type="text" 
                                id="quickAddNamaToko" 
                                placeholder="Nama Toko"
                                required
                            >
                        </div>
                        <div>
                            <textarea 
                                id="quickAddAlamat" 
                                placeholder="Alamat Toko (gunakan Enter untuk baris baru)"
                                required
                            ></textarea>
                        </div>
                        <div class="modal-actions">
                            <button type="button" class="btn-cancel" onclick="hideQuickAddModal()">Batal</button>
                            <button type="submit" class="btn-save">Simpan</button>
                        </div>
                    </form>
                </div>
                
                <!-- Tab 2: Daftar Toko -->
                <div class="tab-pane" id="quickListTab">
                    <div class="quick-list-container">
                        <div class="quick-list-header">
                            <div class="quick-list-actions">
                                <button type="button" class="btn-export-toko" onclick="exportTokoListToJSON()" title="Export daftar toko ke file JSON">⬇️ Export Toko</button>
                                <button type="button" class="btn-import-toko" onclick="document.getElementById('importTokoFileInput').click()" title="Import daftar toko dari file JSON">⬆️ Import Toko</button>
                                <input type="file" id="importTokoFileInput" accept=".json" style="display:none" onchange="handleImportTokoListFile(event)">
                            </div>
                        </div>
                        <div class="quick-toko-list" id="quickTokoList">
                            <!-- Daftar toko akan di-generate di sini -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Print Modal -->
    <div class="modal-overlay" id="printModalOverlay">
        <div class="modal print-modal" style="padding-top: 10px;">
            <div class="modal-header">
                <h3 class="modal-title">🖨️ Print Data</h3>
                <button class="modal-close" onclick="hidePrintModal()">&times;</button>
            </div>
            
            <div class="print-content">
                <div class="print-textarea-container">
                    <!-- Draggable text elements will be generated here -->
                </div>
                
                <div class="print-actions">
                    <!-- Font Controls Section -->
                    <div class="print-controls-section">
                        <h4 class="controls-section-title">📝 Pengaturan Font</h4>
                        <div class="font-controls">
                            <label for="fontSizeControl">Ukuran Font:</label>
                            <select id="fontSizeControl" onchange="changeFontSize()">
                                <option value="8">8px - Sangat Kecil</option>
                                <option value="10" selected>10px - Kecil</option>
                                <option value="12">12px - Sedang</option>
                                <option value="14">14px - Besar</option>
                                <option value="16">16px - Sangat Besar</option>
                                <option value="18">18px - Ekstra Besar</option>
                            </select>
                             <label for="fontWeightControl" style="margin-left: 10px;">Ketebalan Teks:</label>
                             <select id="fontWeightControl" onchange="changeFontWeight()">
                                 <option value="300">Light</option>
                                 <option value="400" selected>Normal</option>
                                 <option value="500">Medium</option>
                                 <option value="600">Semi Bold</option>
                                 <option value="700">Bold</option>
                             </select>
                             <label for="fontFamilyControl" style="margin-left: 10px;">Gaya Font:</label>
                             <select id="fontFamilyControl" onchange="changeFontFamily()">
                                 <option value="'Roboto Mono', 'Courier New', monospace" selected>Roboto Mono (Monospace)</option>
                                 <option value="Arial, Helvetica, sans-serif">Arial (Sans)</option>
                                 <option value="'Segoe UI', Tahoma, Geneva, Verdana, sans-serif">Segoe UI (Sans)</option>
                                 <option value="'Times New Roman', Times, serif">Times New Roman (Serif)</option>
                                 <option value="'Courier New', Courier, monospace">Courier New (Monospace)</option>
                             </select>
                        </div>
                    </div>
                    
                    <!-- Column Spacing Section -->
                    <div class="print-controls-section">
                        <div class="controls-section-header">
                            <h4 class="controls-section-title">📊 Pengaturan Kolom</h4>
                            <button type="button" class="btn-print-now" onclick="printNow()">🖨️ Print Sekarang</button>
                            <button type="button" class="btn-save-positions" onclick="saveCurrentPositions()" title="Simpan posisi teks">💾 Simpan Posisi</button>
                            <button type="button" class="btn-export-positions" onclick="exportPositionsToJSON()" title="Export posisi ke file JSON">⬇️ Export Posisi</button>
                            <button type="button" class="btn-import-positions" onclick="document.getElementById('importPositionsFileInput').click()" title="Import posisi dari file JSON">⬆️ Import Posisi</button>
                            <input type="file" id="importPositionsFileInput" accept=".json" style="display:none" onchange="handleImportPositionsFile(event)">
                        </div>
                        <div class="individual-column-controls">
                            <div class="column-controls-grid">
                                <div class="column-control-item">
                                    <label>Jenis Kaca:</label>
                                    <input type="number" id="colJenisKaca" value="15" min="8" max="30">
                                </div>
                                <div class="column-control-item">
                                    <label>PWD:</label>
                                    <input type="number" id="colPwd" value="8" min="5" max="15">
                                </div>
                                <div class="column-control-item">
                                    <label>NO DO:</label>
                                    <input type="number" id="colNoDo" value="12" min="8" max="20">
                                </div>
                                <div class="column-control-item">
                                    <label>Ukuran:</label>
                                    <input type="number" id="colUkuran" value="12" min="8" max="20">
                                </div>
                                <div class="column-control-item">
                                    <label>BOX:</label>
                                    <input type="number" id="colBox" value="10" min="6" max="15">
                                </div>
                                <div class="column-control-item">
                                    <label>LBR:</label>
                                    <input type="number" id="colLbr" value="10" min="6" max="15">
                                </div>
                                <div class="column-control-item">
                                    <label>Total LBR:</label>
                                    <input type="number" id="colTotalLbr" value="12" min="8" max="20">
                                </div>
                            </div>
                            
                            <div class="spacing-presets">
                                <span class="preset-label">Preset Cepat:</span>
                                <button type="button" class="preset-btn" onclick="applyPreset('compact')">Compact</button>
                                <button type="button" class="preset-btn active" onclick="applyPreset('normal')">Normal</button>
                                <button type="button" class="preset-btn" onclick="applyPreset('wide')">Wide</button>
                                <button type="button" class="preset-btn" onclick="applyPreset('custom')">Custom</button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Position Controls Section removed per request -->
                    
                    
                </div>
            </div>
        </div>
    </div>
        </div>
    </div>

    <script>
        // Function to record stok transactions from surat jalan
        // Helper function to force update harga for a ukuran input
        function forceUpdateHargaForUkuran(ukuranInput) {
            if (!ukuranInput || !ukuranInput.value.trim()) return;
            
            // Respect lock mechanism
            if (ukuranInput.getAttribute('data-price-locked') === 'true') {
                console.log('[Force Update] Skipped due to price lock');
                return;
            }
            
            const ukuranValue = ukuranInput.value.trim();
            console.log(`[Force Update] Processing for value: "${ukuranValue}"`);
            
            const ukuranList = document.getElementById('datalistUkuran');
            if (!ukuranList) return;
            
            // Find all matching options
            const matchingOptions = Array.from(ukuranList.options).filter(opt => {
                const optValue = opt.value.trim();
                return optValue === ukuranValue;
            });
            
            if (matchingOptions.length > 0) {
                // FIRST: Check if current data-selected-harga is still valid
                // This preserves user's selection if it's still available
                const currentHarga = ukuranInput.getAttribute('data-selected-harga') || '';
                if (currentHarga) {
                    const matchingByDataHarga = matchingOptions.find(opt => {
                        const optHarga = opt.getAttribute('data-harga');
                        return optHarga === currentHarga;
                    });
                    if (matchingByDataHarga) {
                        // Current selection is still valid, keep it and return
                        console.log('[Force Update] Current selection still valid, skipping update');
                        return;
                    }
                }
                
                // If current selection is not valid or not set, find the best match
                let selectedOption = null;
                
                // If multiple options, try to match by harga-jual
                if (matchingOptions.length > 1) {
                    const row = ukuranInput.closest('tr');
                    const hargaJualInput = row ? row.querySelector('.harga-jual') : null;
                    const currentHargaJual = hargaJualInput ? hargaJualInput.value.trim().replace(/[^\d]/g, '') : '';
                    
                    if (currentHargaJual) {
                        const matchingByHarga = matchingOptions.find(opt => {
                            const optHarga = opt.getAttribute('data-harga');
                            if (!optHarga) return false;
                            const hargaValues = optHarga.split(',').map(h => h.trim().replace(/[^\d]/g, ''));
                            return hargaValues.includes(currentHargaJual);
                        });
                        if (matchingByHarga) {
                            selectedOption = matchingByHarga;
                            console.log('[Force Update] Matched by existing price value');
                        }
                    }
                    
                    // If still no match, try current data-selected-harga (even if not exact match)
                    if (!selectedOption && currentHarga) {
                        const matchingByDataHarga = matchingOptions.find(opt => {
                            const optHarga = opt.getAttribute('data-harga');
                            return optHarga === currentHarga;
                        });
                        if (matchingByDataHarga) {
                            selectedOption = matchingByDataHarga;
                             console.log('[Force Update] Matched by previous selected price');
                        }
                    }
                }
                
                // If still no match, use first option
                if (!selectedOption) {
                    selectedOption = matchingOptions[0];
                    console.log('[Force Update] Fallback to first match');
                }
                
                // Update data-selected-harga only if we found a different option
                const hargaAttr = selectedOption.getAttribute('data-harga');
                if (hargaAttr) {
                    console.log(`[Force Update] Selected price: ${hargaAttr}`);
                    // Always update attributes
                    ukuranInput.setAttribute('data-selected-harga', hargaAttr);
                    const row = ukuranInput.closest('tr');
                    let hargaJualInput = null;
                    if (row) {
                        row.setAttribute('data-selected-harga', hargaAttr);
                        hargaJualInput = row.querySelector('.harga-jual');
                    }
                    
                    // Also update harga-jual placeholder if it exists
                    if (hargaJualInput) {
                        const hargaValues = hargaAttr.split(',').map(h => h.trim()).filter(h => h);
                        if (hargaValues.length > 0) {
                            const firstHarga = parseFloat(hargaValues[0]);
                            if (!isNaN(firstHarga) && firstHarga > 0) {
                                // Only update placeholder if field is empty
                                if (!hargaJualInput.value.trim()) {
                                    const newPlaceholder = `Rp ${firstHarga.toLocaleString('id-ID')}`;
                                    if (hargaJualInput.placeholder !== newPlaceholder) {
                                        hargaJualInput.placeholder = newPlaceholder;
                                        console.log(`[Force Update] Updated placeholder to: ${newPlaceholder}`);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        async function recordStokTransactionsFromSuratJalan() {
            try {
                // Force update all harga before processing
                const allUkuranInputs = document.querySelectorAll('#kacaTableBody tr .ukuran');
                allUkuranInputs.forEach(ukuranInput => {
                    forceUpdateHargaForUkuran(ukuranInput);
                });
                
                // Get nama toko from input field
                const namaTokoInput = document.getElementById('namaToko');
                const namaToko = namaTokoInput ? namaTokoInput.value.trim() : '';
                
                if (!namaToko) {
                    console.warn('Nama toko tidak diisi, transaksi stok tidak dicatat');
                    return;
                }

                // Get nomor SJ from input field
                const nomorSJInput = document.getElementById('nomorSJ');
                const nomorSJ = nomorSJInput ? nomorSJInput.value.trim() : '';
                
                // Get current date - use formatDate from stok section if available
                const today = new Date();
                let formattedDate;
                if (typeof formatDate === 'function') {
                    formattedDate = formatDate(today.toISOString().split('T')[0]);
                } else {
                    const day = String(today.getDate()).padStart(2, '0');
                    const month = String(today.getMonth() + 1).padStart(2, '0');
                    const year = today.getFullYear();
                    formattedDate = `${day}/${month}/${year}`;
                }
                
                // Ensure stokData is loaded FIRST before checking for old transactions
                if (typeof window.stokData === 'undefined' || !Array.isArray(window.stokData)) {
                    // Try to load data if loadData function exists
                    if (typeof loadData === 'function') {
                        await loadData();
                    } else {
                        window.stokData = [];
                    }
                }
                
                // If editing, delete old transactions with the same logEntryId (more precise than nota)
                // IMPORTANT: Do this AFTER loading stokData to ensure we have the latest data
                // Use lastLogEntryId which is set when log entry is created/edited
                const currentLogEntryId = lastLogEntryId;
                const originalNomorSJ = originalNomorSJForDeletion || (editingLogEntry && editingLogEntry.entry ? editingLogEntry.entry.data?.nomorSJ || '' : '');
                const newNomorSJ = nomorSJ || '';
                
                if (currentLogEntryId) {
                    // Find and delete all transactions with this logEntryId (most precise method)
                    // Make sure we're working with the actual stokData array
                    const currentStokData = window.stokData || [];
                    
                    // Debug: Log all transactions to see what we're working with
                    console.log(`🔍 Searching for transactions with logEntryId: "${currentLogEntryId}"`);
                    console.log(`📊 Total stokData entries: ${currentStokData.length}`);
                    
                    const transactionsToDelete = currentStokData.filter(entry => {
                        const matches = entry.logEntryId === currentLogEntryId;
                        
                        if (matches) {
                            console.log(`  ✓ Found matching transaction: ID=${entry.id}, logEntryId="${entry.logEntryId}", nota="${entry.nota}", tebal="${entry.tebal}", ukuran="${entry.ukuran}", keluar=${entry.keluar}`);
                        }
                        
                        return matches;
                    });
                    
                    if (transactionsToDelete.length > 0) {
                        console.log(`🗑️ Deleting ${transactionsToDelete.length} old transactions for logEntryId: ${currentLogEntryId}`);
                        
                        // Delete from IndexedDB first, then remove from array
                        for (const transaction of transactionsToDelete) {
                            // Delete from IndexedDB if deleteEntryFromDB function is available
                            // Try multiple ways to access the function
                            let deleteFunc = null;
                            if (typeof window.deleteEntryFromDB === 'function') {
                                deleteFunc = window.deleteEntryFromDB;
                            } else if (typeof deleteEntryFromDB === 'function') {
                                deleteFunc = deleteEntryFromDB;
                            }
                            
                            if (deleteFunc) {
                                try {
                                    await deleteFunc(transaction.id);
                                    console.log(`  ✓ Deleted transaction ID ${transaction.id} from IndexedDB`);
                                } catch (error) {
                                    console.error(`  ✗ Error deleting transaction ID ${transaction.id} from DB:`, error);
                                }
                            } else {
                                console.warn('deleteEntryFromDB function not available, only removing from array');
                            }
                            
                            // Remove from stokData array
                            const index = window.stokData.findIndex(e => e.id === transaction.id);
                            if (index !== -1) {
                                window.stokData.splice(index, 1);
                                console.log(`  ✓ Removed transaction ID ${transaction.id} from array`);
                            } else {
                                console.warn(`  ⚠️ Transaction ID ${transaction.id} not found in array`);
                            }
                        }
                        
                        // Update UI immediately after deletion
                        if (typeof updateStokTable === 'function') {
                            updateStokTable();
                        }
                        if (typeof updateTotalSisa === 'function') {
                            updateTotalSisa();
                        }
                        if (typeof updateJenisKacaList === 'function') {
                            updateJenisKacaList();
                        }
                        if (typeof updateUkuranKacaList === 'function') {
                            updateUkuranKacaList();
                        }
                        
                        console.log('✅ Old transactions deleted and UI updated');
                    } else {
                        console.log(`ℹ️ No old transactions found for logEntryId: ${currentLogEntryId}`);
                    }
                } else if (originalNomorSJ) {
                    // Fallback: if logEntryId not available, use nota (for backward compatibility with old data)
                    const currentStokData = window.stokData || [];
                    const transactionsToDelete = currentStokData.filter(entry => {
                        const entryNota = entry.nota ? entry.nota.trim() : '';
                        const targetNota = originalNomorSJ.trim();
                        return entryNota === targetNota && !entry.logEntryId; // Only delete if no logEntryId (old data)
                    });
                    
                    if (transactionsToDelete.length > 0) {
                        console.log(`🗑️ Deleting ${transactionsToDelete.length} old transactions (without logEntryId) for nota: ${originalNomorSJ}`);
                        
                        for (const transaction of transactionsToDelete) {
                            let deleteFunc = null;
                            if (typeof window.deleteEntryFromDB === 'function') {
                                deleteFunc = window.deleteEntryFromDB;
                            } else if (typeof deleteEntryFromDB === 'function') {
                                deleteFunc = deleteEntryFromDB;
                            }
                            
                            if (deleteFunc) {
                                try {
                                    await deleteFunc(transaction.id);
                                } catch (error) {
                                    console.error(`Error deleting transaction ID ${transaction.id} from DB:`, error);
                                }
                            }
                            
                            const index = window.stokData.findIndex(e => e.id === transaction.id);
                            if (index !== -1) {
                                window.stokData.splice(index, 1);
                            }
                        }
                        
                        if (typeof updateStokTable === 'function') updateStokTable();
                        if (typeof updateTotalSisa === 'function') updateTotalSisa();
                        if (typeof updateJenisKacaList === 'function') updateJenisKacaList();
                        if (typeof updateUkuranKacaList === 'function') updateUkuranKacaList();
                    }
                }
                
                // Clear originalNomorSJForDeletion after use
                originalNomorSJForDeletion = null;
                
                // Get all kaca rows
                const kacaRows = document.querySelectorAll('#kacaTableBody tr');
                const transactions = [];

                kacaRows.forEach((row, index) => {
                    // Cache querySelector results for better performance
                    const jenisKacaInput = row.querySelector('.jenis-kaca');
                    const ukuranInput = row.querySelector('.ukuran');
                    const hargaJualInput = row.querySelector('.harga-jual');
                    const totalLbrInput = row.querySelector('input.total-lbr-input');
                    
                    const jenisKaca = jenisKacaInput?.value?.trim() || '';
                    const ukuran = ukuranInput?.value?.trim() || '';
                    const hargaJualValue = hargaJualInput?.value?.trim() || '';
                    const totalLbrValue = totalLbrInput?.value?.trim() || '';
                    
                    // Skip if no jenis kaca or ukuran
                    if (!jenisKaca || !ukuran) return;
                    
                    // Parse total LBR
                    let totalLbr = 0;
                    if (totalLbrValue) {
                        const match = totalLbrValue.match(/^(\d+(?:\.\d+)?)/);
                        if (match) {
                            totalLbr = parseFloat(match[1]);
                        }
                    }
                    
                    // Skip if total LBR is 0 or invalid
                    if (!totalLbr || totalLbr <= 0) return;
                    
                    // Parse harga jual
                    let hargaJual = 0;
                    if (hargaJualValue) {
                        const hargaMatch = hargaJualValue.toString().replace(/[.,](?=\d{3}(\D|$))/g, '').replace(',', '.');
                        hargaJual = parseFloat(hargaMatch) || 0;
                    }
                    
                    // Get harga beli from stok data (if available)
                    // First, check if harga was selected from dropdown (stored in data attribute)
                    let hargaBeli = 0;
                    // Force update harga one more time right before reading it
                    if (ukuranInput) {
                        forceUpdateHargaForUkuran(ukuranInput);
                    }
                    const selectedHarga = ukuranInput ? ukuranInput.getAttribute('data-selected-harga') : null;
                    
                    if (selectedHarga) {
                        // Use harga from selected dropdown option
                        const hargaValues = selectedHarga.split(',').map(h => parseFloat(h.trim())).filter(h => !isNaN(h) && h > 0);
                        if (hargaValues.length > 0) {
                            // Use the first harga (or average if multiple)
                            hargaBeli = hargaValues[0];
                        }
                    }
                    
                    // If no harga from dropdown, try to find from stok data
                    // But prioritize using harga from selected dropdown option for stock deduction
                    if (selectedHarga && window.stokData && window.stokData.length > 0) {
                        // If harga was selected, find matching stok with the same harga
                        // This ensures we deduct stock from the correct harga group
                        const hargaValues = selectedHarga.split(',').map(h => parseFloat(h.trim())).filter(h => !isNaN(h) && h > 0);
                        if (hargaValues.length > 0) {
                            const targetHarga = hargaValues[0];
                            const matchingStok = window.stokData.find(entry => 
                                entry.tebal === jenisKaca && 
                                entry.ukuran === ukuran &&
                                entry.harga === targetHarga &&
                                entry.masuk > 0
                            );
                            if (matchingStok && matchingStok.harga) {
                                hargaBeli = matchingStok.harga;
                            }
                        }
                    } else if (!hargaBeli && window.stokData && window.stokData.length > 0) {
                        // If no harga selected, find any matching stok entry (fallback)
                        const matchingStok = window.stokData.find(entry => 
                            entry.tebal === jenisKaca && 
                            entry.ukuran === ukuran &&
                            entry.masuk > 0
                        );
                        if (matchingStok && matchingStok.harga) {
                            hargaBeli = matchingStok.harga;
                        }
                    }
                    
                    // Use nomor SJ as nota, fallback to default format if nomor SJ is empty
                    const notaValue = nomorSJ || `SJ-${formattedDate.replace(/\//g, '')}-${index + 1}`;
                    
                    // Create transaction entry
                    const transaction = {
                        id: Date.now() + index, // Unique ID
                        nama: namaToko,
                        tanggal: formattedDate,
                        nota: notaValue, // Use nomor SJ from input field
                        tebal: jenisKaca,
                        ukuran: ukuran,
                        harga: hargaBeli > 0 ? hargaBeli : undefined,
                        hargaJual: hargaJual > 0 ? hargaJual : undefined,
                        masuk: 0,
                        keluar: totalLbr,
                        logEntryId: lastLogEntryId || null // Link to log entry
                    };
                    
                    transactions.push(transaction);
                });
                
                // Record all transactions
                if (transactions.length > 0) {
                    // Add each transaction to stokData and IndexedDB
                    for (const transaction of transactions) {
                        try {
                            // Add to stokData array
                            if (Array.isArray(window.stokData)) {
                                window.stokData.unshift(transaction);
                            }
                            
                            // Add to IndexedDB if addEntry function is available
                            if (typeof addEntry === 'function') {
                                await addEntry(transaction);
                            }
                        } catch (error) {
                            console.error('Error recording transaction:', transaction, error);
                        }
                    }
                    
                    // Sync stokData local variable with window.stokData
                    if (typeof window.stokData !== 'undefined' && Array.isArray(window.stokData)) {
                        if (typeof stokData !== 'undefined') {
                            // Update local stokData to match window.stokData
                            stokData = [...window.stokData];
                        }
                    }
                    
                    // Update stok table and related UI if functions are available
                    if (typeof updateStokTable === 'function') {
                        updateStokTable();
                    }
                    if (typeof updateTotalSisa === 'function') {
                        updateTotalSisa();
                    }
                    if (typeof updateNamaTokoList === 'function') {
                        updateNamaTokoList();
                    }
                    if (typeof updateJenisKacaList === 'function') {
                        updateJenisKacaList();
                    }
                    if (typeof updateUkuranKacaList === 'function') {
                        updateUkuranKacaList();
                    }
                    
                    console.log(`Recorded ${transactions.length} stok transactions from surat jalan`);
                }
            } catch (error) {
                console.error('Error recording stok transactions from surat jalan:', error);
            }
        }

        // Process stok transactions from imported log entries
        async function processStokFromImportedLogs(importedEntries) {
            try {
                if (!importedEntries || importedEntries.length === 0) {
                    return;
                }

                // Ensure stokData is loaded
                if (typeof window.stokData === 'undefined' || !Array.isArray(window.stokData)) {
                    if (typeof loadData === 'function') {
                        await loadData();
                    } else {
                        window.stokData = [];
                    }
                }

                const transactions = [];
                
                // Process each imported entry
                for (const entry of importedEntries) {
                    const entryData = entry.data || {};
                    const kacaData = entryData.kacaData || {};
                    const rows = Array.isArray(kacaData) ? kacaData : (kacaData.rows || []);
                    
                    if (!rows || rows.length === 0) continue;
                    
                    const namaToko = entryData.namaToko || '';
                    const nomorSJ = entryData.nomorSJ || '';
                    const tanggal = entryData.tanggal || '';
                    
                    if (!namaToko) continue;
                    
                    // Format date if needed
                    let formattedDate = tanggal;
                    if (tanggal && !tanggal.includes('/')) {
                        // Try to parse ISO date or other formats
                        try {
                            const dateObj = new Date(tanggal);
                            if (!isNaN(dateObj.getTime())) {
                                if (typeof formatDate === 'function') {
                                    formattedDate = formatDate(tanggal);
                                } else {
                                    const day = String(dateObj.getDate()).padStart(2, '0');
                                    const month = String(dateObj.getMonth() + 1).padStart(2, '0');
                                    const year = dateObj.getFullYear();
                                    formattedDate = `${day}/${month}/${year}`;
                                }
                            }
                        } catch (e) {
                            // Use original date if parsing fails
                        }
                    }
                    
                    // Process each kaca row
                    rows.forEach((row, index) => {
                        const jenisKaca = (row.jenisKaca || '').trim();
                        const ukuran = (row.ukuran || '').trim();
                        const totalLbr = parseFloat(row.totalLbr) || 0;
                        const hargaJual = parseFloat(row.hargaJual || row.harga || 0) || 0;
                        
                        // Skip if no jenis kaca, ukuran, or totalLbr
                        if (!jenisKaca || !ukuran || !totalLbr || totalLbr <= 0) return;
                        
                        // Try to find harga beli from stok data
                        let hargaBeli = 0;
                        if (window.stokData && window.stokData.length > 0) {
                            const matchingStok = window.stokData.find(s => 
                                s.tebal === jenisKaca && 
                                s.ukuran === ukuran &&
                                s.masuk > 0
                            );
                            if (matchingStok && matchingStok.harga) {
                                hargaBeli = matchingStok.harga;
                            }
                        }
                        
                        // Use nomor SJ as nota, fallback to default format
                        const notaValue = nomorSJ || `SJ-${formattedDate.replace(/\//g, '')}-${index + 1}`;
                        
                        // Create transaction entry
                        const transaction = {
                            id: Date.now() + Math.random() + index, // Unique ID
                            nama: namaToko,
                            tanggal: formattedDate,
                            nota: notaValue,
                            tebal: jenisKaca,
                            ukuran: ukuran,
                            harga: hargaBeli > 0 ? hargaBeli : undefined,
                            hargaJual: hargaJual > 0 ? hargaJual : undefined,
                            masuk: 0,
                            keluar: totalLbr,
                            logEntryId: entry.id || null // Link to log entry
                        };
                        
                        transactions.push(transaction);
                    });
                }
                
                // Record all transactions
                if (transactions.length > 0) {
                    // Add each transaction to stokData and IndexedDB
                    for (const transaction of transactions) {
                        try {
                            // Check if transaction already exists
                            // First check by logEntryId (most precise)
                            let existingIndex = -1;
                            if (transaction.logEntryId) {
                                existingIndex = window.stokData.findIndex(t => 
                                    t.logEntryId === transaction.logEntryId && 
                                    t.tebal === transaction.tebal &&
                                    t.ukuran === transaction.ukuran
                                );
                            }
                            
                            // If not found by logEntryId, check by nota, tanggal, nama, tebal, ukuran (for old data without logEntryId)
                            if (existingIndex === -1) {
                                existingIndex = window.stokData.findIndex(t => 
                                    !t.logEntryId && // Only match old entries without logEntryId
                                    t.nota === transaction.nota &&
                                    t.tanggal === transaction.tanggal &&
                                    t.nama === transaction.nama &&
                                    t.tebal === transaction.tebal &&
                                    t.ukuran === transaction.ukuran &&
                                    t.keluar === transaction.keluar
                                );
                            }
                            
                            if (existingIndex === -1) {
                                // Add new transaction to stokData array
                                if (Array.isArray(window.stokData)) {
                                    window.stokData.unshift(transaction);
                                }
                                
                                // Add to IndexedDB if addEntry function is available
                                if (typeof addEntry === 'function') {
                                    await addEntry(transaction);
                                }
                            } else {
                                // Update existing transaction (preserve original ID)
                                const existingId = window.stokData[existingIndex].id;
                                transaction.id = existingId;
                                window.stokData[existingIndex] = transaction;
                                if (typeof updateEntry === 'function') {
                                    await updateEntry(transaction);
                                }
                            }
                        } catch (error) {
                            console.error('Error recording transaction from imported log:', transaction, error);
                        }
                    }
                    
                    // Sync stokData local variable with window.stokData
                    if (typeof window.stokData !== 'undefined' && Array.isArray(window.stokData)) {
                        if (typeof stokData !== 'undefined') {
                            stokData = [...window.stokData];
                        }
                    }
                    
                    // Update stok table and related UI if functions are available
                    if (typeof updateStokTable === 'function') {
                        updateStokTable();
                    }
                    if (typeof updateTotalSisa === 'function') {
                        updateTotalSisa();
                    }
                    if (typeof updateNamaTokoList === 'function') {
                        updateNamaTokoList();
                    }
                    if (typeof updateJenisKacaList === 'function') {
                        updateJenisKacaList();
                    }
                    if (typeof updateUkuranKacaList === 'function') {
                        updateUkuranKacaList();
                    }
                    
                    console.log(`✅ Processed ${transactions.length} stok transactions from ${importedEntries.length} imported log entries`);
                }
            } catch (error) {
                console.error('Error processing stok from imported logs:', error);
            }
        }

        // Quick print from header (uses current print settings, opens modal silently to generate data, then prints)
        function handleQuickPrint() {
            // Open modal to ensure latest data/layout prepared (hidden quickly)
            const modal = document.getElementById('printModalOverlay');
            const prevDisplay = modal.style.display;
            modal.style.display = 'flex';
            document.body.style.overflow = 'hidden';
            try {
                loadFontSizePreference();
                loadFontWeightPreference();
                loadFontFamilyPreference();
                loadColumnSpacingFromStorage();
                refreshPrintData();
                // Small delay to allow DOM updates
                setTimeout(() => {
                    // Auto-save log before printing
                    try { saveCurrentInputToLog(); } catch (e) { console.warn('Auto-save log failed:', e); }
                    // Record transactions to stok
                    // Force update all harga before recording transactions
                    const allUkuranInputs = document.querySelectorAll('#kacaTableBody tr .ukuran');
                    allUkuranInputs.forEach(ukuranInput => {
                        if (ukuranInput.value.trim()) {
                            // Trigger update by dispatching change event
                            ukuranInput.dispatchEvent(new Event('change', { bubbles: true }));
                        }
                    });
                    
                    // Wait a bit longer to ensure all updates complete
                    setTimeout(() => {
                        try { recordStokTransactionsFromSuratJalan(); } catch (e) { console.warn('Record stok transactions failed:', e); }
                        printNow();
                        // Close modal after triggering print
                        hidePrintModal();
                    }, 150);
                }, 50);
            } catch (e) {
                console.error('Quick print error:', e);
                // Fallback: show modal so user can print manually
                modal.style.display = 'flex';
            } finally {
                // Restore body overflow when modal hides via hidePrintModal
            }
        }
        // Utilitas database toko bersama untuk autocomplete dan auto-fill
        function buildTokoMapFromArray(arrayOfToko) {
            const nameToAddress = {};
            if (Array.isArray(arrayOfToko)) {
                arrayOfToko.forEach(entry => {
                    if (entry && entry.nama) {
                        nameToAddress[entry.nama.toLowerCase()] = entry.alamat || '';
                    }
                });
            }
            return nameToAddress;
        }

        function getDatabaseToko() {
            let map = {};
            try {
                const saved = storageManager.load('databaseToko');
                if (saved && typeof saved === 'object') {
                    map = saved;
                }
            } catch (_) {}
            // Hanya gunakan data dari storage tanpa default bawaan
            return map;
        }

        // Tidak lagi memaksa sync dari seed; gunakan storage manager
        function persistDatabaseTokoFromLengkap() {
            try {
                const map = buildTokoMapFromArray(databaseTokoLengkap);
                storageManager.save('databaseToko', map);
            } catch (_) {}
        }

        // Fungsi untuk mengisi alamat otomatis berdasarkan nama toko
        document.getElementById('namaToko').addEventListener('input', function() {
            const rawInput = this.value || '';
            const namaTokoLower = rawInput.toLowerCase();
            const alamatField = document.getElementById('alamat');
            const autocompleteDropdown = document.getElementById('autocompleteDropdown');
            
            // Tampilkan autocomplete jika ada input (case-insensitive, cari di nama/alamat)
            if (namaTokoLower.length > 0) {
                showAutocomplete(namaTokoLower);
            } else {
                hideAutocomplete();
            }
            
            // Auto-fill alamat berdasarkan data dari localStorage (map nama->alamat)
            const map = getDatabaseToko();
            const addressFromMap = map[namaTokoLower];
            if (addressFromMap) {
                alamatField.value = addressFromMap;
                alamatField.style.backgroundColor = '#f8f9fa';
                autoResizeTextarea(alamatField);
            } else {
                alamatField.value = '';
                alamatField.style.backgroundColor = '#fff';
                alamatField.style.height = '80px';
            }
        });

        // Fungsi untuk format tanggal Indonesia
        document.getElementById('tanggal').addEventListener('change', function() {
            const date = new Date(this.value);
            const options = { 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric' 
            };
            
            // Format tanggal Indonesia
            const tanggalIndonesia = date.toLocaleDateString('id-ID', options);
            console.log('Tanggal yang dipilih:', tanggalIndonesia);
        });

        // Handle form submission
        document.getElementById('tokoForm').addEventListener('submit', function(e) {
            e.preventDefault();
            
            const namaToko = document.getElementById('namaToko').value;
            const alamat = document.getElementById('alamat').value;
            const tanggal = document.getElementById('tanggal').value;
            const nomorSJ = document.getElementById('nomorSJ').value;
            const supir = document.getElementById('supir').value;
            const noKendaraan = document.getElementById('noKendaraan').value;
            
            if (!namaToko || !tanggal || !nomorSJ || !supir || !noKendaraan) {
                alert('Mohon lengkapi semua field yang wajib diisi!');
                return;
            }
            
            // Format tanggal untuk output
            const date = new Date(tanggal);
            const options = { 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric' 
            };
            const tanggalFormatted = date.toLocaleDateString('id-ID', options);
            
            // Output data
            const output = `
Data yang diinput:
Nama Toko: ${namaToko}
Alamat: ${alamat || 'Tidak ada alamat'}
Tanggal: ${tanggalFormatted}
No. SJ: ${nomorSJ}
Nama Supir: ${supir}
No. Kendaraan: ${noKendaraan}
            `;
            
            alert(output);
            console.log(output);
        });

        // Set tanggal default ke hari ini
        document.getElementById('tanggal').valueAsDate = new Date();

        // Enhanced storage manager with multiple fallback options
        class StorageManager {
            constructor() {
                this.storageKey = 'sj_app_data';
                this.fallbackData = {};
            }
            
            // Try multiple storage methods in order of preference
            save(key, data) {
                try {
                    // Method 1: localStorage (preferred)
                    localStorage.setItem(key, JSON.stringify(data));
                    return true;
                } catch (e) {
                    console.warn(`⚠️ localStorage failed for ${key}, trying alternatives...`);
                    
                    try {
                        // Method 2: sessionStorage (fallback)
                        sessionStorage.setItem(key, JSON.stringify(data));
                        console.log(`✅ Data saved to sessionStorage: ${key}`);
                        return true;
                    } catch (e2) {
                        console.warn(`⚠️ sessionStorage failed for ${key}, using memory fallback`);
                        
                        // Method 3: In-memory storage (last resort)
                        this.fallbackData[key] = data;
                        console.log(`✅ Data saved to memory fallback: ${key}`);
                        return true;
                    }
                }
            }
            
            load(key) {
                try {
                    // Method 1: localStorage
                    const data = localStorage.getItem(key);
                    if (data) {
                        return JSON.parse(data);
                    }
                } catch (e) {
                    console.warn(`⚠️ localStorage read failed for ${key}`);
                }
                
                try {
                    // Method 2: sessionStorage
                    const data = sessionStorage.getItem(key);
                    if (data) {
                        console.log(`✅ Data loaded from sessionStorage: ${key}`);
                        return JSON.parse(data);
                    }
                } catch (e) {
                    console.warn(`⚠️ sessionStorage read failed for ${key}`);
                }
                
                // Method 3: In-memory fallback
                if (this.fallbackData[key]) {
                    console.log(`✅ Data loaded from memory fallback: ${key}`);
                    return this.fallbackData[key];
                }
                
                console.log(`ℹ️ No data found for key: ${key}`);
                return null;
            }
            
            // Export data for backup/download
            async exportData() {
                const allData = {};
                const keys = ['databaseToko', 'databaseTokoLengkap', 'printTextPositions', 
                             'inputLogHistory', 'lastNomorSJ', 'printFontSize', 'printFontFamily', 
                             'printFontWeight', 'printColumnSpacing', 'columnSpacingConfig'];
                
                keys.forEach(key => {
                    const data = this.load(key);
                    if (data !== null) {
                        allData[key] = data;
                    }
                });
                
                // Try to get inputLogHistory from IndexedDB if available (prioritize IndexedDB)
                try {
                    // Try to access IndexedDB directly
                    const idbLogHistory = await new Promise((resolve, reject) => {
                        try {
                            const req = window.indexedDB.open('sj-logs-db', 1);
                            req.onsuccess = () => {
                                const db = req.result;
                                const tx = db.transaction('kv', 'readonly');
                                const store = tx.objectStore('kv');
                                const getReq = store.get('inputLogHistory');
                                getReq.onsuccess = () => {
                                    db.close();
                                    resolve(getReq.result ? getReq.result.value : undefined);
                                };
                                getReq.onerror = () => {
                                    db.close();
                                    reject(getReq.error);
                                };
                            };
                            req.onerror = () => reject(req.error);
                        } catch (e) {
                            reject(e);
                        }
                    });
                    
                    if (Array.isArray(idbLogHistory) && idbLogHistory.length > 0) {
                        allData['inputLogHistory'] = idbLogHistory;
                        console.log('✅ Input log included in backup from IndexedDB:', idbLogHistory.length, 'entries');
                    } else if (allData['inputLogHistory'] && Array.isArray(allData['inputLogHistory'])) {
                        console.log('✅ Input log included in backup from localStorage:', allData['inputLogHistory'].length, 'entries');
                    } else if (typeof window !== 'undefined' && window.inputLogHistory && Array.isArray(window.inputLogHistory)) {
                        allData['inputLogHistory'] = window.inputLogHistory;
                        console.log('✅ Input log included in backup from window.inputLogHistory:', window.inputLogHistory.length, 'entries');
                    }
                } catch (e) {
                    console.warn('⚠️ Failed to export input log from IndexedDB, trying alternatives:', e);
                    // Fallback to localStorage or window variable
                    if (allData['inputLogHistory'] && Array.isArray(allData['inputLogHistory'])) {
                        console.log('✅ Input log included in backup from localStorage:', allData['inputLogHistory'].length, 'entries');
                    } else if (typeof window !== 'undefined' && window.inputLogHistory && Array.isArray(window.inputLogHistory)) {
                        allData['inputLogHistory'] = window.inputLogHistory;
                        console.log('✅ Input log included in backup from window.inputLogHistory:', window.inputLogHistory.length, 'entries');
                    }
                }
                
                // Export riwayat stok from IndexedDB
                try {
                    if (typeof loadData === 'function') {
                        const stokDataArray = await loadData();
                        if (Array.isArray(stokDataArray) && stokDataArray.length > 0) {
                            allData['stokData'] = stokDataArray;
                            console.log('✅ Riwayat stok included in backup:', stokDataArray.length, 'entries');
                        }
                    }
                } catch (e) {
                    console.warn('⚠️ Failed to export riwayat stok:', e);
                }
                
                return JSON.stringify(allData, null, 2);
            }
            
            // Import data from backup
            async importData(jsonData) {
                try {
                    const data = JSON.parse(jsonData);
                    
                    // Import riwayat stok to IndexedDB if present
                    if (data.stokData && Array.isArray(data.stokData)) {
                        try {
                            const storeName = typeof STORE_NAME !== 'undefined' ? STORE_NAME : 'stokData';
                            
                            // Clear existing stokData first
                            if (typeof initDB === 'function') {
                                await initDB();
                                if (typeof db !== 'undefined' && db) {
                                    const transaction = db.transaction([storeName], 'readwrite');
                                    const store = transaction.objectStore(storeName);
                                    await new Promise((resolve, reject) => {
                                        const clearRequest = store.clear();
                                        clearRequest.onsuccess = () => resolve();
                                        clearRequest.onerror = () => reject(clearRequest.error);
                                    });
                                    
                                    // Add all stokData entries
                                    for (const entry of data.stokData) {
                                        await new Promise((resolve, reject) => {
                                            const request = store.add(entry);
                                            request.onsuccess = () => resolve();
                                            request.onerror = () => reject(request.error);
                                        });
                                    }
                                    
                                    // Update global stokData array
                                    if (typeof window !== 'undefined') {
                                        window.stokData = data.stokData;
                                        // Also update stokData variable if it exists in current scope
                                        if (typeof stokData !== 'undefined') {
                                            stokData = data.stokData;
                                        }
                                    }
                                    
                                    // Update tables if functions are available
                                    if (typeof updateStokTable === 'function') {
                                        updateStokTable();
                                    }
                                    if (typeof updateTotalSisa === 'function') {
                                        updateTotalSisa();
                                    }
                                    
                                    console.log('✅ Riwayat stok imported successfully:', data.stokData.length, 'entries');
                                }
                            } else if (typeof addEntry === 'function') {
                                // Fallback: use addEntry function if available
                                for (const entry of data.stokData) {
                                    await addEntry(entry);
                                }
                                
                                // Update global stokData array
                                if (typeof window !== 'undefined') {
                                    window.stokData = data.stokData;
                                    if (typeof stokData !== 'undefined') {
                                        stokData = data.stokData;
                                    }
                                }
                                
                                // Update tables if functions are available
                                if (typeof updateStokTable === 'function') {
                                    updateStokTable();
                                }
                                if (typeof updateTotalSisa === 'function') {
                                    updateTotalSisa();
                                }
                                
                                console.log('✅ Riwayat stok imported via addEntry:', data.stokData.length, 'entries');
                            }
                            
                            // Remove stokData from data object to avoid saving to localStorage
                            delete data.stokData;
                        } catch (e) {
                            console.warn('⚠️ Failed to import riwayat stok:', e);
                        }
                    }
                    
                    // Import other data to localStorage
                    Object.keys(data).forEach(key => {
                        this.save(key, data[key]);
                    });
                    
                    // Update inputLogHistory and render log if present
                    if (data.inputLogHistory && Array.isArray(data.inputLogHistory)) {
                        try {
                            // Save to IndexedDB if available
                            try {
                                const db = await new Promise((resolve, reject) => {
                                    const req = window.indexedDB.open('sj-logs-db', 1);
                                    req.onupgradeneeded = () => {
                                        const db = req.result;
                                        if (!db.objectStoreNames.contains('kv')) {
                                            db.createObjectStore('kv', { keyPath: 'key' });
                                        }
                                    };
                                    req.onsuccess = () => resolve(req.result);
                                    req.onerror = () => reject(req.error);
                                });
                                
                                await new Promise((resolve, reject) => {
                                    const tx = db.transaction('kv', 'readwrite');
                                    tx.oncomplete = resolve;
                                    tx.onerror = () => reject(tx.error);
                                    tx.objectStore('kv').put({ key: 'inputLogHistory', value: data.inputLogHistory });
                                });
                                db.close();
                                console.log('✅ Input log saved to IndexedDB:', data.inputLogHistory.length, 'entries');
                            } catch (e) {
                                console.warn('⚠️ Failed to save input log to IndexedDB:', e);
                            }
                            
                            // Update global inputLogHistory variable
                            if (typeof window !== 'undefined') {
                                if (typeof inputLogHistory !== 'undefined') {
                                    inputLogHistory = data.inputLogHistory;
                                }
                                window.inputLogHistory = data.inputLogHistory;
                            }
                            
                            // Render the log
                            if (typeof renderInputLog === 'function') {
                                renderInputLog();
                                console.log('✅ Input log rendered after restore');
                            }
                            
                            // Update suggestions
                            if (typeof updateKacaSuggestionsFromLogs === 'function') {
                                updateKacaSuggestionsFromLogs();
                            }
                            
                            // Update nomor SJ warning
                            if (typeof window.refreshNomorSJWarningNow === 'function') {
                                window.refreshNomorSJWarningNow();
                            }
                            
                            console.log('✅ Input log imported and rendered:', data.inputLogHistory.length, 'entries');
                        } catch (e) {
                            console.warn('⚠️ Failed to render input log after restore:', e);
                        }
                    }
                    
                    // Update lastNomorSJ if present
                    if (data.lastNomorSJ !== undefined) {
                        try {
                            if (typeof window !== 'undefined' && typeof lastNomorSJ !== 'undefined') {
                                lastNomorSJ = data.lastNomorSJ;
                                window.lastNomorSJ = data.lastNomorSJ;
                            }
                        } catch (e) {
                            console.warn('⚠️ Failed to update lastNomorSJ:', e);
                        }
                    }
                    
                    console.log('✅ Data imported successfully');
                    return true;
                } catch (e) {
                    console.error('❌ Failed to import data:', e);
                    return false;
                }
            }
        }
        
        // Initialize storage manager
        const storageManager = new StorageManager();
        
        // Backup and Restore functionality
        document.addEventListener('DOMContentLoaded', function() {
            const backupBtn = document.getElementById('backupBtn');
            const restoreBtn = document.getElementById('restoreBtn');
            const restoreFile = document.getElementById('restoreFile');
            
            if (backupBtn) {
                backupBtn.addEventListener('click', async function() {
                    try {
                        const data = await storageManager.exportData();
                        const blob = new Blob([data], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `SJ_BACKUP_${new Date().toISOString().split('T')[0]}.json`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        
                        alert('✅ Data berhasil di-backup');
                    } catch (error) {
                        console.error('❌ Backup failed:', error);
                        alert('❌ Gagal melakukan backup data!');
                    }
                });
            }
            
            if (restoreBtn) {
                restoreBtn.addEventListener('click', function() {
                    restoreFile.click();
                });
            }
            
            if (restoreFile) {
                restoreFile.addEventListener('change', function(e) {
                    const file = e.target.files[0];
                    if (!file) return;
                    
                    const reader = new FileReader();
                    reader.onload = async function(e) {
                        try {
                            const success = await storageManager.importData(e.target.result);
                            if (success) {
                                alert('✅ Data berhasil di-restore');
                                location.reload();
                            } else {
                                alert('❌ Gagal melakukan restore data!');
                            }
                        } catch (error) {
                            console.error('❌ Restore failed:', error);
                            alert('❌ File backup tidak valid!');
                        }
                    };
                    reader.readAsText(file);
                });
            }
        });

        // Database toko lengkap dikelola via localStorage (tanpa seed bawaan)
        const databaseTokoLengkap = [];
        // Load dari storage dengan fallback
        (function loadDatabaseTokoLengkapFromStorage(){
            try {
                const saved = storageManager.load('databaseTokoLengkap');
                if (Array.isArray(saved) && saved.length > 0) {
                    databaseTokoLengkap.splice(0, databaseTokoLengkap.length, ...saved);
                    // Sinkronkan map autocomplete dari data yang di-load agar tanpa default bawaan
                    try { persistDatabaseTokoFromLengkap(); } catch (_) {}
                }
            } catch (_) {}
        })();

        function persistDatabaseTokoLengkapArray() {
            storageManager.save('databaseTokoLengkap', databaseTokoLengkap);
        }
        // Hapus inisialisasi otomatis dari seed; hanya gunakan data localStorage yang ada

        // Fungsi untuk menampilkan popup daftar toko
        function showTokoList() {
            const popup = document.getElementById('popupOverlay');
            const tokoList = document.getElementById('tokoList');
            
            // Generate daftar toko dari array yang tersimpan (di-load dari localStorage)
            tokoList.innerHTML = '';
            if (!Array.isArray(databaseTokoLengkap) || databaseTokoLengkap.length === 0) {
                const empty = document.createElement('div');
                empty.className = 'no-results';
                empty.textContent = 'Belum ada toko yang tersedia';
                tokoList.appendChild(empty);
            } else {
                databaseTokoLengkap.forEach((toko, index) => {
                    const tokoItem = document.createElement('div');
                    tokoItem.className = 'toko-item';
                    tokoItem.innerHTML = `
                        <div class="toko-nama">🏪 ${toko.nama}</div>
                        <div class="toko-alamat">📍 ${toko.alamat}</div>
                        <div class="action-buttons">
                            <button class="btn-edit" onclick="editToko(${index})">✏️ Edit</button>
                            <button class="btn-delete" onclick="deleteToko(${index})">🗑️ Hapus</button>
                        </div>
                    `;
                    tokoList.appendChild(tokoItem);
                });
            }
            
            popup.style.display = 'flex';
            document.body.style.overflow = 'hidden'; // Prevent scrolling
        }

        // Fungsi untuk menyembunyikan popup
        function hideTokoList() {
            const popup = document.getElementById('popupOverlay');
            popup.style.display = 'none';
            document.body.style.overflow = 'auto'; // Restore scrolling
        }

        // Close popup when clicking outside
        document.getElementById('popupOverlay').addEventListener('click', function(e) {
            if (e.target === this) {
                hideTokoList();
            }
        });

        // Close popup with Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                hideTokoList();
                hideModal();
                hideQuickAddModal();
                hidePrintModal();
            }
            // Handle Ctrl+P or Cmd+P to trigger Print Sekarang
            if ((e.ctrlKey || e.metaKey) && e.key === 'p') {
                e.preventDefault();
                if (typeof handleQuickPrint === 'function') {
                    handleQuickPrint();
                }
            }
        });

        // Refresh page helper
        function refreshPage() {
            try {
                window.location.reload();
            } catch (_) {
                // Fallback: navigate to same URL
                window.location.href = window.location.href;
            }
        }

        // Fungsi untuk menampilkan modal tambah toko
        function showAddModal() {
            const modal = document.getElementById('modalOverlay');
            const modalTitle = document.getElementById('modalTitle');
            const saveBtn = document.getElementById('saveBtn');
            const editIndex = document.getElementById('editIndex');
            
            modalTitle.textContent = '➕ Tambah Toko Baru';
            saveBtn.textContent = 'Simpan';
            editIndex.value = '';
            
            // Reset form
            document.getElementById('modalNamaToko').value = '';
            document.getElementById('modalAlamat').value = '';
            
            modal.style.display = 'flex';
            document.body.style.overflow = 'hidden';
        }

        // Fungsi untuk menampilkan quick add modal
        function showQuickAddModal() {
            const modal = document.getElementById('quickAddModalOverlay');
            
            // Reset form
            document.getElementById('quickAddNamaToko').value = '';
            document.getElementById('quickAddAlamat').value = '';
            
            // Reset ke tab pertama
            showQuickAddTab();
            
            modal.style.display = 'flex';
            document.body.style.overflow = 'hidden';
        }

        // Fungsi untuk menampilkan tab tambah toko
        function showQuickAddTab() {
            const addTab = document.getElementById('quickAddTab');
            const listTab = document.getElementById('quickListTab');
            if (addTab) addTab.classList.add('active');
            if (listTab) listTab.classList.remove('active');
            // Update tab buttons safely tanpa bergantung pada event
            const buttons = Array.from(document.querySelectorAll('.tab-btn'));
            buttons.forEach(btn => btn.classList.remove('active'));
            const addBtn = buttons.find(b => /Tambah Baru/i.test(b.textContent || ''));
            if (addBtn) addBtn.classList.add('active');
        }

        // Fungsi untuk menampilkan tab daftar toko
        function showQuickListTab() {
            const addTab = document.getElementById('quickAddTab');
            const listTab = document.getElementById('quickListTab');
            if (addTab) addTab.classList.remove('active');
            if (listTab) listTab.classList.add('active');
            // Update tab buttons safely tanpa bergantung pada event
            const buttons = Array.from(document.querySelectorAll('.tab-btn'));
            buttons.forEach(btn => btn.classList.remove('active'));
            const listBtn = buttons.find(b => /Lihat Daftar/i.test(b.textContent || ''));
            if (listBtn) listBtn.classList.add('active');
            // Generate daftar toko
            generateQuickTokoList();
        }

        // Fungsi untuk menyembunyikan quick add modal
        function hideQuickAddModal() {
            const modal = document.getElementById('quickAddModalOverlay');
            modal.style.display = 'none';
            document.body.style.overflow = 'auto';
        }

        // Fungsi untuk menampilkan modal edit toko
        function editToko(index) {
            const modal = document.getElementById('modalOverlay');
            const modalTitle = document.getElementById('modalTitle');
            const saveBtn = document.getElementById('saveBtn');
            const editIndex = document.getElementById('editIndex');
            const toko = databaseTokoLengkap[index];
            
            modalTitle.textContent = '✏️ Edit Toko';
            saveBtn.textContent = 'Update';
            editIndex.value = index;
            
            // Isi form dengan data yang ada
            document.getElementById('modalNamaToko').value = toko.nama;
            document.getElementById('modalAlamat').value = toko.alamat;
            
            modal.style.display = 'flex';
            document.body.style.overflow = 'hidden';
        }

        // Fungsi untuk menghapus toko
        function deleteToko(index) {
            if (confirm('Apakah Anda yakin ingin menghapus toko ini?')) {
                databaseTokoLengkap.splice(index, 1);
                // Sinkronkan database autocomplete dan daftar lengkap yang tersimpan
                persistDatabaseTokoFromLengkap();
                persistDatabaseTokoLengkapArray();
                
                // Refresh popup jika sedang terbuka
                if (document.getElementById('popupOverlay').style.display === 'flex') {
                    showTokoList();
                }
                // Refresh quick list tab jika sedang terbuka
                const quickModal = document.getElementById('quickAddModalOverlay');
                const quickListTab = document.getElementById('quickListTab');
                if (quickModal && quickModal.style.display === 'flex' && quickListTab && quickListTab.classList.contains('active')) {
                    generateQuickTokoList();
                }

                alert('Toko berhasil dihapus!');
            }
        }

        // Fungsi untuk menyembunyikan modal
        function hideModal() {
            const modal = document.getElementById('modalOverlay');
            modal.style.display = 'none';
            document.body.style.overflow = 'auto';
        }

        // Handle form modal submission
        document.getElementById('modalForm').addEventListener('submit', function(e) {
            e.preventDefault();
            
            const namaToko = document.getElementById('modalNamaToko').value.trim();
            const alamat = document.getElementById('modalAlamat').value.trim();
            const editIndex = document.getElementById('editIndex').value;
            
            if (!namaToko || !alamat) {
                alert('Mohon lengkapi semua field!');
                return;
            }
            
            if (editIndex === '') {
                // Tambah toko baru
                const newToko = {
                    nama: namaToko,
                    alamat: alamat
                };
                
                databaseTokoLengkap.push(newToko);
                // Sinkronkan database autocomplete dan daftar lengkap yang tersimpan
                persistDatabaseTokoFromLengkap();
                persistDatabaseTokoLengkapArray();
                
                alert('Toko berhasil ditambahkan!');
            } else {
                // Edit toko yang ada
                const index = parseInt(editIndex);
                const oldNama = databaseTokoLengkap[index].nama;
                
                // Update database lengkap
                databaseTokoLengkap[index] = {
                    nama: namaToko,
                    alamat: alamat
                };
                // Sinkronkan database autocomplete dan daftar lengkap yang tersimpan
                persistDatabaseTokoFromLengkap();
                persistDatabaseTokoLengkapArray();
                
                alert('Toko berhasil diupdate!');
            }
            
            hideModal();
            
            // Refresh popup jika sedang terbuka
            if (document.getElementById('popupOverlay').style.display === 'flex') {
                showTokoList();
            }

            // Refresh quick list tab jika sedang terbuka
            const quickModal = document.getElementById('quickAddModalOverlay');
            const quickListTab = document.getElementById('quickListTab');
            if (quickModal && quickModal.style.display === 'flex' && quickListTab && quickListTab.classList.contains('active')) {
                generateQuickTokoList();
            }
        });

        // Close modal when clicking outside
        document.getElementById('modalOverlay').addEventListener('click', function(e) {
            if (e.target === this) {
                hideModal();
            }
        });

        // Close quick add modal when clicking outside
        document.getElementById('quickAddModalOverlay').addEventListener('click', function(e) {
            if (e.target === this) {
                hideQuickAddModal();
            }
        });

        // Handle quick add form submission
        document.getElementById('quickAddForm').addEventListener('submit', function(e) {
            e.preventDefault();
            
            // Normalisasi: simpan Nama apa adanya (preserve case) untuk tampilan,
            // namun lakukan pencarian/duplikasi dengan lower-case key
            const namaInput = document.getElementById('quickAddNamaToko').value.trim();
            const alamatInput = document.getElementById('quickAddAlamat').value.trim();
            const namaKey = namaInput.toLowerCase();
            
            if (!namaInput || !alamatInput) {
                alert('Mohon lengkapi semua field yang wajib diisi!');
                return;
            }
            
            // Tambah toko baru
            const newToko = {
                nama: namaInput,
                alamat: alamatInput
            };
            
            // Cek duplikasi berdasarkan lower-case key
            const existingIndex = databaseTokoLengkap.findIndex(t => (t.nama || '').toLowerCase() === namaKey);
            if (existingIndex >= 0) {
                // Update yang lama untuk menjaga satu sumber truth
                databaseTokoLengkap[existingIndex] = newToko;
            } else {
                databaseTokoLengkap.push(newToko);
            }
            // Sinkronkan database autocomplete dan daftar lengkap yang tersimpan
            persistDatabaseTokoFromLengkap();
            persistDatabaseTokoLengkapArray();
            // Segarkan daftar cepat bila tab "Lihat Daftar" dibuka setelahnya
            try { generateQuickTokoList(); } catch (_) {}
            
            // Auto-fill form utama
            const alamatField = document.getElementById('alamat');
            document.getElementById('namaToko').value = namaInput;
            alamatField.value = alamatInput;
            alamatField.style.backgroundColor = '#f8f9fa';
            
            // Auto-resize textarea
            autoResizeTextarea(alamatField);
            
            alert('Toko berhasil ditambahkan dan form telah diisi otomatis!');
            hideQuickAddModal();
        });

        // Fungsi untuk auto-resize textarea
        function autoResizeTextarea(textarea) {
            // Reset height untuk mendapatkan scrollHeight yang akurat
            textarea.style.height = 'auto';
            
            // Set height berdasarkan konten
            const newHeight = Math.max(80, textarea.scrollHeight);
            textarea.style.height = newHeight + 'px';
        }

        // Fungsi untuk generate baris default tabel kaca
        // Removed generateDefaultKacaRows (not used anymore)

        // Global helper for caching datalist
        let _globalCachedUkuranList = null;
        function getGlobalUkuranList() {
            if (!_globalCachedUkuranList) {
                _globalCachedUkuranList = document.getElementById('datalistUkuran');
            }
            return _globalCachedUkuranList;
        }

        // Global function for update harga ukuran logic
        function updateHargaUkuranLogic(inputElement, forceUpdate = false, explicitSize = null, explicitPrice = null) {
            const originalValue = inputElement.value.trim();
            
            console.log(`[Price Update] Processing update for value: "${originalValue}", force: ${forceUpdate}`);
            
            // Check for price suffix from unique options (e.g. "10x10 (Rp 5.000)")
            const priceMatch = originalValue.match(/(.*)\s+\(Rp\s+[\d\.,]+\)$/);
            let cleanValue = originalValue;
            let hasPriceSuffix = false;
            
            if (priceMatch) {
                cleanValue = priceMatch[1].trim();
                hasPriceSuffix = true;
                console.log(`[Price Update] Detected price suffix. Clean value: "${cleanValue}"`);
            }

            const currentHarga = inputElement.getAttribute('data-selected-harga') || '';
            
            // Use passed explicit values or get from attributes
            const lockSize = explicitSize || inputElement.getAttribute('data-explicit-size');
            const lockPrice = explicitPrice || inputElement.getAttribute('data-explicit-price');
            
            // Get current harga from harga-jual input field for better matching
            const row = inputElement.closest('tr');
            const hargaJualInput = row ? row.querySelector('.harga-jual') : null;
            const currentHargaJual = hargaJualInput ? hargaJualInput.value.trim().replace(/[^\d]/g, '') : '';
            
            // State management on element
            const lastUkuranValue = inputElement._lastUkuranValue || '';
            const lastSelectedHarga = inputElement._lastSelectedHarga || '';
            
            // Update if value changed OR if harga might have changed (same ukuran, different harga)
            // Also force update if explicitly requested
            if (!forceUpdate && cleanValue === lastUkuranValue && cleanValue && currentHarga === lastSelectedHarga && !hasPriceSuffix) {
                console.log('[Price Update] Skipping update - no changes detected');
                return;
            }
            
            // If user clears input, clear explicit locks
            if (!cleanValue) {
                inputElement.removeAttribute('data-explicit-size');
                inputElement.removeAttribute('data-explicit-price');
            }

            // Check if we have an explicit lock and the size hasn't changed
            // This ensures that if the user selected a specific price, we stick to it
            // even if the input value is just the size (without suffix)
            let lockedPrice = null;
            if (lockSize && lockPrice && cleanValue === lockSize) {
                 console.log(`[Price Update] Using explicit lock for size "${lockSize}" with price "${lockPrice}"`);
                 lockedPrice = lockPrice;
                 // Ensure attributes are set if they were passed as args
                 if (explicitSize) inputElement.setAttribute('data-explicit-size', explicitSize);
                 if (explicitPrice) inputElement.setAttribute('data-explicit-price', explicitPrice);
            } else if (cleanValue !== lockSize && lockSize) {
                 // Size changed, clear lock
                 console.log('[Price Update] Size changed, clearing explicit lock');
                 inputElement.removeAttribute('data-explicit-size');
                 inputElement.removeAttribute('data-explicit-price');
            }
            
            inputElement._lastUkuranValue = cleanValue;
            
            if (cleanValue) {
                const ukuranList = getGlobalUkuranList();
                if (ukuranList) {
                    // Find all matching options (same ukuran might have different harga)
                    const matchingOptions = Array.from(ukuranList.options).filter(opt => {
                        const optValue = opt.value.trim();
                        const optDisplay = opt.textContent.trim();
                        
                        // If input has suffix, we look for exact match first
                        if (hasPriceSuffix) {
                            return optValue === originalValue;
                        }
                        
                        // Otherwise match base value
                        // We need to handle options that might have suffixes
                        const optValueClean = optValue.replace(/\s+\(Rp\s+[\d\.,]+\)$/, '');
                        return optValueClean === cleanValue || optDisplay.startsWith(cleanValue);
                    });
                    
                    // If multiple options found, use smart matching
                    let selectedOption = null;
                    if (matchingOptions.length > 0) {
                        console.log(`[Price Update] Found ${matchingOptions.length} matching options`);
                        
                        // PRIORITY 1: Explicit Locked Price
                        if (lockedPrice) {
                            selectedOption = matchingOptions.find(opt => {
                                const optHarga = opt.getAttribute('data-harga');
                                return optHarga === lockedPrice;
                            });
                            if (selectedOption) console.log('[Price Update] Matched by explicit lock');
                        }

                        // PRIORITY 2: Exact string match (e.g. user typed suffix)
                        if (!selectedOption) {
                            selectedOption = matchingOptions.find(opt => {
                                const optValue = opt.value.trim();
                                return optValue === originalValue;
                            });
                        }
                        
                        // PRIORITY 3: Match clean value (size)
                        if (!selectedOption) {
                            // Filter options that match the clean size
                            const sizeMatches = matchingOptions.filter(opt => {
                                 const optValueClean = opt.value.trim().replace(/\s+\(Rp\s+[\d\.,]+\)$/, '');
                                 return optValueClean === cleanValue;
                            });

                            if (sizeMatches.length > 0) {
                                // If we have multiple prices for this size
                                if (sizeMatches.length > 1) {
                                    // Try to match with current harga-jual value if available
                                    if (currentHargaJual) {
                                        const matchingByHarga = sizeMatches.find(opt => {
                                            const optHarga = opt.getAttribute('data-harga');
                                            if (!optHarga) return false;
                                            const hargaValues = optHarga.split(',').map(h => h.trim().replace(/[^\d]/g, ''));
                                            return hargaValues.includes(currentHargaJual);
                                        });
                                        if (matchingByHarga) {
                                            selectedOption = matchingByHarga;
                                            console.log('[Price Update] Matched by existing price value');
                                        }
                                    }
                                    
                                    // If no price match, default to the first one (or previous selection if valid)
                                    if (!selectedOption && currentHarga) {
                                         const matchingByDataHarga = sizeMatches.find(opt => opt.getAttribute('data-harga') === currentHarga);
                                         if (matchingByDataHarga) selectedOption = matchingByDataHarga;
                                    }
                                    
                                    if (!selectedOption) selectedOption = sizeMatches[0];
                                } else {
                                    selectedOption = sizeMatches[0];
                                }
                            }
                        }
                    }
                    
                    if (selectedOption) {
                        const hargaAttr = selectedOption.getAttribute('data-harga');
                        console.log(`[Price Update] Selected price: ${hargaAttr}`);
                        
                        if (hargaAttr) {
                            // Always update attributes
                            inputElement.setAttribute('data-selected-harga', hargaAttr);
                            // Also save to row for easy access
                            if (row) {
                                row.setAttribute('data-selected-harga', hargaAttr);
                            }
                            inputElement._lastSelectedHarga = hargaAttr;

                            // SET EXPLICIT LOCK if we have a suffix or user is selecting or explicit lock was passed
                            // This ensures subsequent updates (e.g. blur) stick to this price
                            if (hasPriceSuffix || forceUpdate || explicitPrice) {
                                inputElement.setAttribute('data-explicit-size', cleanValue);
                                inputElement.setAttribute('data-explicit-price', hargaAttr);
                                console.log(`[Price Update] Set explicit lock: Size=${cleanValue}, Price=${hargaAttr}`);
                            }
                            
                            // Also update harga-jual field if it's empty or different
                            if (hargaJualInput) {
                                const hargaValues = hargaAttr.split(',').map(h => h.trim()).filter(h => h);
                                if (hargaValues.length > 0) {
                                    const firstHarga = parseFloat(hargaValues[0]);
                                    if (!isNaN(firstHarga) && firstHarga > 0) {
                                        // Always update placeholder to reflect current selection
                                        const newPlaceholder = `Rp ${firstHarga.toLocaleString('id-ID')}`;
                                        if (hargaJualInput.placeholder !== newPlaceholder) {
                                            hargaJualInput.placeholder = newPlaceholder;
                                            console.log(`[Price Update] Updated placeholder to: ${newPlaceholder}`);
                                        }
                                    }
                                }
                            }
                            
                            // Clean input value if it had a suffix to show only size
                            if (hasPriceSuffix) {
                                inputElement.value = cleanValue;
                                // Update tracking to prevent loops if needed, though handled at start
                                if (inputElement._lastUkuranValue !== cleanValue) {
                                    inputElement._lastUkuranValue = cleanValue;
                                }
                            }
                        }
                    }
                }
            }
        }

        // Fungsi untuk menambah baris baru
        function addKacaRow() {
            try {
                const tbody = document.getElementById('kacaTableBody');
                if (!tbody) {
                    console.error('kacaTableBody element not found');
                    return;
                }
                
                const newRow = document.createElement('tr');
                const rowId = Date.now() + Math.random();
                
                newRow.innerHTML = `
                    <td>
                        <input type="text" placeholder="Jenis Kaca" class="jenis-kaca" list="datalistJenisKaca" onchange="calculateTotalLbr(this)" autocomplete="off" autocapitalize="none" spellcheck="false">
                    </td>
                    <td class="pwd-input">
                        <input type="text" placeholder="PWD" class="pwd" maxlength="3">
                    </td>
                    <td class="no-do-input">
                        <input type="text" placeholder="No DO" class="no-do">
                    </td>
                    <td>
                        <input type="text" placeholder="Ukuran" class="ukuran" list="datalistUkuran" onchange="calculateTotalLbr(this)" autocomplete="off" autocapitalize="none" spellcheck="false">
                    </td>
                    <td class="harga-input">
                        <input type="text" placeholder="Harga Jual" class="harga-jual" onchange="calculateTotalLbr(this)" oninput="calculateTotalLbr(this)">
                    </td>
                    <td class="box-input">
                        <input type="text" placeholder="0 BOX" class="box" onchange="calculateTotalLbr(this)" oninput="calculateTotalLbr(this)">
                    </td>
                    <td class="lbr-input">
                        <input type="text" placeholder="0 LBR" class="lbr" onchange="calculateTotalLbr(this)" oninput="calculateTotalLbr(this)">
                    </td>
                    <td class="total-lbr">
                        <input type="text" placeholder="0 LBR" class="total-lbr-input" readonly>
                    </td>
                `;
                
                tbody.appendChild(newRow);

                // Attach simple inline drop-down behavior to encourage reuse
                const jenisInput = newRow.querySelector('input.jenis-kaca');
                const ukuranInput = newRow.querySelector('input.ukuran');
                if (jenisInput) {
                    jenisInput.setAttribute('autocomplete', 'off');
                    jenisInput.setAttribute('autocapitalize', 'none');
                    jenisInput.setAttribute('spellcheck', 'false');
                    jenisInput.addEventListener('focus', updateKacaSuggestionsFromLogs, { once: true });
                    // Update ukuran dropdown when jenis kaca changes
                    jenisInput.addEventListener('change', function() {
                        const jenisValue = this.value.trim();
                        if (ukuranInput) {
                            updateUkuranByJenisKaca(jenisValue, ukuranInput);
                        }
                    });
                    jenisInput.addEventListener('input', function() {
                        const jenisValue = this.value.trim();
                        if (ukuranInput && jenisValue) {
                            updateUkuranByJenisKaca(jenisValue, ukuranInput);
                        }
                    });
                }
                if (ukuranInput) {
                    ukuranInput.setAttribute('autocomplete', 'off');
                    ukuranInput.setAttribute('autocapitalize', 'none');
                    ukuranInput.setAttribute('spellcheck', 'false');
                    
                    // Use a flag to prevent multiple updates in quick succession
                    let isSelectingFromDatalist = false;
                    
                    // Debounce utility function
                    const debounce = (func, wait) => {
                        let timeout;
                        return function executedFunction(...args) {
                            const later = () => {
                                clearTimeout(timeout);
                                func.apply(this, args);
                            };
                            clearTimeout(timeout);
                            timeout = setTimeout(later, wait);
                        };
                    };
                    
                    // Helper function to update harga from selected ukuran
                    const updateHargaFromSelectedUkuran = function(inputElement, forceUpdate = false) {
                        updateHargaUkuranLogic(inputElement, forceUpdate);
                    };
                    
                    // Debounced update function
                    const debouncedUpdateHarga = debounce((input) => {
                        updateHargaFromSelectedUkuran(input, true);
                    }, 300);
                    
                    // Track when user selects from datalist
                    ukuranInput.addEventListener('change', function() {
                        isSelectingFromDatalist = true;
                        // Force update
                        updateHargaFromSelectedUkuran(this, true);
                        setTimeout(() => {
                            isSelectingFromDatalist = false;
                        }, 1000);
                    });
                    
                    // Listen to input event with debouncing
                    ukuranInput.addEventListener('input', function() {
                        debouncedUpdateHarga(this);
                    });
                    
                    // Listen to blur event
                    ukuranInput.addEventListener('blur', function() {
                        setTimeout(() => {
                            updateHargaFromSelectedUkuran(this, true);
                        }, 150);
                    });
                    
                    // Listen to keyup for Enter/Tab
                    ukuranInput.addEventListener('keyup', function(e) {
                        if (e.key === 'Enter' || e.key === 'Tab' || e.key === 'ArrowDown' || e.key === 'ArrowUp') {
                            setTimeout(() => {
                                updateHargaFromSelectedUkuran(this, true);
                            }, 100);
                        }
                    });
                    
                    // Always update datalist based on jenis kaca from the same row when focused
                    ukuranInput.addEventListener('focus', function() {
                        // Prevent update if user just selected from datalist
                        if (isSelectingFromDatalist) {
                            return;
                        }
                        
                        const row = this.closest('tr');
                        const jenisInput = row ? row.querySelector('input.jenis-kaca') : null;
                        const jenisValue = jenisInput ? jenisInput.value.trim() : '';
                        if (jenisValue) {
                            updateUkuranByJenisKaca(jenisValue, this);
                        } else {
                            updateKacaSuggestionsFromLogs();
                        }
                    });
                }
                
                // Update grand total setelah tambah baris
                setTimeout(() => {
                    updateGrandTotal();
                }, 100);
                
                // Trigger print data refresh if modal is open
                const printModal = document.getElementById('printModalOverlay');
                if (printModal && printModal.style.display === 'flex') {
                    setTimeout(() => {
                        if (typeof refreshPrintData === 'function') {
                            refreshPrintData();
                        }
                    }, 100);
                }
                
            } catch (error) {
                console.error('Error adding glass row:', error);
            }
        }

        // Fungsi untuk menghapus baris
        function removeKacaRow() {
            try {
                const tbody = document.getElementById('kacaTableBody');
                if (!tbody) {
                    console.error('kacaTableBody element not found');
                    return;
                }
                
                const rows = tbody.querySelectorAll('tr');
                
                if (rows.length > 1) {
                    const rowToRemove = rows[rows.length - 1];
                    
                    // Clean up any intervals or event listeners from the row being removed
                    // This prevents memory leaks
                    const ukuranInputs = rowToRemove.querySelectorAll('.ukuran');
                    ukuranInputs.forEach(input => {
                        // Clear any stored intervals (if polling was used)
                        if (input._pollingInterval) {
                            clearInterval(input._pollingInterval);
                            delete input._pollingInterval;
                        }
                        // Clear any debounce timeouts
                        if (input._debounceTimeout) {
                            clearTimeout(input._debounceTimeout);
                            delete input._debounceTimeout;
                        }
                    });
                    
                    tbody.removeChild(rowToRemove);
                    // Update grand total setelah hapus baris
                    setTimeout(() => {
                        updateGrandTotal();
                    }, 100);
                    
                    // Trigger print data refresh if modal is open
                    const printModal = document.getElementById('printModalOverlay');
                    if (printModal && printModal.style.display === 'flex') {
                        setTimeout(() => {
                            if (typeof refreshPrintData === 'function') {
                                refreshPrintData();
                            }
                        }, 100);
                    }
                } else {
                    alert('Minimal harus ada 1 baris!');
                }
            } catch (error) {
                console.error('Error removing glass row:', error);
            }
        }

        // Fungsi untuk menghitung total LBR
        // Debounced updateGrandTotal for better performance (global cache)
        if (!window._debouncedUpdateGrandTotal) {
            window._debouncedUpdateGrandTotal = (function() {
                let timeout;
                return function() {
                    clearTimeout(timeout);
                    timeout = setTimeout(() => {
                        updateGrandTotal();
                    }, 150);
                };
            })();
        }
        const debouncedUpdateGrandTotal = window._debouncedUpdateGrandTotal;
        
        // Cache printModal element for better performance (global cache)
        if (!window._getPrintModal) {
            let cachedPrintModal = null;
            window._getPrintModal = () => {
                if (!cachedPrintModal) {
                    cachedPrintModal = document.getElementById('printModalOverlay');
                }
                return cachedPrintModal;
            };
        }
        const getPrintModal = window._getPrintModal;
        
        function calculateTotalLbr(input) {
            try {
                if (!input) {
                    console.error('Input parameter is null or undefined');
                    return;
                }
                
                const row = input.closest('tr');
                if (!row) {
                    console.error('Row element not found');
                    return;
                }
                
                const boxInput = row.querySelector('input.box');
                const lbrInput = row.querySelector('input.lbr');
                const totalInput = row.querySelector('input.total-lbr-input');
                
                if (!boxInput || !lbrInput || !totalInput) {
                    console.error('Input elements not found:', { boxInput, lbrInput, totalInput });
                    return;
                }
                
                // Extract angka dari input BOX (misal: "2 BOX" -> 2)
                const boxValue = boxInput.value || '';
                const boxMatch = boxValue.trim().match(/^(\d+(?:\.\d+)?)/);
                const box = boxMatch ? parseFloat(boxMatch[1]) : 0;
                
                // Extract angka dari input LBR (misal: "100 LBR" -> 100)
                const lbrValue = lbrInput.value || '';
                const lbrMatch = lbrValue.trim().match(/^(\d+(?:\.\d+)?)/);
                const lbr = lbrMatch ? parseFloat(lbrMatch[1]) : 0;
                
                // Jika kolom BOX tidak diisi, maka TOTAL LBR = LBR
                // Jika kolom BOX diisi, maka TOTAL LBR = BOX * LBR
                const total = (box === 0 || !boxValue.trim()) ? lbr : box * lbr;
                
                // Format total dengan satuan LBR
                totalInput.value = Math.round(total) + " LBR";
                
                // Update grand total with debouncing for better performance
                debouncedUpdateGrandTotal();
                
                // Trigger print data refresh if modal is open (using cached element)
                const printModal = getPrintModal();
                if (printModal && printModal.style.display === 'flex') {
                    setTimeout(() => {
                        if (typeof refreshPrintData === 'function') {
                            refreshPrintData();
                        }
                    }, 100);
                }
            } catch (error) {
                console.error('Error calculating total LBR:', error);
            }
        }

        // Fungsi untuk menghitung total keseluruhan
        function calculateGrandTotal() {
            const totalInputs = document.querySelectorAll('input.total-lbr-input:not(.grand-total-input)');
            let grandTotal = 0;
            
            totalInputs.forEach(input => {
                // Extract angka dari format "100 LBR"
                const value = input.value;
                if (value && typeof value === 'string') {
                    const trimmedValue = value.trim();
                    const match = trimmedValue.match(/^(\d+(?:\.\d+)?)/);
                    const number = match ? parseFloat(match[1]) : 0;
                    grandTotal += number;
                }
            });
            
            return grandTotal;
        }

        // Fungsi untuk update grand total
        // Cache grandTotalInput for better performance (global cache)
        if (!window._getGrandTotalInput) {
            let cachedGrandTotalInput = null;
            window._getGrandTotalInput = () => {
                if (!cachedGrandTotalInput) {
                    cachedGrandTotalInput = document.querySelector('.grand-total-input');
                }
                return cachedGrandTotalInput;
            };
        }
        const getGrandTotalInput = window._getGrandTotalInput;
        
        function updateGrandTotal() {
            try {
                const grandTotal = calculateGrandTotal();
                const grandTotalInput = getGrandTotalInput();
                
                if (grandTotalInput) {
                    grandTotalInput.value = grandTotal + " LBR";
                } else {
                    console.warn('Grand total input element not found');
                }
                
                // Trigger print data refresh if modal is open (using cached element)
                const printModal = getPrintModal();
                if (printModal && printModal.style.display === 'flex') {
                    setTimeout(() => {
                        if (typeof refreshPrintData === 'function') {
                            refreshPrintData();
                        }
                    }, 100);
                }
            } catch (error) {
                console.error('Error updating grand total:', error);
            }
        }

        // Event listener untuk input changes
        document.addEventListener('input', function(e) {
            if (e.target.classList.contains('box') || e.target.classList.contains('lbr')) {
                calculateTotalLbr(e.target);
            }
        });

        // Event listener untuk blur (ketika input kehilangan focus)
        document.addEventListener('blur', function(e) {
            if (e.target.classList.contains('box')) {
                autoAddBoxUnit(e.target);
            } else if (e.target.classList.contains('lbr')) {
                autoAddLbrUnit(e.target);
            }
        }, true);

        // Event listener untuk keydown (ENTER key)
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                const target = e.target;
                
                // Auto-add unit jika user menekan ENTER pada input BOX atau LBR
                if (target.classList.contains('box')) {
                    autoAddBoxUnit(target);
                } else if (target.classList.contains('lbr')) {
                    autoAddLbrUnit(target);
                }
                
                // Navigasi form dengan ENTER - hanya untuk form surat jalan (tokoForm)
                // Cek apakah target berada di dalam form surat jalan
                const tokoForm = target.closest('#tokoForm');
                const stokForm = target.closest('#stokForm');
                
                // Skip jika target berada di form stok
                if (stokForm) {
                    return; // Let setupEnterKeyNavigation() handle it
                }
                
                // Hanya proses jika target berada di form surat jalan
                if (tokoForm) {
                    if (target.id === 'namaToko') {
                        e.preventDefault();
                        const tanggalInput = tokoForm.querySelector('#tanggal');
                        if (tanggalInput) tanggalInput.focus();
                    } else if (target.id === 'tanggal' && tokoForm.contains(target)) {
                        e.preventDefault();
                        const nomorSJInput = tokoForm.querySelector('#nomorSJ');
                        if (nomorSJInput) nomorSJInput.focus();
                    } else if (target.id === 'nomorSJ') {
                        e.preventDefault();
                        const supirInput = tokoForm.querySelector('#supir');
                        if (supirInput) supirInput.focus();
                    } else if (target.id === 'supir') {
                        e.preventDefault();
                        const noKendaraanInput = tokoForm.querySelector('#noKendaraan');
                        if (noKendaraanInput) noKendaraanInput.focus();
                    } else if (target.id === 'noKendaraan') {
                        e.preventDefault();
                        // Focus ke input Jenis Kaca di baris pertama
                        const firstJenisKacaInput = document.querySelector('input.jenis-kaca');
                        if (firstJenisKacaInput) {
                            firstJenisKacaInput.focus();
                            firstJenisKacaInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }
                    }
                }
                // Note: Form stok navigation is handled by setupEnterKeyNavigation() function
                // which is called separately and only handles fields in the stock form
                // This prevents conflicts between form surat jalan and form stok
                
                // Cek apakah input berada di tabel kaca
                if (target.closest('#kacaTable')) {
                    const currentRow = target.closest('tr');
                    const tbody = document.getElementById('kacaTableBody');
                    const rows = tbody.querySelectorAll('tr');
                    const isLastRow = currentRow === rows[rows.length - 1];
                    
                    // Navigasi antar kolom dalam tabel
                    if (target.classList.contains('jenis-kaca')) {
                        e.preventDefault();
                        const nextInput = currentRow.querySelector('input.pwd');
                        if (nextInput) nextInput.focus();
                    } else if (target.classList.contains('pwd')) {
                        e.preventDefault();
                        const nextInput = currentRow.querySelector('input.no-do');
                        if (nextInput) nextInput.focus();
                    } else if (target.classList.contains('no-do')) {
                        e.preventDefault();
                        const nextInput = currentRow.querySelector('input.ukuran');
                        if (nextInput) nextInput.focus();
                    } else if (target.classList.contains('ukuran')) {
                        e.preventDefault();
                        const nextInput = currentRow.querySelector('input.harga-jual');
                        if (nextInput) nextInput.focus();
                    } else if (target.classList.contains('harga-jual')) {
                        e.preventDefault();
                        const nextInput = currentRow.querySelector('input.box');
                        if (nextInput) nextInput.focus();
                    } else if (target.classList.contains('box')) {
                        e.preventDefault();
                        const nextInput = currentRow.querySelector('input.lbr');
                        if (nextInput) nextInput.focus();
                    } else if (target.classList.contains('lbr')) {
                        // Jika ini adalah baris terakhir dan semua field terisi
                        if (isLastRow && isRowComplete(currentRow)) {
                            e.preventDefault();
                            
                            // Visual feedback - highlight baris saat ini
                            currentRow.style.backgroundColor = '#e8f5e8';
                            setTimeout(() => {
                                currentRow.style.backgroundColor = '';
                            }, 300);
                            
                            addKacaRow();
                            
                            // Focus ke input Jenis Kaca di baris baru
                            setTimeout(() => {
                                const allRows = tbody.querySelectorAll('tr');
                                const newRow = allRows[allRows.length - 1]; // Ambil baris terakhir (yang baru)
                                const jenisKacaInput = newRow.querySelector('input.jenis-kaca');
                                
                                if (jenisKacaInput) {
                                    jenisKacaInput.focus();
                                    
                                    // Tambahan: scroll ke input jika perlu
                                    jenisKacaInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                } else {
                                    // Fallback: coba focus ke input pertama
                                    const firstInput = newRow.querySelector('input');
                                    if (firstInput) {
                                        firstInput.focus();
                                    }
                                }
                            }, 200);
                        } else {
                            // Jika bukan baris terakhir, pindah ke baris berikutnya
                            e.preventDefault();
                            const nextRow = currentRow.nextElementSibling;
                            if (nextRow) {
                                const nextJenisKacaInput = nextRow.querySelector('input.jenis-kaca');
                                if (nextJenisKacaInput) {
                                    nextJenisKacaInput.focus();
                                    nextJenisKacaInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                }
                            }
                        }
                    }
                }
            }
        });

        // Fungsi untuk mengecek apakah baris sudah terisi lengkap
        function isRowComplete(row) {
            const inputs = row.querySelectorAll('input:not([readonly])');
            let filledCount = 0;
            let totalInputs = 0;
            
            inputs.forEach(input => {
                totalInputs++;
                const value = input.value;
                if (value && typeof value === 'string' && value.trim() !== '') {
                    filledCount++;
                }
            });
            
            // Minimal 3 field harus terisi (jenis kaca, box, lbr)
            // Atau jika user menekan ENTER pada field terakhir yang terisi
            const currentInput = document.activeElement;
            const isLastInput = currentInput === row.querySelector('input:last-of-type');
            
            return filledCount >= 3 || (filledCount >= 2 && isLastInput);
        }

        // Fungsi untuk otomatis menambahkan satuan BOX
        function autoAddBoxUnit(input) {
            const value = input.value.trim();
            if (value && !value.toLowerCase().includes('box')) {
                // Cek apakah input hanya berisi angka
                const numberMatch = value.match(/^(\d+(?:\.\d+)?)$/);
                if (numberMatch) {
                    input.value = value + ' BOX';
                    // Trigger calculation after adding unit
                    calculateTotalLbr(input);
                }
            }
        }

        // Fungsi untuk otomatis menambahkan satuan LBR
        function autoAddLbrUnit(input) {
            const value = input.value.trim();
            if (value && !value.toLowerCase().includes('lbr')) {
                // Cek apakah input hanya berisi angka
                const numberMatch = value.match(/^(\d+(?:\.\d+)?)$/);
                if (numberMatch) {
                    input.value = value + ' LBR';
                    // Trigger calculation after adding unit
                    calculateTotalLbr(input);
                }
            }
        }

        // Fungsi untuk generate daftar toko di quick modal
        function generateQuickTokoList() {
            const quickTokoList = document.getElementById('quickTokoList');
            
            if (databaseTokoLengkap.length === 0) {
                quickTokoList.innerHTML = '<div class="no-results">Belum ada toko yang tersedia</div>';
                return;
            }
            
            let html = '';
            databaseTokoLengkap.forEach((toko, index) => {
                html += `
                    <div class="quick-toko-item" onclick="selectQuickToko('${toko.nama}', '${toko.alamat.replace(/\n/g, '\\n')}')">
                        <div class="quick-toko-name">🏪 ${toko.nama}</div>
                        <div class="quick-toko-address">📍 ${toko.alamat}</div>
                        <div class="quick-toko-actions">
                            <button type="button" class="btn-edit" onclick="event.stopPropagation(); editToko(${index})">✏️ Edit</button>
                            <button type="button" class="btn-delete" onclick="event.stopPropagation(); deleteToko(${index})">🗑️ Hapus</button>
                        </div>
                    </div>
                `;
            });
            
            quickTokoList.innerHTML = html;
        }

        // Export daftar toko (databaseTokoLengkap) ke JSON yang bisa diunduh
        function exportTokoListToJSON() {
            try {
                const data = Array.isArray(databaseTokoLengkap) ? databaseTokoLengkap : [];
                const dataStr = JSON.stringify(data, null, 2);
                const blob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const now = new Date();
                const ts = now.toISOString().slice(0,19).replace(/[:T]/g,'-');
                a.download = `daftar_toko_${ts}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } catch (error) {
                console.error('Gagal export daftar toko:', error);
                alert('Gagal export daftar toko.');
            }
        }

        // Import daftar toko dari file JSON
        async function handleImportTokoListFile(event) {
            try {
                const file = event.target.files && event.target.files[0];
                if (!file) return;
                const text = await file.text();
                let parsed;
                try {
                    parsed = JSON.parse(text);
                } catch (e) {
                    alert('File JSON tidak valid.');
                    return;
                }
                if (!Array.isArray(parsed)) {
                    alert('Format file tidak valid. Harus berupa array daftar toko.');
                    return;
                }
                // Validasi minimal field
                const sanitized = parsed.map(item => ({
                    nama: String((item && (item.nama ?? item.Nama ?? item.name)) || '').trim(),
                    alamat: String((item && (item.alamat ?? item.Alamat ?? item.address)) || '').trim()
                })).filter(it => it.nama && it.alamat);
                if (sanitized.length === 0) {
                    alert('File tidak berisi data toko yang valid.');
                    return;
                }
                // Gabungkan dengan data existing, hindari duplikat nama (case-insensitive)
                const existingByLower = new Map(
                    (Array.isArray(databaseTokoLengkap) ? databaseTokoLengkap : []).map(it => [String(it.nama || '').toLowerCase(), it])
                );
                sanitized.forEach(it => {
                    const key = it.nama.toLowerCase();
                    existingByLower.set(key, { nama: it.nama, alamat: it.alamat });
                });
                // Mutate the existing const array instead of reassigning
                const merged = Array.from(existingByLower.values());
                databaseTokoLengkap.splice(0, databaseTokoLengkap.length, ...merged);
                // Persist ke localStorage
                persistDatabaseTokoFromLengkap();
                persistDatabaseTokoLengkapArray();
                // Refresh UI jika tab daftar terbuka
                const quickModal = document.getElementById('quickAddModalOverlay');
                const quickListTab = document.getElementById('quickListTab');
                if (quickModal && quickModal.style.display === 'flex' && quickListTab && quickListTab.classList.contains('active')) {
                    generateQuickTokoList();
                }
                alert(`Import berhasil. Total toko: ${databaseTokoLengkap.length}`);
                // Reset input untuk bisa import ulang
                const input = document.getElementById('importTokoFileInput');
                if (input) input.value = '';
            } catch (error) {
                console.error('Gagal import daftar toko:', error);
                alert('Gagal import daftar toko. Pastikan file JSON valid.');
            }
        }

        // Fungsi untuk memilih toko dari quick list
        function selectQuickToko(namaToko, alamat) {
            const alamatField = document.getElementById('alamat');
            // Isi form utama
            document.getElementById('namaToko').value = namaToko;
            alamatField.value = alamat.replace(/\\n/g, '\n');
            alamatField.style.backgroundColor = '#f8f9fa';
            
            // Auto-resize textarea
            autoResizeTextarea(alamatField);
            
            // Tutup modal
            hideQuickAddModal();
            
            // Tampilkan feedback
            alert(`Form telah diisi dengan data ${namaToko}!`);
        }

        function getDisplayNameForKey(lowerKey) {
            try {
                const entry = Array.isArray(databaseTokoLengkap)
                    ? databaseTokoLengkap.find(t => (t.nama || '').toLowerCase() === String(lowerKey || ''))
                    : null;
                if (entry && entry.nama) return entry.nama;
            } catch (_) {}
            // Fallback: Title Case dari lowerKey
            return String(lowerKey || '').replace(/\b\w+/g, s => s.charAt(0).toUpperCase() + s.slice(1));
        }

        // Fungsi untuk menampilkan autocomplete
        function showAutocomplete(searchTerm) {
            const dropdown = document.getElementById('autocompleteDropdown');
            const matches = [];
            const map = getDatabaseToko();
            // Cari toko yang cocok berdasarkan nama ATAU alamat (case-insensitive)
            Object.keys(map).forEach(key => {
                const nameLower = key;
                const addressLower = String(map[key] || '').toLowerCase();
                if (nameLower.includes(searchTerm) || addressLower.includes(searchTerm)) {
                    matches.push({
                        namaKey: key,
                        displayName: getDisplayNameForKey(key),
                        alamat: map[key]
                    });
                }
            });
            
            // Generate HTML untuk dropdown
            if (matches.length > 0) {
                let html = '';
                matches.forEach((toko, index) => {
                    html += `
                        <div class="autocomplete-item" data-index="${index}" onclick="selectToko('${toko.displayName.replace(/'/g, "&#39;")}', '${toko.alamat.replace(/\n/g, '\\n').replace(/'/g, "&#39;")}')">
                            <div class="autocomplete-item-icon">🏪</div>
                            <div class="autocomplete-item-text">
                                <div class="autocomplete-item-name">${toko.displayName}</div>
                                <div class="autocomplete-item-address">${toko.alamat.split('\n')[0]}...</div>
                            </div>
                        </div>
                    `;
                });
                dropdown.innerHTML = html;
                dropdown.style.display = 'block';
            } else {
                dropdown.innerHTML = '<div class="no-results">Tidak ada toko yang cocok</div>';
                dropdown.style.display = 'block';
            }
        }

        // Fungsi untuk menyembunyikan autocomplete
        function hideAutocomplete() {
            const dropdown = document.getElementById('autocompleteDropdown');
            dropdown.style.display = 'none';
        }

        // Fungsi untuk memilih toko dari autocomplete
        function selectToko(namaToko, alamat) {
            const alamatField = document.getElementById('alamat');
            document.getElementById('namaToko').value = namaToko;
            alamatField.value = alamat.replace(/\\n/g, '\n');
            alamatField.style.backgroundColor = '#f8f9fa';
            // Auto-resize textarea
            autoResizeTextarea(alamatField);
            hideAutocomplete();
        }

        // Sembunyikan autocomplete saat klik di luar
        document.addEventListener('click', function(e) {
            const autocompleteContainer = document.querySelector('.autocomplete-container');
            if (!autocompleteContainer.contains(e.target)) {
                hideAutocomplete();
            }
        });

        // Keyboard navigation untuk autocomplete
        document.getElementById('namaToko').addEventListener('keydown', function(e) {
            const dropdown = document.getElementById('autocompleteDropdown');
            const items = dropdown.querySelectorAll('.autocomplete-item');
            const selectedItem = dropdown.querySelector('.autocomplete-item.selected');
            
            if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (selectedItem) {
                    selectedItem.classList.remove('selected');
                    const nextItem = selectedItem.nextElementSibling;
                    if (nextItem && nextItem.classList.contains('autocomplete-item')) {
                        nextItem.classList.add('selected');
                    } else {
                        items[0]?.classList.add('selected');
                    }
                } else {
                    items[0]?.classList.add('selected');
                }
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (selectedItem) {
                    selectedItem.classList.remove('selected');
                    const prevItem = selectedItem.previousElementSibling;
                    if (prevItem && prevItem.classList.contains('autocomplete-item')) {
                        prevItem.classList.add('selected');
                    } else {
                        items[items.length - 1]?.classList.add('selected');
                    }
                } else {
                    items[items.length - 1]?.classList.add('selected');
                }
            } else if (e.key === 'Enter' && selectedItem) {
                e.preventDefault();
                selectedItem.click();
            } else if (e.key === 'Escape') {
                hideAutocomplete();
            }
        });

        // Fungsi untuk toggle hide/unhide tombol
        function toggleButtons() {
            const mainActionsContainer = document.getElementById('mainActionsContainer');
            const toggleBtn = document.querySelector('.toggle-buttons-btn');
            const isHidden = mainActionsContainer.classList.contains('hidden');
            
            if (isHidden) {
                // Tampilkan tombol
                mainActionsContainer.classList.remove('hidden');
                toggleBtn.innerHTML = '🔽 Sembunyikan Tombol';
                toggleBtn.style.background = 'linear-gradient(135deg, #6f42c1 0%, #5a32a3 100%)';
            } else {
                // Sembunyikan tombol
                mainActionsContainer.classList.add('hidden');
                toggleBtn.innerHTML = '🔼 Tampilkan Tombol';
                toggleBtn.style.background = 'linear-gradient(135deg, #28a745 0%, #20c997 100%)';
            }
        }

        // Set state awal - tombol tersembunyi
        window.addEventListener('load', function() {
            try {
                // Tombol tersembunyi secara default
                const mainActionsContainer = document.getElementById('mainActionsContainer');
                const toggleBtn = document.querySelector('.toggle-buttons-btn');
                
                if (mainActionsContainer && toggleBtn) {
                    mainActionsContainer.classList.add('hidden');
                    toggleBtn.innerHTML = '🔼 Tampilkan Tombol';
                    toggleBtn.style.background = 'linear-gradient(135deg, #28a745 0%, #20c997 100%)';
                }
                
                // Tambahkan 1 baris default jika belum ada
                setTimeout(() => {
                    const tbody = document.getElementById('kacaTableBody');
                    if (tbody && tbody.children.length === 0) {
                        addKacaRow();
                    }
                }, 200);
                
            } catch (error) {
                console.error('Error during page initialization:', error);
            }
        });

        // Backup initialization untuk memastikan glass data ter-load
        document.addEventListener('DOMContentLoaded', function() {
            try {
                // Cek apakah glass data sudah ada, jika belum, tambahkan 1 baris default
                setTimeout(() => {
                    const kacaTableBody = document.getElementById('kacaTableBody');
                    if (kacaTableBody && kacaTableBody.children.length === 0) {
                        console.log('Glass data not found, adding one default row...');
                        addKacaRow();
                    }
                }, 500);
            } catch (error) {
                console.error('Error during DOMContentLoaded:', error);
            }
        });

        // Debug function untuk testing glass data
        // Removed debugGlassData (not used anymore)

        // Print Modal Functions
        function adjustLayoutForSinglePage() {
            const container = document.querySelector('.print-textarea-container');
            const textElements = container.querySelectorAll('.draggable-text-item');
            
            if (textElements.length === 0) return;
            
            // F4 dimensions in pixels (matching container dimensions)
            const a4Width = 813;
            const a4Height = 1247;
            const margin = 0; // 20px margin on each side
            
            // Calculate available space
            const maxWidth = a4Width - (margin * 2);
            const maxHeight = a4Height - (margin * 2);
            
            // Check if elements need adjustment (only if they're outside bounds or too close together)
            let needsAdjustment = false;
            let previousY = -1;
            
            textElements.forEach((element, index) => {
                const currentX = parseInt(element.style.left) || 20;
                const currentY = parseInt(element.style.top) || 20;
                
                // Check if element is outside F4 bounds
                if (currentX < margin || currentX > maxWidth || currentY < margin || currentY > maxHeight) {
                    needsAdjustment = true;
                }
                
                // Check if elements are too close together (less than 30px spacing)
                if (previousY !== -1 && Math.abs(currentY - previousY) < 30) {
                    needsAdjustment = true;
                }
                
                previousY = currentY;
            });
            
            // Never auto-rearrange user positions; only log the state
            console.log('No layout auto-adjustment applied; preserving user positions');
        }

        // Add event listeners for real-time column spacing updates
        function addColumnSpacingEventListeners() {
            const columnInputs = [
                'colJenisKaca', 'colPwd', 'colNoDo', 'colUkuran', 'colBox', 'colLbr', 'colTotalLbr'
            ];
            
            columnInputs.forEach(inputId => {
                const input = document.getElementById(inputId);
                if (input) {
                    // Remove existing listeners to prevent duplicates
                    input.removeEventListener('input', updateColumnSpacing);
                    input.removeEventListener('change', updateColumnSpacing);
                    
                    // Add new listeners for real-time updates
                    input.addEventListener('input', debounce(updateColumnSpacing, 300));
                    input.addEventListener('change', updateColumnSpacing);
                }
            });
        }

        // Debounce function to prevent too many updates
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Update the showPrintModal function to add event listeners
        function showPrintModal() {
            const modal = document.getElementById('printModalOverlay');
            modal.style.display = 'flex';
            document.body.style.overflow = 'hidden';
            
            // Load font size preference
            loadFontSizePreference();
            loadFontWeightPreference();
            loadFontFamilyPreference();
            
            // Load column spacing preference
            loadColumnSpacingFromStorage();
            
            // Generate print data
            refreshPrintData();
            
            // Add event listeners for column spacing
            setTimeout(() => {
                addColumnSpacingEventListeners();
            }, 100);
            
            // Smart position handling: never auto-adjust; keep user positions as-is
            setTimeout(() => {
                if (Object.keys(savedPositions).length > 0) {
                    preserveUserPositions();
                }
                initDragAndDropForElements();
            }, 100);
            
            // Restore lock button state
            const lockBtn = document.querySelector('.btn-lock-position');
            if (lockBtn) {
                if (positionsLocked) {
                    lockBtn.textContent = '🔓 Unlock Posisi';
                    lockBtn.classList.add('locked');
                } else {
                    lockBtn.textContent = '🔒 Lock Posisi';
                    lockBtn.classList.remove('locked');
                }
            }
        }

        function hidePrintModal() {
            const modal = document.getElementById('printModalOverlay');
            modal.style.display = 'none';
            document.body.style.overflow = 'auto';
        }

        function refreshPrintData() {
            // Use the clean version that doesn't include headers
            refreshPrintDataClean();
        }

        function validateAndAdjustForSinglePage() {
            const container = document.querySelector('.print-textarea-container');
            const textElements = container.querySelectorAll('.draggable-text-item');
            
            if (textElements.length === 0) return;
            
            // F4 dimensions in pixels (matching container dimensions)
            const a4Width = 813;
            const a4Height = 1247;
            const margin = 0;
            
            let needsAdjustment = false;
            let previousY = -1;
            
            // Check if any element is beyond F4 boundaries or too close together
            textElements.forEach(element => {
                const x = parseInt(element.style.left) || 0;
                const y = parseInt(element.style.top) || 0;
                
                // Check if element is outside F4 bounds
                if (x < margin || x > (a4Width - margin) || y < margin || y > (a4Height - margin)) {
                    needsAdjustment = true;
                }
                
                // Check if elements are too close together (less than 40px spacing)
                if (previousY !== -1 && Math.abs(y - previousY) < 40) {
                    needsAdjustment = true;
                }
                
                previousY = y;
            });
            
            // If adjustment is needed, apply single page layout
            // Do not auto-adjust; trust user-defined positions
            console.log('Validation step skipped auto-adjustments; preserving user positions');
        }

        function debugPositions() {
            const container = document.querySelector('.print-textarea-container');
            const textElements = container.querySelectorAll('.draggable-text-item');
            
            console.log('=== Position Debug ===');
            console.log('Container dimensions:', {
                width: container.offsetWidth,
                height: container.offsetHeight,
                scrollLeft: container.scrollLeft,
                scrollTop: container.scrollTop
            });
            
            textElements.forEach((element, index) => {
                const x = parseInt(element.style.left) || 0;
                const y = parseInt(element.style.top) || 0;
                const text = element.querySelector('.text-content')?.textContent || '';
                
                console.log(`Element ${index}:`, {
                    text: text.substring(0, 30) + '...',
                    x: x,
                    y: y,
                    computedLeft: element.style.left,
                    computedTop: element.style.top
                });
            });
        }

        function showPositionOverlay() {
            const container = document.querySelector('.print-textarea-container');
            const textElements = container.querySelectorAll('.draggable-text-item');
            
            // Remove existing overlay
            const existingOverlay = document.querySelector('.position-overlay');
            if (existingOverlay) {
                existingOverlay.remove();
            }
            
            // Create overlay
            const overlay = document.createElement('div');
            overlay.className = 'position-overlay';
            overlay.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(255, 255, 0, 0.1);
                pointer-events: none;
                z-index: 9999;
            `;
            
            textElements.forEach((element, index) => {
                const x = parseInt(element.style.left) || 0;
                const y = parseInt(element.style.top) || 0;
                
                const marker = document.createElement('div');
                marker.style.cssText = `
                    position: absolute;
                    left: ${x}px;
                    top: ${y}px;
                    width: 10px;
                    height: 10px;
                    background: red;
                    border-radius: 50%;
                    z-index: 10000;
                `;
                marker.title = `Element ${index}: x=${x}, y=${y}`;
                overlay.appendChild(marker);
            });
            
            container.appendChild(overlay);
            
            // Remove overlay after 3 seconds
            setTimeout(() => {
                if (overlay.parentNode) {
                    overlay.remove();
                }
            }, 3000);
        }

        function printNow() {
            const container = document.querySelector('.print-textarea-container');
            const textElements = container.querySelectorAll('.draggable-text-item');
            
            if (textElements.length === 0) {
                alert('Tidak ada konten untuk dicetak!');
                return;
            }
            
            // Show position overlay for debugging
            showPositionOverlay();
            
            // Capture positions BEFORE any adjustments
            let positionedTexts = [];
            textElements.forEach(element => {
                const textContent = element.querySelector('.text-content');
                if (textContent && textContent.textContent.trim()) {
                    // Get exact pixel positions from the drag area
                    const x = parseInt(element.style.left) || 0;
                    const y = parseInt(element.style.top) || 0;
                    const type = element.dataset.type || 'data';
                    // Capture both raw text and the exact HTML preview for kaca-data
                    const text = (type === 'kaca-data')
                        ? (element.dataset.rawText || textContent.textContent)
                        : textContent.textContent;
                    const html = (type === 'kaca-data') ? textContent.innerHTML : null;
                    
                    positionedTexts.push({ x, y, text, type, html });
                }
            });
            
            // Debug positions before printing
            debugPositions();
            
            // Create a new window for printing with positioned layout
            const printWindow = window.open('', '_blank');
            
            // Sort by Y position first, then X position for consistent layout
            positionedTexts.sort((a, b) => {
                if (a.y !== b.y) return a.y - b.y;
                return a.x - b.x;
            });
            
            // Create HTML with positioned text elements using exact positions
            let positionedHTML = '';
            positionedTexts.forEach((item, index) => {
                // Clamp to F4 canvas to prevent overflow triggering blank extra page
                const pageWidth = 813;
                const pageHeight = 1247;
                const approxTextHeight = Math.max(currentFontSize, 10) + 8; // include ~8px vertical padding
                const safeX = Math.max(0, Math.min(item.x, pageWidth - 1));
                const safeY = Math.max(0, Math.min(item.y, pageHeight - approxTextHeight));
                const style = `position: absolute; left: ${safeX}px; top: ${safeY}px;`;
                let className = 'print-text-item';
                
                // Add styling based on type
                if (item.type === 'header') {
                    className += ' print-header';
                } else if (item.type === 'total') {
                    className += ' print-total';
                } else if (item.type === 'kaca-data') {
                    className += ' print-kaca-data';
                } else if (item.type === 'timestamp') {
                    className += ' print-timestamp';
                }
                
                if (item.type === 'kaca-data') {
                    // Use the exact preview HTML for perfect column alignment; fallback to rebuild
                    const kdHTML = item.html || buildKacaDataFixedColumnsHTML(item.text, currentFontFamily, currentFontSize);
                    positionedHTML += `<div class="${className}" style="${style}">${kdHTML}</div>`;
                } else {
                    positionedHTML += `<div class="${className}" style="${style}">${item.text}</div>`;
                }
                
                // Debug: Log the exact position being used
                console.log(`Print element ${index}:`, {
                    text: item.text.substring(0, 30) + '...',
                    x: safeX,
                    y: safeY,
                    style: style
                });
            });
            
            printWindow.document.write(`
                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="UTF-8">
                    <link rel="preconnect" href="https://fonts.googleapis.com">
                    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
                    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@300;400;500;600;700&display=swap" rel="stylesheet">
                    <style>
                        @page {
                            size: 215mm 330mm; /* F4 */
                            margin: 0;
                        }
                        html, body {
                            margin: 0;
                            padding: 0;
                            font-family: ${currentFontFamily};
                            font-size: ${currentFontSize}px;
                            font-weight: ${currentFontWeight};
                            line-height: 1.2;
                            background: white;
                            overflow: hidden;
                        }
                        html, body, * { box-sizing: border-box; }
                        .page {
                            position: fixed;
                            top: 0;
                            left: 0;
                            width: 212mm;   /* more conservative to avoid overflow */
                            height: 327mm;  /* more conservative to avoid overflow */
                            overflow: clip;
                            background: white;
                            margin: 0;
                            padding: 0;
                        }
                        .print-text-item { box-sizing: border-box; }
                        .print-text-item {
                            position: absolute;
                            background: transparent;
                            padding: 4px 8px;
                            border: none;
                            white-space: pre-wrap;
                            max-width: none;
                            font-family: ${currentFontFamily};
                            font-size: ${currentFontSize}px;
                            font-weight: ${currentFontWeight};
                        }
                        .print-header {
                            font-weight: 700;
                        }
                        .print-total {
                            font-weight: 700;
                            color: #000 !important; /* force black for TOTAL */
                            font-size: ${currentFontSize}px;
                        }
                        /* Mirror preview's fixed-columns layout exactly in print */
                        .print-kaca-data { font-size: ${Math.max(currentFontSize - 2, 8)}px; max-width: 600px; width: auto; }
                        .kd-block { display: block; }
                        .kd-row { white-space: nowrap; line-height: 1.2; }
                        .kd-cell { display:inline-block; font-family: 'Roboto Mono', 'Courier New', monospace; white-space: nowrap; overflow: hidden; text-overflow: clip; vertical-align: top; }
                        .kd-cell.left{ text-align:left; } .kd-cell.center{ text-align:center; } .kd-cell.right{ text-align:right; }
                        .kd-text{ display:inline; font-family:${currentFontFamily}; font-size:${currentFontSize}px; }
                        .print-timestamp {
                            font-weight: ${currentFontWeight};
                        }
        .print-timestamp {
            font-weight: ${currentFontWeight};
        }
                        @media print {
                            @page {
                                size: 215mm 330mm; /* F4 */
                                margin: 0;
                            }
                            html, body { 
                                margin: 0; 
                                padding: 0;
                                overflow: hidden;
                                font-size: ${currentFontSize}px;
                                font-weight: ${currentFontWeight};
                                font-family: ${currentFontFamily};
                            }
                            .page {
                                width: 212mm;
                                height: 327mm;
                                position: fixed;
                                top: 0;
                                left: 0;
                                overflow: clip;
                                margin: 0;
                                padding: 0;
                            }
                            .print-text-item {
                                page-break-inside: avoid;
                                page-break-before: avoid;
                                page-break-after: avoid;
                                font-family: ${currentFontFamily};
                                font-size: ${currentFontSize}px;
                                font-weight: ${currentFontWeight};
                                /* Ensure no overflow from padding during print */
                                padding: 0;
                                max-width: 212mm;
                            }
                            .print-kaca-data { max-width: 600px !important; width: auto !important; }
                            * {
                                page-break-inside: avoid;
                                page-break-after: avoid;
                                page-break-before: avoid;
                            }
                            /* Hide browser headers and footers */
                            html, body {
                                -webkit-print-color-adjust: exact;
                                print-color-adjust: exact;
                            }
                            /* Force single page */
                            html {
                                height: 100%;
                                overflow: hidden;
                            }
                        }
                    </style>
                </head>
                <body>
                    <div class="page">${positionedHTML}</div>
                </body>
                </html>
            `);
            
            printWindow.document.close();
            
            // Wait for content and web fonts to load before printing
            printWindow.onload = function() {
                try {
                    const timeoutMs = 1500;
                    let timedOut = false;
                    const timeoutId = setTimeout(() => { timedOut = true; printWindow.print(); printWindow.close(); }, timeoutMs);
                    const ready = (printWindow.document.fonts && printWindow.document.fonts.ready) ? printWindow.document.fonts.ready : Promise.resolve();
                    ready.then(() => {
                        if (!timedOut) {
                            clearTimeout(timeoutId);
                            // Slight delay ensures layout with loaded fonts
                            setTimeout(() => { printWindow.print(); printWindow.close(); }, 50);
                        }
                    }).catch(() => {
                        // Fallback if fonts API fails
                        if (!timedOut) {
                            clearTimeout(timeoutId);
                            printWindow.print();
                            printWindow.close();
                        }
                    });
                } catch (_) {
                    // Last resort
                    printWindow.print();
                    printWindow.close();
                }
            };
        }

        // Close print modal when clicking outside
        document.getElementById('printModalOverlay').addEventListener('click', function(e) {
            if (e.target === this) {
                hidePrintModal();
            }
        });

        // Drag functionality for print text content
        let isDragging = false;
        let dragOffsetX = 0;
        let dragOffsetY = 0;
        let currentDraggedElement = null;
        let selectedElement = null;
        let gridEnabled = false; // free movement (no grid)
        let gridSize = 1; // 1px step for arrow keys
        let positionsLocked = false;
        let savedPositions = {};
        let dragStartTime = 0;
        let dragDistance = 0;
        let currentFontSize = 10; // Default font size for print
        let currentFontWeight = 400; // Default font weight (Normal)
        let currentFontFamily = "'Roboto Mono', 'Courier New', monospace"; // Default font family
        let currentColumnSpacing = 12; // Default column spacing for kaca-data
        
        // Individual column spacing configuration
        let columnSpacingConfig = {
            jenisKaca: 15,
            pwd: 8,
            noDo: 12,
            ukuran: 12,
            box: 10,
            lbr: 10,
            totalLbr: 12
        };
        
        // Preset configurations
        const spacingPresets = {
            compact: {
                jenisKaca: 12,
                pwd: 6,
                noDo: 8,
                ukuran: 8,
                box: 6,
                lbr: 6,
                totalLbr: 8
            },
            normal: {
                jenisKaca: 15,
                pwd: 8,
                noDo: 12,
                ukuran: 12,
                box: 10,
                lbr: 10,
                totalLbr: 12
            },
            wide: {
                jenisKaca: 20,
                pwd: 12,
                noDo: 16,
                ukuran: 16,
                box: 14,
                lbr: 14,
                totalLbr: 16
            },
            custom: {
                jenisKaca: 18,
                pwd: 10,
                noDo: 14,
                ukuran: 14,
                box: 12,
                lbr: 12,
                totalLbr: 14
            }
        };
        
        // Load saved positions from storage on page load
        function loadSavedPositions() {
            try {
                const saved = storageManager.load('printTextPositions');
                if (saved) {
                    savedPositions = saved;
                } else {
                }
            } catch (error) {
                console.error('❌ Error loading saved positions:', error);
                savedPositions = {};
            }
        }
        
        // Save positions to storage
        function savePositionsToStorage() {
            try {
                storageManager.save('printTextPositions', savedPositions);
                console.log('💾 Positions saved to storage:', savedPositions);
            } catch (error) {
                console.error('❌ Error saving positions:', error);
            }
        }

        // Save current positions explicitly (triggered by button)
        function saveCurrentPositions() {
            try {
                const container = document.querySelector('.print-textarea-container');
                if (!container) return;
                const textElements = container.querySelectorAll('.draggable-text-item');
                const latest = {};
                textElements.forEach(el => {
                    const index = parseInt(el.dataset.index);
                    const x = Math.round(parseFloat(el.style.left) || 0);
                    const y = Math.round(parseFloat(el.style.top) || 0);
                    if (!isNaN(index)) {
                        latest[index] = { x, y };
                    }
                });
                savedPositions = latest;
                savePositionsToStorage();
                alert('Posisi saat ini telah disimpan.');
            } catch (error) {
                console.error('Error saving current positions:', error);
                alert('Gagal menyimpan posisi: ' + error.message);
            }
        }

        // Export positions to downloadable JSON file
        function exportPositionsToJSON() {
            try {
                const dataStr = JSON.stringify(savedPositions, null, 2);
                const blob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                const dateStr = new Date().toISOString().replace(/[:.]/g, '-');
                a.href = url;
                a.download = `print-positions-${dateStr}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } catch (error) {
                console.error('Error exporting positions:', error);
                alert('Gagal export posisi: ' + error.message);
            }
        }

        // Handle import positions JSON file
        async function handleImportPositionsFile(event) {
            try {
                const file = event.target.files && event.target.files[0];
                if (!file) return;
                const text = await file.text();
                const json = JSON.parse(text);
                if (!json || typeof json !== 'object') throw new Error('Format file tidak valid');
                // Basic validation of structure: values should be {x, y}
                const validated = {};
                Object.keys(json).forEach(key => {
                    const val = json[key];
                    if (val && typeof val.x === 'number' && typeof val.y === 'number') {
                        validated[key] = { x: Math.round(val.x), y: Math.round(val.y) };
                    }
                });
                savedPositions = validated;
                savePositionsToStorage();

                // Apply to DOM immediately if elements exist
                const container = document.querySelector('.print-textarea-container');
                if (container) {
                    const elements = container.querySelectorAll('.draggable-text-item');
                    elements.forEach(el => {
                        const index = parseInt(el.dataset.index);
                        const pos = savedPositions[index];
                        if (pos) {
                            el.style.left = pos.x + 'px';
                            el.style.top = pos.y + 'px';
                        }
                    });
                }
                alert('Posisi berhasil diimport dan diterapkan.');
                // Reset input for re-import
                const input = document.getElementById('importPositionsFileInput');
                if (input) input.value = '';
            } catch (error) {
                console.error('Error importing positions:', error);
                alert('Gagal import posisi: ' + error.message);
            }
        }
        
        // Load positions when page loads
        document.addEventListener('DOMContentLoaded', function() {
            loadSavedPositions();
            loadFontSizePreference();
            loadColumnSpacingFromStorage();
        });
        
        // Function to clear saved positions
        function clearSavedPositions() {
            try {
                // Try to remove from localStorage first
                try { localStorage.removeItem('printTextPositions'); } catch (_) {}
                // Try to remove from sessionStorage
                try { sessionStorage.removeItem('printTextPositions'); } catch (_) {}
                // Clear from memory fallback
                if (storageManager.fallbackData['printTextPositions']) {
                    delete storageManager.fallbackData['printTextPositions'];
                }
                savedPositions = {};
                console.log('Saved positions cleared');
                alert('Posisi tersimpan telah dihapus! Posisi akan kembali ke default saat modal dibuka kembali.');
            } catch (error) {
                console.error('Error clearing saved positions:', error);
            }
        }

        function snapToGrid(x, y) {
            if (!gridEnabled) return { x: Math.round(x), y: Math.round(y) };
            
            const snappedX = Math.round(x / gridSize) * gridSize;
            const snappedY = Math.round(y / gridSize) * gridSize;
            
            // Add haptic feedback if supported
            if (navigator.vibrate && Math.abs(x - snappedX) < 2 && Math.abs(y - snappedY) < 2) {
                navigator.vibrate(10);
            }
            
            return { x: Math.round(snappedX), y: Math.round(snappedY) };
        }

        function selectElement(element) {
            // Remove selection from previously selected element
            if (selectedElement) {
                selectedElement.classList.remove('selected');
            }
            
            // Select new element
            selectedElement = element;
            if (element) {
                element.classList.add('selected');
                element.focus();
                
                // Add haptic feedback for selection
                if (navigator.vibrate) {
                    navigator.vibrate(20);
                }
                
                // Scroll element into view if needed
                element.scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'nearest',
                    inline: 'nearest'
                });
            }
        }

        function moveSelectedElement(direction) {
            if (!selectedElement) return;
            
            const currentX = parseInt(selectedElement.style.left) || 0;
            const currentY = parseInt(selectedElement.style.top) || 0;
            let newX = currentX;
            let newY = currentY;
            
            switch (direction) {
                case 'up':
                    newY = currentY - gridSize;
                    break;
                case 'down':
                    newY = currentY + gridSize;
                    break;
                case 'left':
                    newX = currentX - gridSize;
                    break;
                case 'right':
                    newX = currentX + gridSize;
                    break;
            }
            
            // Constrain to container boundaries with full page range
            const container = selectedElement.closest('.print-textarea-container');
            
            // Use F4 dimensions for boundary calculation
            const containerWidth = 813;  // F4 width in pixels
            const containerHeight = 1247; // F4 height in pixels
            
            const maxX = containerWidth - selectedElement.offsetWidth;
            const maxY = containerHeight - selectedElement.offsetHeight;
            
            // Allow movement across the full page
            newX = Math.max(0, Math.min(newX, maxX));
            newY = Math.max(0, Math.min(newY, maxY));
            
            // Snap to grid within container only
            const snapped = snapToGrid(newX, newY);
            selectedElement.style.left = snapped.x + 'px';
            selectedElement.style.top = snapped.y + 'px';
            
            // Save position to localStorage
            const index = parseInt(selectedElement.dataset.index);
            if (!isNaN(index)) {
                savedPositions[index] = { x: Math.round(snapped.x), y: Math.round(snapped.y) };
                savePositionsToStorage();
            }
        }

        function initDragAndDropForElements() {
            const container = document.querySelector('.print-textarea-container');
            
            if (!container) return;
            
            // Remove existing event listeners
            const existingElements = container.querySelectorAll('.draggable-text-item');
            existingElements.forEach(element => {
                element.removeEventListener('mousedown', handleMouseDown);
                element.removeEventListener('click', handleElementClick);
                element.removeEventListener('touchstart', handleTouchStart);
            });
            
            // Add event listeners to all draggable text elements
            const textElements = container.querySelectorAll('.draggable-text-item');
            textElements.forEach(element => {
                element.addEventListener('mousedown', handleMouseDown);
                element.addEventListener('click', handleElementClick);
                element.addEventListener('touchstart', handleTouchStart, { passive: false });
            });
        }

        function handleTouchStart(e) {
            if (positionsLocked) return;
            const touch = e.touches[0];
            const element = e.target && e.target.closest ? e.target.closest('.draggable-text-item') : null;
            if (!element) return;
            
            e.preventDefault();
            
            isDragging = true;
            currentDraggedElement = element;
            dragStartTime = Date.now();
            dragDistance = 0;
            
            currentDraggedElement.classList.add('dragging');
            selectElement(currentDraggedElement);
            
            const rect = currentDraggedElement.getBoundingClientRect();
            const containerRect = currentDraggedElement.closest('.print-textarea-container').getBoundingClientRect();
            
            dragOffsetX = touch.clientX - rect.left;
            dragOffsetY = touch.clientY - rect.top;
            
            document.addEventListener('touchmove', handleTouchMove, { passive: false });
            document.addEventListener('touchend', handleMouseUp);
        }

        function handleElementClick(e) {
            // Select element on click (but not during drag)
            if (!isDragging && !positionsLocked) {
                const el = e.target && e.target.closest ? e.target.closest('.draggable-text-item') : null;
                if (el) selectElement(el);
            }
        }

        function handleMouseDown(e) {
            if (e.button === 0 && !positionsLocked) { // Left mouse button only and not locked
                const el = e.target && e.target.closest ? e.target.closest('.draggable-text-item') : null;
                if (!el) return;
                isDragging = true;
                currentDraggedElement = el;
                dragStartTime = Date.now();
                dragDistance = 0;
                
                // Add dragging class for visual feedback
                currentDraggedElement.classList.add('dragging');
                
                // Select the element being dragged
                selectElement(currentDraggedElement);
                
                const rect = currentDraggedElement.getBoundingClientRect();
                const containerRect = currentDraggedElement.closest('.print-textarea-container').getBoundingClientRect();
                
                // Compute offset relative to element top-left to avoid initial jump
                dragOffsetX = e.clientX - rect.left;
                dragOffsetY = e.clientY - rect.top;
                
                // Disable transitions during drag to prevent visual jump/glitch
                currentDraggedElement.style.transition = 'none';
                
                // Prevent text selection during drag
                e.preventDefault();
                
                // Add global event listeners
                document.addEventListener('mousemove', handleMouseMove, { passive: false });
                document.addEventListener('mouseup', handleMouseUp);
                document.addEventListener('touchmove', handleTouchMove, { passive: false });
                document.addEventListener('touchend', handleMouseUp);
            }
        }
        
        function handleMouseMove(e) {
            if (!isDragging || !currentDraggedElement) return;
            
            e.preventDefault();
            
            // Use requestAnimationFrame for smooth performance
            requestAnimationFrame(() => {
                const container = currentDraggedElement.closest('.print-textarea-container');
                const containerRect = container.getBoundingClientRect();
                // Account for scroll so positions map to full F4 canvas
                const newX = e.clientX - containerRect.left + container.scrollLeft - dragOffsetX;
                const newY = e.clientY - containerRect.top + container.scrollTop - dragOffsetY;
                
                // Calculate drag distance for click detection
                const deltaX = e.clientX - (containerRect.left + dragOffsetX);
                const deltaY = e.clientY - (containerRect.top + dragOffsetY);
                dragDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                
                // Constrain to full F4 canvas boundaries
                const maxX = container.scrollWidth - currentDraggedElement.offsetWidth;
                const maxY = container.scrollHeight - currentDraggedElement.offsetHeight;
                
                const constrainedX = Math.max(0, Math.min(newX, maxX));
                const constrainedY = Math.max(0, Math.min(newY, maxY));
                
                // Snap to grid
                const snapped = snapToGrid(constrainedX, constrainedY);
                
                // Apply position with smooth transition
                currentDraggedElement.style.transition = 'none';
                currentDraggedElement.style.left = snapped.x + 'px';
                currentDraggedElement.style.top = snapped.y + 'px';
            });
        }
        
        function handleTouchMove(e) {
            if (!isDragging || !currentDraggedElement) return;
            
            e.preventDefault();
            const touch = e.touches[0];
            const container = currentDraggedElement.closest('.print-textarea-container');
            const containerRect = container.getBoundingClientRect();
            
            // Directly compute new position for touch; include scroll offsets
            const newX = touch.clientX - containerRect.left + container.scrollLeft - dragOffsetX;
            const newY = touch.clientY - containerRect.top + container.scrollTop - dragOffsetY;
            
            // Calculate drag distance for click detection
            const deltaX = touch.clientX - (containerRect.left + dragOffsetX);
            const deltaY = touch.clientY - (containerRect.top + dragOffsetY);
            dragDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            const maxX = container.scrollWidth - currentDraggedElement.offsetWidth;
            const maxY = container.scrollHeight - currentDraggedElement.offsetHeight;
            const constrainedX = Math.max(0, Math.min(newX, maxX));
            const constrainedY = Math.max(0, Math.min(newY, maxY));
            const snapped = snapToGrid(constrainedX, constrainedY);
            
            currentDraggedElement.style.left = snapped.x + 'px';
            currentDraggedElement.style.top = snapped.y + 'px';
        }
        
        function handleMouseUp() {
            if (isDragging && currentDraggedElement) {
                const dragDuration = Date.now() - dragStartTime;
                
                // Remove dragging class
                currentDraggedElement.classList.remove('dragging');
                
                // Restore smooth transitions (not position) after drag ends
                currentDraggedElement.style.transition = 'box-shadow 0.2s ease, border-color 0.2s ease, transform 0.15s ease';
                
                // Check if it was a click (short duration and small distance)
                if (dragDuration < 200 && dragDistance < 5) {
                    // It was a click, not a drag
                    selectElement(currentDraggedElement);
                }
                
                            // Save position to localStorage after drag ends
            if (currentDraggedElement) {
                const index = parseInt(currentDraggedElement.dataset.index);
                if (!isNaN(index)) {
                    const x = Math.round(parseFloat(currentDraggedElement.style.left) || 0);
                    const y = Math.round(parseFloat(currentDraggedElement.style.top) || 0);
                    savedPositions[index] = { x, y };
                    savePositionsToStorage();
                }
            }
                
                isDragging = false;
                currentDraggedElement = null;
                
                // Remove global event listeners
                document.removeEventListener('mousemove', handleMouseMove);
                document.removeEventListener('mouseup', handleMouseUp);
                document.removeEventListener('touchmove', handleTouchMove);
                document.removeEventListener('touchend', handleMouseUp);
            }
        }

        // Keyboard navigation for selected elements
        document.addEventListener('keydown', function(e) {
            if (!selectedElement || positionsLocked) return;
            
            let moved = false;
            
            switch (e.key) {
                case 'ArrowUp':
                    e.preventDefault();
                    moveSelectedElement('up');
                    moved = true;
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    moveSelectedElement('down');
                    moved = true;
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    moveSelectedElement('left');
                    moved = true;
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    moveSelectedElement('right');
                    moved = true;
                    break;
            }
            
            // Visual feedback when moving with keyboard
            if (moved) {
                selectedElement.style.transform = 'scale(1.05)';
                setTimeout(() => {
                    selectedElement.style.transform = 'scale(1)';
                }, 150);
            }
        });

        function lockPositions() {
            const container = document.querySelector('.print-textarea-container');
            const textElements = container.querySelectorAll('.draggable-text-item');
            const lockBtn = document.querySelector('.btn-lock-position');
            
            if (!positionsLocked) {
                // Save current positions
                savedPositions = {};
                textElements.forEach((element, index) => {
                    const x = Math.round(parseFloat(element.style.left) || 0);
                    const y = Math.round(parseFloat(element.style.top) || 0);
                    savedPositions[index] = { x, y };
                });
                
                // Save to localStorage for persistence
                savePositionsToStorage();
                
                // Lock positions
                positionsLocked = true;
                lockBtn.textContent = '🔓 Unlock Posisi';
                lockBtn.classList.add('locked');
                
                // Disable dragging
                textElements.forEach(element => {
                    element.style.cursor = 'not-allowed';
                    element.classList.add('locked');
                });
                
                alert('Posisi teks telah dikunci dan tersimpan! Posisi akan tetap ada meskipun halaman di-refresh.');
            } else {
                // Unlock positions
                positionsLocked = false;
                lockBtn.textContent = '🔒 Lock Posisi';
                lockBtn.classList.remove('locked');
                
                // Enable dragging
                textElements.forEach(element => {
                    element.style.cursor = 'move';
                    element.classList.remove('locked');
                });
                
                alert('Posisi teks telah dibuka kunci! Anda dapat mengatur ulang posisi.');
            }
        }

        // Function to preserve user positions more effectively
        function preserveUserPositions() {
            const container = document.querySelector('.print-textarea-container');
            const textElements = container.querySelectorAll('.draggable-text-item');
            
            if (textElements.length === 0) return;
            
            // Save current positions before any adjustments
            const currentPositions = {};
            textElements.forEach((element, index) => {
                const x = parseInt(element.style.left) || 0;
                const y = parseInt(element.style.top) || 0;
                currentPositions[index] = { x, y };
            });
            
            // Only adjust if positions are significantly problematic
            let needsAdjustment = false;
            const a4Width = 813; // F4
            const a4Height = 1247; // F4
            const margin = 0;
            
            Object.values(currentPositions).forEach(pos => {
                if (pos.x < margin || pos.x > (a4Width - margin) || pos.y < margin || pos.y > (a4Height - margin)) {
                    needsAdjustment = true;
                }
            });
            
            if (needsAdjustment) {
                console.log('Critical position issues detected - minimal adjustment needed');
                // Apply minimal adjustments only for out-of-bounds elements
                textElements.forEach((element, index) => {
                    const pos = currentPositions[index];
                    let newX = pos.x;
                    let newY = pos.y;
                    
                    // Only adjust if out of bounds
                    if (pos.x < margin) newX = margin;
                    if (pos.x > (a4Width - margin)) newX = a4Width - margin;
                    if (pos.y < margin) newY = margin;
                    if (pos.y > (a4Height - margin)) newY = a4Height - margin;
                    
                    // Apply only if changed
                    if (newX !== pos.x || newY !== pos.y) {
                        element.style.left = newX + 'px';
                        element.style.top = newY + 'px';
                    }
                });
            } else {
                console.log('User positions preserved - no adjustments needed');
            }
        }

        // Function to change font size of print elements
        function changeFontSize() {
            const fontSizeSelect = document.getElementById('fontSizeControl');
            const newFontSize = parseInt(fontSizeSelect.value);
            currentFontSize = newFontSize;
            
            // Update font size of all draggable text elements
            const textElements = document.querySelectorAll('.draggable-text-item');
            textElements.forEach(element => {
                element.style.fontSize = newFontSize + 'px';
            });
            
            console.log(`📝 Font size changed to ${newFontSize}px`);
            
            // Save font size preference to storage
            try {
                storageManager.save('printFontSize', newFontSize.toString());
                console.log('💾 Font size preference saved to storage');
            } catch (error) {
                console.error('❌ Error saving font size preference:', error);
            }
        }

        // Function to change font family (gaya teks)
        function changeFontFamily() {
            const select = document.getElementById('fontFamilyControl');
            if (!select) return;
            const newFontFamily = select.value;
            currentFontFamily = newFontFamily;

            // Apply to all draggable elements, and rebuild kaca-data with fixed columns layout
            const textElements = document.querySelectorAll('.draggable-text-item');
            textElements.forEach(element => {
                const type = element.dataset.type || '';
                // Apply font family to the element itself with !important to override CSS
                element.style.setProperty('font-family', newFontFamily, 'important');
                
                // Also apply font family to the text-content child to ensure it inherits
                const content = element.querySelector('.text-content');
                if (content) {
                    if (type === 'kaca-data' || element.dataset.index === '6') {
                        // For kaca-data, rebuild with fixed columns layout
                        const raw = element.dataset.rawText || content.textContent || '';
                        content.innerHTML = buildKacaDataFixedColumnsHTML(raw, newFontFamily, currentFontSize);
                        // Also set font family on content for kaca-data
                        content.style.setProperty('font-family', newFontFamily, 'important');
                    } else {
                        // For other elements (nama toko, alamat, etc.), apply font family directly with !important
                        content.style.setProperty('font-family', newFontFamily, 'important');
                    }
                }
            });

            try {
                storageManager.save('printFontFamily', newFontFamily);
            } catch (error) {
                console.error('❌ Error saving font family preference:', error);
            }
        }

        // Load saved font family preference
        function loadFontFamilyPreference() {
            try {
                const saved = storageManager.load('printFontFamily');
                const select = document.getElementById('fontFamilyControl');
                if (saved && select) {
                    currentFontFamily = saved;
                    select.value = saved;
                } else if (select) {
                    select.value = currentFontFamily;
                }

                // Apply immediately to existing elements
                changeFontFamily();
            } catch (error) {
                console.error('❌ Error loading font family preference:', error);
            }
        }

        // Function to change font weight (ketebalan teks) of print elements
        function changeFontWeight() {
            const fontWeightSelect = document.getElementById('fontWeightControl');
            const newFontWeight = parseInt(fontWeightSelect.value);
            currentFontWeight = newFontWeight;
            
            // Update font weight of all draggable text elements except special types overriding weight
            const textElements = document.querySelectorAll('.draggable-text-item');
            textElements.forEach(element => {
                const type = element.dataset.type || '';
                // Apply font weight to the element itself
                if (type === 'header' || type === 'total') {
                    // keep bold for header/total
                    element.style.setProperty('font-weight', '700', 'important');
                } else {
                    element.style.setProperty('font-weight', String(newFontWeight), 'important');
                }
                
                // Also apply font weight to the text-content child to ensure it inherits
                const content = element.querySelector('.text-content');
                if (content) {
                    if (type === 'header' || type === 'total') {
                        // keep bold for header/total
                        content.style.setProperty('font-weight', '700', 'important');
                    } else {
                        content.style.setProperty('font-weight', String(newFontWeight), 'important');
                    }
                }
            });
            
            console.log(`📝 Font weight changed to ${newFontWeight}`);
            
            // Save font weight preference to storage
            try {
                storageManager.save('printFontWeight', newFontWeight.toString());
                console.log('💾 Font weight preference saved to storage');
            } catch (error) {
                console.error('❌ Error saving font weight preference:', error);
            }
        }

        // Function to load saved font weight preference
        function loadFontWeightPreference() {
            try {
                const saved = storageManager.load('printFontWeight');
                if (saved) {
                    const weight = parseInt(saved);
                    currentFontWeight = weight;
                    const select = document.getElementById('fontWeightControl');
                    if (select) {
                        select.value = String(weight);
                    }
                    // apply to existing elements if any
                    const textElements = document.querySelectorAll('.draggable-text-item');
                    textElements.forEach(element => {
                        const type = element.dataset.type || '';
                        // Apply font weight to the element itself
                        if (type === 'header' || type === 'total') {
                            element.style.setProperty('font-weight', '700', 'important');
                        } else {
                            element.style.setProperty('font-weight', String(weight), 'important');
                        }
                        
                        // Also apply font weight to the text-content child
                        const content = element.querySelector('.text-content');
                        if (content) {
                            if (type === 'header' || type === 'total') {
                                content.style.setProperty('font-weight', '700', 'important');
                            } else {
                                content.style.setProperty('font-weight', String(weight), 'important');
                            }
                        }
                    });
                    console.log(`📝 Loaded saved font weight: ${weight}`);
                } else {
                    // initialize control with default and apply
                    const select = document.getElementById('fontWeightControl');
                    if (select) select.value = String(currentFontWeight);
                    changeFontWeight();
                }
            } catch (error) {
                console.error('❌ Error loading font weight preference:', error);
            }
        }

        // Function to load saved font size preference
        function loadFontSizePreference() {
            try {
                const savedFontSize = storageManager.load('printFontSize');
                if (savedFontSize) {
                    const fontSize = parseInt(savedFontSize);
                    currentFontSize = fontSize;
                    
                    // Update select element
                    const fontSizeSelect = document.getElementById('fontSizeControl');
                    if (fontSizeSelect) {
                        fontSizeSelect.value = fontSize;
                    }
                    
                }
            } catch (error) {
                console.error('❌ Error loading font size preference:', error);
            }
        }

        // Function to change column spacing of kaca-data
        function changeColumnSpacing() {
            const spacingSelect = document.getElementById('columnSpacingControl');
            const newSpacing = parseInt(spacingSelect.value);
            currentColumnSpacing = newSpacing;
            
            // Update column spacing of kaca-data elements
            const kacaDataElements = document.querySelectorAll('.draggable-text-item[data-type="kaca-data"]');
            kacaDataElements.forEach(element => {
                // Reformat the text content with new column spacing
                const textContent = element.querySelector('.text-content');
                if (textContent) {
                    const originalText = textContent.textContent;
                    const reformattedText = reformatKacaDataWithSpacing(originalText, newSpacing);
                    textContent.textContent = reformattedText;
                }
            });
            
            console.log(`📊 Column spacing changed to ${newSpacing}px`);
            
            // Save column spacing preference to storage
            try {
                storageManager.save('printColumnSpacing', newSpacing.toString());
                console.log('💾 Column spacing preference saved to storage');
            } catch (error) {
                console.error('❌ Error saving column spacing preference:', error);
            }
        }

        // Helper to center-align text within fixed width (monospace)
        function centerPad(value, width) {
            const text = (value ?? '').toString();
            const clipped = text.length > width ? text.slice(0, width) : text;
            const totalPadding = width - clipped.length;
            const leftPadding = Math.floor(totalPadding / 2);
            const rightPadding = totalPadding - leftPadding;
            return ' '.repeat(leftPadding) + clipped + ' '.repeat(rightPadding);
        }

        // Measure actual monospace character width in pixels for a given font size
        function getMonospaceCharWidthPx(fontSizePx) {
            try {
                const probe = document.createElement('span');
                probe.textContent = 'M';
                probe.style.position = 'absolute';
                probe.style.visibility = 'hidden';
                probe.style.whiteSpace = 'pre';
                probe.style.fontFamily = "'Roboto Mono', 'Courier New', monospace";
                probe.style.fontSize = fontSizePx + 'px';
                document.body.appendChild(probe);
                const width = probe.getBoundingClientRect().width || probe.offsetWidth || Math.max(Math.round(fontSizePx * 0.6), 6);
                probe.remove();
                return width;
            } catch (_) {
                return Math.max(Math.round(fontSizePx * 0.6), 6);
            }
        }

        // Build HTML for kaca-data with fixed columns that do not shift across fonts
        function buildKacaDataFixedColumnsHTML(rawText, appliedFontFamily, fontSizePx) {
            try {
                // Normalize line breaks (Windows/Unix) and trailing spaces
                const lines = (rawText || '').replace(/\r\n?/g, '\n').split('\n');
                if (lines.length === 0) return '';

                const widths = columnSpacingConfig; // per-character widths
                const order = ['jenisKaca', 'pwd', 'noDo', 'ukuran', 'box', 'lbr', 'totalLbr'];
                const alignRight = new Set(['box', 'lbr', 'totalLbr']);
                const alignCenter = new Set(['ukuran']);

                // precise monospace char width in px for measurement container
                const charWidthPx = getMonospaceCharWidthPx(fontSizePx);

                const rowsHTML = lines.map(line => {
                    if (line.trim() === '') return '';
                    const cells = [];
                    let cursor = 0;
                    order.forEach(key => {
                        const span = widths[key] || 12;
                        const slice = line.substring(cursor, cursor + span);
                        cursor += span;
                        const text = slice.trim();
                        const alignClass = alignRight.has(key) ? 'right' : alignCenter.has(key) ? 'center' : 'left';
                        const pxWidth = span * charWidthPx;
                        cells.push(`<span class="kd-cell ${alignClass}" style="width:${pxWidth}px">` +
                                   `<span class="kd-text" style="font-family:${appliedFontFamily}; font-size:${fontSizePx}px">${escapeHtml(text)}</span>` +
                                   `</span>`);
                    });
                    return `<div class="kd-row">${cells.join('')}</div>`;
                }).join('');

                return `<div class="kd-block">${rowsHTML}</div>`;
            } catch (e) {
                console.error('buildKacaDataFixedColumnsHTML error', e);
                return rawText;
            }
        }

        function escapeHtml(str) {
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
        }

        // Function to reformat kaca-data text with new column spacing
        function reformatKacaDataWithSpacing(text, newConfig) {
            if (!text || text.trim() === '') return text;

            const lines = text.split('\n');
            const reformattedLines = [];

            const columnOrder = ['jenisKaca', 'pwd', 'noDo', 'ukuran', 'box', 'lbr', 'totalLbr'];
            const rightAlignColumns = new Set(['box', 'lbr', 'totalLbr']);
            const centerAlignColumns = new Set(['ukuran']);

            lines.forEach(line => {
                if (line.trim() === '') {
                    reformattedLines.push('');
                    return;
                }

                // Parse the line based on current spacing (existing rendering)
                const columns = [];
                let remainingLine = line;

                columnOrder.forEach(columnName => {
                    const currentWidth = columnSpacingConfig[columnName] || 12;
                    if (remainingLine.length >= currentWidth) {
                        columns.push(remainingLine.substring(0, currentWidth).trim());
                        remainingLine = remainingLine.substring(currentWidth);
                    } else {
                        columns.push(remainingLine.trim());
                        remainingLine = '';
                    }
                });

                // Reformat per newConfig with proper alignment
                const reformattedLine = columns.map((rawValue, index) => {
                    const columnName = columnOrder[index];
                    const width = newConfig[columnName] || 12;
                    const value = (rawValue ?? '').toString();

                    // Clip to width first
                    let clipped;
                    if (rightAlignColumns.has(columnName)) {
                        // Keep least significant part on the right when clipping
                        clipped = value.length > width ? value.slice(-width) : value;
                        return clipped.padStart(width);
                    } else if (centerAlignColumns.has(columnName)) {
                        return centerPad(value, width);
                    } else {
                        clipped = value.length > width ? value.slice(0, width) : value;
                        return clipped.padEnd(width);
                    }
                }).join('');

                reformattedLines.push(reformattedLine);
            });

            return reformattedLines.join('\n');
        }

        // Function to load saved column spacing preference
        function loadColumnSpacingPreference() {
            try {
                const savedSpacing = storageManager.load('printColumnSpacing');
                if (savedSpacing) {
                    const spacing = parseInt(savedSpacing);
                    currentColumnSpacing = spacing;
                    
                    // Update select element
                    const spacingSelect = document.getElementById('columnSpacingControl');
                    if (spacingSelect) {
                        spacingSelect.value = spacing;
                    }
                    
                    console.log(`📊 Loaded saved column spacing: ${spacing}px`);
                }
            } catch (error) {
                console.error('❌ Error loading column spacing preference:', error);
            }
        }

        // Function to update column spacing from individual inputs
        function updateColumnSpacing() {
            const newConfig = {
                jenisKaca: parseInt(document.getElementById('colJenisKaca').value) || 15,
                pwd: parseInt(document.getElementById('colPwd').value) || 8,
                noDo: parseInt(document.getElementById('colNoDo').value) || 12,
                ukuran: parseInt(document.getElementById('colUkuran').value) || 12,
                box: parseInt(document.getElementById('colBox').value) || 10,
                lbr: parseInt(document.getElementById('colLbr').value) || 10,
                totalLbr: parseInt(document.getElementById('colTotalLbr').value) || 12
            };
            
            // Update column spacing configuration
            columnSpacingConfig = { ...newConfig };
            
            // Show visual feedback
            showColumnSpacingFeedback();
            
            // Refresh the print data with new spacing
            refreshPrintData();
            
            // Save to localStorage
            saveColumnSpacingToStorage();
            
            console.log('📊 Column spacing updated:', columnSpacingConfig);
        }

        // Function to show visual feedback for column spacing updates
        function showColumnSpacingFeedback() {
            // Add a subtle animation to the print preview area
            const previewArea = document.querySelector('.print-textarea-container');
            if (previewArea) {
                previewArea.style.transition = 'all 0.3s ease';
                previewArea.style.transform = 'scale(1.02)';
                previewArea.style.boxShadow = '0 8px 25px rgba(102, 126, 234, 0.2)';
                
                setTimeout(() => {
                    previewArea.style.transform = 'scale(1)';
                    previewArea.style.boxShadow = '0 4px 20px rgba(0, 0, 0, 0.1)';
                }, 300);
            }
            
            // Add visual feedback to the section title
            const sectionTitle = document.querySelector('.controls-section-title');
            if (sectionTitle) {
                sectionTitle.style.color = '#667eea';
                sectionTitle.style.transition = 'color 0.3s ease';
                
                setTimeout(() => {
                    sectionTitle.style.color = '#2c3e50';
                }, 500);
            }
        }

        // Function to apply spacing presets
        function applyPreset(presetName) {
            if (spacingPresets[presetName]) {
                const newConfig = { ...spacingPresets[presetName] };
                columnSpacingConfig = newConfig;
                
                // Update input values
                document.getElementById('colJenisKaca').value = columnSpacingConfig.jenisKaca;
                document.getElementById('colPwd').value = columnSpacingConfig.pwd;
                document.getElementById('colNoDo').value = columnSpacingConfig.noDo;
                document.getElementById('colUkuran').value = columnSpacingConfig.ukuran;
                document.getElementById('colBox').value = columnSpacingConfig.box;
                document.getElementById('colLbr').value = columnSpacingConfig.lbr;
                document.getElementById('colTotalLbr').value = columnSpacingConfig.totalLbr;
                
                // Update preset button states
                document.querySelectorAll('.preset-btn').forEach(btn => btn.classList.remove('active'));
                event.target.classList.add('active');
                
                // Show visual feedback
                showColumnSpacingFeedback();
                
                // Refresh the print data with new spacing
                refreshPrintData();
                
                // Save to localStorage
                saveColumnSpacingToStorage();
                
                console.log(`📊 Applied ${presetName} preset:`, columnSpacingConfig);
            }
        }

        // Function to save column spacing to storage
        function saveColumnSpacingToStorage() {
            try {
                storageManager.save('columnSpacingConfig', columnSpacingConfig);
                console.log('💾 Column spacing saved to storage');
            } catch (error) {
                console.error('❌ Error saving column spacing:', error);
            }
        }

        // Function to load column spacing from storage
        function loadColumnSpacingFromStorage() {
            try {
                const saved = storageManager.load('columnSpacingConfig');
                if (saved) {
                    const loaded = saved;
                    columnSpacingConfig = { ...columnSpacingConfig, ...loaded };
                    
                    // Update input values if they exist
                    if (document.getElementById('colJenisKaca')) {
                        document.getElementById('colJenisKaca').value = columnSpacingConfig.jenisKaca;
                        document.getElementById('colPwd').value = columnSpacingConfig.pwd;
                        document.getElementById('colNoDo').value = columnSpacingConfig.noDo;
                        document.getElementById('colUkuran').value = columnSpacingConfig.ukuran;
                        document.getElementById('colBox').value = columnSpacingConfig.box;
                        document.getElementById('colLbr').value = columnSpacingConfig.lbr;
                        document.getElementById('colTotalLbr').value = columnSpacingConfig.totalLbr;
                    }
                    
                }
            } catch (error) {
                console.error('❌ Error loading column spacing:', error);
            }
        }

        // Function to change column spacing (legacy function for backward compatibility)
        function changeColumnSpacing() {
            const spacingSelect = document.getElementById('columnSpacingControl');
            if (spacingSelect) {
                const newSpacing = parseInt(spacingSelect.value);
                currentColumnSpacing = newSpacing;
                
                // Update all column widths to the same value
                const newConfig = {
                    jenisKaca: newSpacing,
                    pwd: newSpacing,
                    noDo: newSpacing,
                    ukuran: newSpacing,
                    box: newSpacing,
                    lbr: newSpacing,
                    totalLbr: newSpacing
                };
                
                // Update column spacing configuration
                columnSpacingConfig = { ...newConfig };
                
                // Update input values
                updateColumnInputs();
                
                // Refresh the print data with new spacing
                refreshPrintData();
                
                // Save to localStorage
                saveColumnSpacingToStorage();
                
                console.log(`📊 Column spacing changed to ${newSpacing}px for all columns`);
            }
        }

        // Function to update column input values
        function updateColumnInputs() {
            const inputs = [
                'colJenisKaca', 'colPwd', 'colNoDo', 'colUkuran', 'colBox', 'colLbr', 'colTotalLbr'
            ];
            
            inputs.forEach(id => {
                const input = document.getElementById(id);
                if (input) {
                    const columnName = id.replace('col', '').toLowerCase();
                    if (columnName === 'jeniskaca') columnName = 'jenisKaca';
                    if (columnName === 'nodo') columnName = 'noDo';
                    if (columnName === 'totallbr') columnName = 'totalLbr';
                    
                    input.value = columnSpacingConfig[columnName] || 12;
                }
            });
        }

        // Test function to debug TOTAL LBR issue
        function testKacaData() {
            console.log('🧪 Testing Kaca Data Processing...');
            
            // Check if kaca table exists
            const kacaTable = document.getElementById('kacaTable');
            if (!kacaTable) {
                console.error('❌ Kaca table not found!');
                return;
            }
            
            // Check kaca table body
            const kacaTableBody = document.getElementById('kacaTableBody');
            if (!kacaTableBody) {
                console.error('❌ Kaca table body not found!');
                return;
            }
            
            // Check rows
            const rows = kacaTableBody.querySelectorAll('tr');
            console.log(`📊 Found ${rows.length} rows in kaca table`);
            
            // Debug each row in detail
            rows.forEach((row, index) => {
                console.log(`\n🔍 === ROW ${index + 1} DETAILED ANALYSIS ===`);
                
                // Check row structure
                console.log('Row HTML:', row.outerHTML.substring(0, 300) + '...');
                
                // Check all input elements in the row
                const allInputs = row.querySelectorAll('input');
                console.log(`Found ${allInputs.length} input elements in row ${index + 1}:`);
                
                allInputs.forEach((input, inputIndex) => {
                    const className = input.className;
                    const value = input.value;
                    const placeholder = input.placeholder;
                    console.log(`  Input ${inputIndex + 1}: class="${className}", value="${value}", placeholder="${placeholder}"`);
                });
                
                // Check specific selectors
                const jenisKaca = row.querySelector('.jenis-kaca');
                const pwd = row.querySelector('.pwd');
                const noDo = row.querySelector('.no-do');
                const ukuran = row.querySelector('.ukuran');
                const box = row.querySelector('.box');
                const lbr = row.querySelector('.lbr');
                const totalLbr = row.querySelector('.total-lbr-input');
                
                console.log('Selector results:', {
                    jenisKaca: jenisKaca ? `Found: "${jenisKaca.value}"` : 'NOT FOUND',
                    pwd: pwd ? `Found: "${pwd.value}"` : 'NOT FOUND',
                    noDo: noDo ? `Found: "${noDo.value}"` : 'NOT FOUND',
                    ukuran: ukuran ? `Found: "${ukuran.value}"` : 'NOT FOUND',
                    box: box ? `Found: "${box.value}"` : 'NOT FOUND',
                    lbr: lbr ? `Found: "${lbr.value}"` : 'NOT FOUND',
                    totalLbr: totalLbr ? `Found: "${totalLbr.value}"` : 'NOT FOUND'
                });
                
                // Check if totalLbr has the right class
                if (totalLbr) {
                    console.log('✅ TOTAL LBR input found with classes:', totalLbr.className);
                    console.log('TOTAL LBR value:', `"${totalLbr.value}"`);
                    console.log('TOTAL LBR type:', totalLbr.type);
                    console.log('TOTAL LBR readonly:', totalLbr.readOnly);
                } else {
                    console.log('❌ TOTAL LBR input NOT FOUND!');
                    
                    // Try alternative selectors
                    const alternativeSelectors = [
                        'input[readonly]',
                        '.total-lbr',
                        'input[placeholder*="LBR"]',
                        'td:last-child input'
                    ];
                    
                    alternativeSelectors.forEach(selector => {
                        const alt = row.querySelector(selector);
                        if (alt) {
                            console.log(`🔍 Alternative selector "${selector}" found:`, alt);
                        }
                    });
                }
            });
            
            // Check column spacing configuration
            console.log('\n📏 Column Spacing Config:', columnSpacingConfig);
            
            // Test refreshPrintData function
            console.log('\n🔄 Testing refreshPrintData function...');
            try {
                refreshPrintData();
                console.log('✅ refreshPrintData executed successfully');
            } catch (error) {
                console.error('❌ Error in refreshPrintData:', error);
            }
        }

        // Make test function globally available
        window.testKacaData = testKacaData;

        // Simple function to check TOTAL LBR data quickly
        function quickCheckTotalLBR() {
            console.log('🚀 Quick Check TOTAL LBR Data...');
            
            const kacaTableBody = document.getElementById('kacaTableBody');
            if (!kacaTableBody) {
                console.error('❌ Kaca table body not found!');
                return;
            }
            
            const rows = kacaTableBody.querySelectorAll('tr');
            console.log(`📊 Found ${rows.length} rows`);
            
            let totalSum = 0;
            
            rows.forEach((row, index) => {
                const totalLbrInput = row.querySelector('.total-lbr-input');
                const totalLbrValue = totalLbrInput ? totalLbrInput.value : 'NOT FOUND';
                
                console.log(`Row ${index + 1}: TOTAL LBR = "${totalLbrValue}"`);
                
                if (totalLbrValue && totalLbrValue !== 'NOT FOUND') {
                    const match = totalLbrValue.match(/^(\d+(?:\.\d+)?)/);
                    if (match) {
                        const number = parseFloat(match[1]);
                        totalSum += number;
                        console.log(`  ✅ Added ${number} to total`);
                    }
                }
            });
            
            console.log(`\n🎯 GRAND TOTAL: ${totalSum} LBR`);
            
            // Check if there are any TOTAL LBR inputs at all
            const allTotalInputs = document.querySelectorAll('.total-lbr-input');
            console.log(`\n🔍 Found ${allTotalInputs.length} TOTAL LBR input elements in the entire table`);
            
            allTotalInputs.forEach((input, index) => {
                console.log(`  Input ${index + 1}: value="${input.value}", class="${input.className}", readonly=${input.readOnly}`);
            });
        }

        // Make quick check function globally available
        window.quickCheckTotalLBR = quickCheckTotalLBR;

        // Function to remove header row from kaca data
        function removeHeaderFromKacaData(kacaData) {
            if (!kacaData) return '';
            
            // Split into lines and remove the first line (header)
            const lines = kacaData.split('\n');
            if (lines.length > 1) {
                // Remove first line (header) and any empty lines
                const dataLines = lines.slice(1).filter(line => line.trim() !== '');
                return dataLines.join('\n');
            }
            return '';
        }

        // Function to clean kaca data for printing (no headers, no placeholders)
        function getCleanKacaData() {
            const kacaRows = document.querySelectorAll('#kacaTableBody tr');
            let cleanData = '';
            let totalLbrSum = 0;
            
            kacaRows.forEach((row, index) => {
                const jenisKaca = row.querySelector('.jenis-kaca')?.value || '';
                const pwd = row.querySelector('.pwd')?.value || '';
                const noDo = row.querySelector('.no-do')?.value || '';
                const ukuran = row.querySelector('.ukuran')?.value || '';
                const box = row.querySelector('.box')?.value || '';
                const lbr = row.querySelector('.lbr')?.value || '';
                
                // Try multiple selectors for TOTAL LBR
                let totalLbr = row.querySelector('input.total-lbr-input')?.value || '';
                if (!totalLbr) {
                    const altSelectors = [
                        'input.total-lbr-input',
                        'td.total-lbr input',
                        'td:last-child input',
                        'input[readonly]',
                        'input[placeholder*="LBR"]'
                    ];
                    
                    for (const selector of altSelectors) {
                        const altInput = row.querySelector(selector);
                        if (altInput && altInput.value) {
                            totalLbr = altInput.value;
                            break;
                        }
                    }
                }

                // Fallback: compute TOTAL LBR from BOX and LBR if empty
                if (!totalLbr || !totalLbr.trim()) {
                    const boxNumMatch = (box || '').trim().match(/^(\d+(?:\.\d+)?)/);
                    const lbrNumMatch = (lbr || '').trim().match(/^(\d+(?:\.\d+)?)/);
                    const boxNum = boxNumMatch ? parseFloat(boxNumMatch[1]) : 0;
                    const lbrNum = lbrNumMatch ? parseFloat(lbrNumMatch[1]) : 0;
                    // Jika kolom BOX tidak diisi, maka TOTAL LBR = LBR
                    // Jika kolom BOX diisi, maka TOTAL LBR = BOX * LBR
                    const computed = (boxNum === 0 || !box.trim()) ? lbrNum : boxNum * lbrNum;
                    if (computed > 0) {
                        totalLbr = String(Math.round(computed)) + ' LBR';
                    }
                }
                
                // Only add rows that have actual data
                const hasData = jenisKaca.trim() || pwd.trim() || noDo.trim() || ukuran.trim() || box.trim() || lbr.trim() || totalLbr.trim();
                
                if (hasData) {
                    const formattedRow = 
                        jenisKaca.padEnd(columnSpacingConfig.jenisKaca) +
                        pwd.padEnd(columnSpacingConfig.pwd) +
                        noDo.padEnd(columnSpacingConfig.noDo) +
                        // Center align ukuran column
                        centerPad(ukuran, columnSpacingConfig.ukuran) +
                        // Right-align numeric columns for better visual alignment
                        box.padStart(columnSpacingConfig.box) +
                        lbr.padStart(columnSpacingConfig.lbr) +
                        totalLbr.padStart(columnSpacingConfig.totalLbr);
                    
                    cleanData += formattedRow + '\n';
                    
                    // Calculate total LBR sum
                    if (totalLbr.trim()) {
                        const match = totalLbr.match(/^(\d+(?:\.\d+)?)/);
                        if (match) {
                            totalLbrSum += parseFloat(match[1]);
                        }
                    }
                }
            });
            
            return { cleanData, totalLbrSum };
        }

        // Get kaca data using clean function (no headers, no placeholders)
        const { cleanData: kacaData, totalLbrSum } = getCleanKacaData();
        
        // New clean version of refreshPrintData (no headers)
        function refreshPrintDataClean() {
            const container = document.querySelector('.print-textarea-container');
            
            // Clear existing content
            container.innerHTML = '';
            
            // Get form data
            const namaToko = document.getElementById('namaToko').value || 'Nama Toko';
            const alamat = document.getElementById('alamat').value || 'Alamat Toko';
            const tanggal = document.getElementById('tanggal').value || 'Tanggal';
            const nomorSJ = document.getElementById('nomorSJ').value || 'No. SJ';
            const supir = document.getElementById('supir').value || '';
            const noKendaraan = document.getElementById('noKendaraan').value || '';
            
            // Get clean kaca data (no headers, no placeholders)
            const { cleanData: kacaData, totalLbrSum } = getCleanKacaData();
            
            // Debug: Log the final kacaData and totalLbrSum
            console.log('Final kacaData (clean, no headers):', kacaData);
            console.log('Final totalLbrSum:', totalLbrSum);
            
            // Get footer data
            const cont = document.querySelector('.cont-input')?.value || '';
            const seal = document.querySelector('.seal-input')?.value || '';
            
            // Format date with uppercase month (for print modal)
            let formattedDate = 'Tanggal';
            if (tanggal) {
                const date = new Date(tanggal);
                const day = date.toLocaleDateString('id-ID', { day: '2-digit' });
                const monthUpper = date.toLocaleDateString('id-ID', { month: 'long' }).toUpperCase();
                const year = date.toLocaleDateString('id-ID', { year: 'numeric' });
                formattedDate = `${day} ${monthUpper} ${year}`;
            }
            
            // Create individual draggable text elements
            const textElements = [
                { text: namaToko, x: 20, y: 40, type: 'header' },
                { text: alamat, x: 20, y: 100, type: 'data' },
                { text: formattedDate, x: 20, y: 160, type: 'data' },
                { text: nomorSJ, x: 20, y: 220, type: 'data' },
                { text: supir, x: 20, y: 280, type: 'data' },
                { text: noKendaraan, x: 20, y: 340, type: 'data' },
                { text: kacaData, x: 20, y: 400, type: 'kaca-data' },
                { text: `${totalLbrSum} LBR`, x: 20, y: 500, type: 'total' },
                { text: cont, x: 20, y: 560, type: 'data' },
                { text: seal, x: 20, y: 620, type: 'data' }
            ];
            
            // Create and position each text element
            textElements.forEach((element, index) => {
                const textDiv = document.createElement('div');
                textDiv.className = 'draggable-text-item';
                
                // Create text content div
                const textContentDiv = document.createElement('div');
                textContentDiv.className = 'text-content';
                textContentDiv.textContent = element.text;
                textDiv.appendChild(textContentDiv);
                
                // Use saved positions if available, otherwise use default positions
                let x, y;
                if (savedPositions[index]) {
                    x = Math.round(savedPositions[index].x);
                    y = Math.round(savedPositions[index].y);
                    console.log(`📍 Using saved position for element ${index}:`, { x, y, text: element.text.substring(0, 30) + '...' });
                } else {
                    x = element.x;
                    y = element.y;
                    console.log(`🆕 Using default position for element ${index}:`, { x, y, text: element.text.substring(0, 30) + '...' });
                }
                
                textDiv.style.left = Math.round(x) + 'px';
                textDiv.style.top = Math.round(y) + 'px';
                textDiv.dataset.index = index;
                textDiv.dataset.type = element.type;
                // Preserve raw text for reliable rebuilds (font change, print)
                textDiv.dataset.rawText = element.text;
                
                // Apply current font family to all text elements
                textDiv.style.fontFamily = currentFontFamily;
                
                // Apply current font weight to all text elements
                if (element.type === 'header' || element.type === 'total') {
                    // Keep bold for header/total
                    textDiv.style.setProperty('font-weight', '700', 'important');
                    textDiv.style.setProperty('font-variation-settings', 'normal', 'important');
                } else {
                    // Apply current font weight for other elements
                    textDiv.style.setProperty('font-weight', String(currentFontWeight), 'important');
                    textDiv.style.setProperty('font-variation-settings', 'normal', 'important');
                }
                
                // Debug: Log creation of kaca-data element (index 6)
                if (index === 6) {
                    console.log('🎯 Created kaca-data element (index 6):', {
                        text: element.text.substring(0, 100) + '...',
                        type: element.type,
                        x: x,
                        y: y,
                        className: textDiv.className,
                        dataset: textDiv.dataset
                    });
                }
                
                // Add locked styling if positions are locked
                if (positionsLocked) {
                    textDiv.style.cursor = 'not-allowed';
                    textDiv.classList.add('locked');
                }
                
                // Add special styling for different types
                if (element.type === 'header') {
                    textDiv.style.fontWeight = '700';
                    textDiv.style.fontSize = '16px';
                    textDiv.style.color = '#333';
                    textDiv.style.backgroundColor = '#f8f9fa';
                    // Ensure font family is applied to header (nama toko)
                    textDiv.style.fontFamily = currentFontFamily;
                } else if (element.type === 'total') {
                    textDiv.style.fontWeight = '700';
                    textDiv.style.color = '#28a745';
                    textDiv.style.borderColor = '#28a745';
                    textDiv.style.backgroundColor = '#f8fff9';
                    // Ensure font family is applied to total
                    textDiv.style.fontFamily = currentFontFamily;
                } else if (element.type === 'kaca-data') {
                    textDiv.style.maxWidth = '600px';
                    textDiv.style.width = 'auto';
                    // Preserve newlines and allow wrapping for immediate correct display
                    textDiv.style.whiteSpace = 'pre-wrap';
                    textDiv.style.wordWrap = 'break-word';
                    textDiv.style.fontSize = '12px';
                    textDiv.style.fontFamily = currentFontFamily;
                    textDiv.style.backgroundColor = '#f8f9ff';
                    textDiv.style.padding = '8px 12px';
                    textDiv.style.lineHeight = '1.2';
                    textDiv.style.height = 'auto';
                    textDiv.style.minHeight = 'auto';
                    textDiv.style.border = '2px solid #667eea';
                    textDiv.style.borderRadius = '6px';
                    textDiv.style.boxShadow = '0 2px 8px rgba(102, 126, 234, 0.15)';
                    
                    // Build fixed-columns HTML so column widths are stable across fonts
                    const kdHtml = buildKacaDataFixedColumnsHTML(element.text, currentFontFamily, currentFontSize);
                    const inner = textDiv.querySelector('.text-content');
                    if (inner) {
                        inner.innerHTML = kdHtml;
                        // Also apply font weight to text-content for kaca-data
                        inner.style.setProperty('font-weight', String(currentFontWeight), 'important');
                        inner.style.setProperty('font-variation-settings', 'normal', 'important');
                        // Also apply to all nested spans in kaca-data
                        const spans = inner.querySelectorAll('span');
                        spans.forEach(span => {
                            span.style.setProperty('font-weight', String(currentFontWeight), 'important');
                        });
                    }

                    // Debug: Log kaca-data element creation
                    console.log('🎯 Created kaca-data element with enhanced styling:', {
                        text: element.text.substring(0, 100) + '...',
                        maxWidth: textDiv.style.maxWidth,
                        backgroundColor: textDiv.style.backgroundColor,
                        border: textDiv.style.border
                    });
                } else if (element.type === 'timestamp') {
                    textDiv.style.fontSize = '11px';
                    textDiv.style.color = '#666';
                    textDiv.style.fontStyle = 'italic';
                    textDiv.style.backgroundColor = '#f9f9f9';
                }
                
                // Special handling for address element (index 1)
                if (index === 1) {
                    textDiv.classList.add('address-element');
                    textDiv.style.whiteSpace = 'pre-wrap';
                    textDiv.style.wordWrap = 'break-word';
                    textDiv.style.maxWidth = '300px';
                    textDiv.style.width = 'auto';
                    textDiv.style.height = 'auto';
                    textDiv.style.minHeight = 'auto';
                    textDiv.style.lineHeight = '1.3';
                    textDiv.style.padding = '6px 10px';
                }

                // Apply font weight to text-content for all elements (not just kaca-data)
                const textContentDivForWeight = textDiv.querySelector('.text-content');
                if (textContentDivForWeight && element.type !== 'kaca-data') {
                    // For non-kaca-data elements, apply font weight to text-content
                    if (element.type === 'header' || element.type === 'total') {
                        textContentDivForWeight.style.setProperty('font-weight', '700', 'important');
                        textContentDivForWeight.style.setProperty('font-variation-settings', 'normal', 'important');
                    } else {
                        textContentDivForWeight.style.setProperty('font-weight', String(currentFontWeight), 'important');
                        textContentDivForWeight.style.setProperty('font-variation-settings', 'normal', 'important');
                    }
                }
                
                // Force 8th element (index 7 - total LBR) text color to black in modal preview
                if (index === 7) {
                     textDiv.style.color = '#000';
                     const textContentDivForce = textDiv.querySelector('.text-content');
                     if (textContentDivForce) {
                         textContentDivForce.style.color = '#000';
                     }
                }
                
                // Apply current font size and weight to all elements (weight overridden for header/total)
                textDiv.style.fontSize = currentFontSize + 'px';
                textDiv.style.fontFamily = currentFontFamily;
                if (element.type !== 'header' && element.type !== 'total') {
                    textDiv.style.fontWeight = String(currentFontWeight);
                }
                
                container.appendChild(textDiv);
            });
            
            // Initialize drag and drop for all text elements
            initDragAndDropForElements();
        }

        // Test function to verify no headers in kaca data
        function testNoHeaders() {
            console.log('🧪 Testing No Headers in Kaca Data...');
            
            const { cleanData: kacaData, totalLbrSum } = getCleanKacaData();
            
            console.log('📊 Clean Kaca Data (should have NO headers):');
            console.log('Data length:', kacaData.length);
            console.log('Data content:', kacaData);
            
            // Check if any line contains header text
            const lines = kacaData.split('\n');
            const hasHeaders = lines.some(line => 
                line.includes('JENIS KACA') || 
                line.includes('PWD') || 
                line.includes('NO DO') || 
                line.includes('UKURAN') || 
                line.includes('BOX') || 
                line.includes('LBR') || 
                line.includes('TOTAL LBR')
            );
            
            if (hasHeaders) {
                console.log('❌ HEADERS FOUND! Kaca data still contains column titles');
            } else {
                console.log('✅ NO HEADERS FOUND! Kaca data is clean');
            }
            
            console.log('🎯 Total LBR Sum:', totalLbrSum);
            
            return { kacaData, totalLbrSum, hasHeaders };
        }
        
        // Make test function globally available
        window.testNoHeaders = testNoHeaders;

        // Input Log System
        let inputLogHistory = [];
        // Track last entered No. SJ to warn on duplicates
        let lastNomorSJ = '';
        // Track entry being edited
        let editingLogEntry = null;
        // Track last log entry ID for linking stok transactions
        let lastLogEntryId = null;
        try {
            const saved = storageManager.load('lastNomorSJ');
            lastNomorSJ = (saved || '').trim();
        } catch (_) {
            lastNomorSJ = '';
        }

        // Load input log from storage on page load
        function loadInputLogFromStorage() {
            try {
                const saved = storageManager.load('inputLogHistory');
                if (saved) {
                    inputLogHistory = saved;
                    renderInputLog();
                    updateSupirDanKendaraanSuggestions();
                } else {
                }
            } catch (error) {
                console.error('❌ Error loading input log:', error);
                inputLogHistory = [];
            }
        }

        // Save input log to storage
        function saveInputLogToStorage() {
            try {
                storageManager.save('inputLogHistory', inputLogHistory);
                console.log('💾 Input log saved to storage:', inputLogHistory.length, 'entries');
                // Update suggestion datalists whenever log changes
                updateKacaSuggestionsFromLogs();
                updateSupirDanKendaraanSuggestions();
                if (typeof window.refreshNomorSJWarningNow === 'function') {
                    window.refreshNomorSJWarningNow();
                }
            } catch (error) {
                console.error('❌ Error saving input log:', error);
            }
        }

        // Save current form input to log
        function saveCurrentInputToLog() {
            const namaToko = document.getElementById('namaToko').value.trim();
            const alamat = document.getElementById('alamat').value.trim();
            const alias = (document.getElementById('alias')?.value || '').trim();
            const tanggal = document.getElementById('tanggal').value;
            const nomorSJ = document.getElementById('nomorSJ').value.trim();
            const supir = document.getElementById('supir').value.trim();
            const noKendaraan = document.getElementById('noKendaraan').value.trim();
            
            // Check if required fields are filled
            if (!namaToko || !tanggal || !nomorSJ || !supir || !noKendaraan) {
                alert('Mohon lengkapi semua field yang wajib diisi sebelum menyimpan log!');
                return;
            }
            
            // Get kaca data
            const kacaData = getKacaDataForLog();
            
            // Create log entry
            const logEntry = {
                id: Date.now(),
                timestamp: new Date().toISOString(),
                data: {
                    namaToko,
                    alias,
                    alamat,
                    tanggal,
                    nomorSJ,
                    supir,
                    noKendaraan,
                    kacaData
                }
            };
            
            // Store log entry ID for linking stok transactions
            lastLogEntryId = logEntry.id;
            
            // Check if we're editing an existing entry
            if (editingLogEntry) {
                // Store original nomorSJ before clearing editingLogEntry (needed for stock transaction deletion)
                originalNomorSJForDeletion = editingLogEntry.entry.data?.nomorSJ || null;
                
                // Preserve the original log entry ID when editing
                logEntry.id = editingLogEntry.entry.id;
                lastLogEntryId = logEntry.id;
                
                // Replace the original entry with the new one
                inputLogHistory[editingLogEntry.index] = logEntry;
                editingLogEntry = null; // Clear editing state
                hideEditingIndicator(); // Hide editing indicator
                console.log('✏️ Updated existing log entry, originalNomorSJForDeletion:', originalNomorSJForDeletion);
            } else {
                // Clear originalNomorSJForDeletion if not editing
                originalNomorSJForDeletion = null;
                // Add to beginning of array (newest first)
                inputLogHistory.unshift(logEntry);
                
                // No limit on log entries - keep all data
            }
            
            // Save to localStorage
            saveInputLogToStorage();
            // Update lastNomorSJ AFTER successful save/print
            try { storageManager.save('lastNomorSJ', nomorSJ); } catch (_) {}
            lastNomorSJ = nomorSJ;
            
            // Render the log
            renderInputLog();
            
            // Optional: toast could be added here if needed
            
            console.log('💾 Saved input log entry:', logEntry);
        }

        // Helper: check if No. SJ exists in input log
        function isNomorSJInLog(nomor) {
            try {
                const val = (nomor || '').trim();
                if (!val) return false;
                return (inputLogHistory || []).some(entry => ((entry.data?.nomorSJ || '').trim() === val));
            } catch (_) { return false; }
        }

        // Warn if No. SJ duplicates an existing log entry
        document.addEventListener('DOMContentLoaded', function() {
            const nomorSJInput = document.getElementById('nomorSJ');
            const warningEl = document.getElementById('nomorSJWarning');
            if (!nomorSJInput) return;

            let nomorSJWarningTimer = null;
            // Auto-fill default value when focusing No. SJ if empty
            nomorSJInput.addEventListener('focus', function() {
                if (!nomorSJInput.value || nomorSJInput.value.trim() === '') {
                    // Prefill 7-digit default as requested (leading zeros allowed)
                    nomorSJInput.value = '225';
                    // Trigger input event so any bindings/validations refresh
                    nomorSJInput.dispatchEvent(new Event('input', { bubbles: true }));
                }
            });
            // Enforce numeric-only and 7 digits length on input
            nomorSJInput.addEventListener('input', function() {
                const digits = (nomorSJInput.value || '').replace(/\D+/g, '').slice(0, 7);
                nomorSJInput.value = digits;
            });
            function applyNomorSJWarningVisibility() {
                const current = nomorSJInput.value.trim();
                const isDuplicate = !!current && isNomorSJInLog(current);
                if (isDuplicate) {
                    warningEl.style.display = 'flex';
                    nomorSJInput.classList.add('has-warning');
                } else {
                    warningEl.style.display = 'none';
                    nomorSJInput.classList.remove('has-warning');
                }
            }

            nomorSJInput.addEventListener('input', function() {
                const current = nomorSJInput.value.trim();
                // Clear immediately when not duplicate; debounce when duplicate
                if (!current || !isNomorSJInLog(current)) {
                    warningEl.style.display = 'none';
                    nomorSJInput.classList.remove('has-warning');
                }
                // Debounce showing warning when equal to last value
                if (nomorSJWarningTimer) clearTimeout(nomorSJWarningTimer);
                nomorSJWarningTimer = setTimeout(() => {
                    applyNomorSJWarningVisibility();
                }, 500);
            });
            // Validate on blur without updating lastNomorSJ to avoid false warnings
            nomorSJInput.addEventListener('blur', function() {
                if (nomorSJWarningTimer) clearTimeout(nomorSJWarningTimer);
                applyNomorSJWarningVisibility();
            });

            // Expose refresh function globally and initialize state on load
            window.refreshNomorSJWarningNow = applyNomorSJWarningVisibility;
            applyNomorSJWarningVisibility();
        });

        // Function to get kaca data for log
        function getKacaDataForLog() {
            const kacaRows = document.querySelectorAll('#kacaTableBody tr');
            const kacaData = [];
            
            kacaRows.forEach((row, index) => {
                const jenisKaca = row.querySelector('.jenis-kaca')?.value || '';
                const pwd = row.querySelector('.pwd')?.value || '';
                const noDo = row.querySelector('.no-do')?.value || '';
                const ukuran = row.querySelector('.ukuran')?.value || '';
                const box = row.querySelector('.box')?.value || '';
                const lbr = row.querySelector('.lbr')?.value || '';
                
                // Try multiple selectors for TOTAL LBR
                let totalLbr = row.querySelector('input.total-lbr-input')?.value || '';
                if (!totalLbr) {
                    const altSelectors = [
                        'input.total-lbr-input',
                        'td.total-lbr input',
                        'td:last-child input',
                        'input[readonly]',
                        'input[placeholder*="LBR"]'
                    ];
                    
                    for (const selector of altSelectors) {
                        const altInput = row.querySelector(selector);
                        if (altInput && altInput.value) {
                            totalLbr = altInput.value;
                            break;
                        }
                    }
                }

                // Fallback: compute TOTAL LBR from BOX and LBR if empty
                if (!totalLbr || !totalLbr.trim()) {
                    const boxNumMatch = (box || '').trim().match(/^(\d+(?:\.\d+)?)/);
                    const lbrNumMatch = (lbr || '').trim().match(/^(\d+(?:\.\d+)?)/);
                    const boxNum = boxNumMatch ? parseFloat(boxNumMatch[1]) : 0;
                    const lbrNum = lbrNumMatch ? parseFloat(lbrNumMatch[1]) : 0;
                    // Jika kolom BOX tidak diisi, maka TOTAL LBR = LBR
                    // Jika kolom BOX diisi, maka TOTAL LBR = BOX * LBR
                    const computed = (boxNum === 0 || !box.trim()) ? lbrNum : boxNum * lbrNum;
                    if (computed > 0) {
                        totalLbr = String(Math.round(computed)) + ' LBR';
                    }
                }
                
                // Get harga jual
                const hargaJual = row.querySelector('.harga-jual')?.value?.trim() || '';
                
                // Only add rows that have actual data
                const hasData = jenisKaca.trim() || pwd.trim() || noDo.trim() || ukuran.trim() || box.trim() || lbr.trim() || totalLbr.trim() || hargaJual.trim();
                
                if (hasData) {
                    kacaData.push({
                        jenisKaca: jenisKaca.trim(),
                        pwd: pwd.trim(),
                        noDo: noDo.trim(),
                        ukuran: ukuran.trim(),
                        hargaJual: hargaJual.trim(),
                        box: box.trim(),
                        lbr: lbr.trim(),
                        totalLbr: totalLbr.trim()
                    });
                }
            });
            
            // Get footer data (CONT and SEAL)
            const contInput = document.querySelector('.cont-input');
            const sealInput = document.querySelector('.seal-input');
            const grandTotalInput = document.querySelector('.grand-total-input');
            
            const footerData = {
                cont: contInput ? contInput.value.trim() : '',
                seal: sealInput ? sealInput.value.trim() : '',
                grandTotal: grandTotalInput ? grandTotalInput.value.trim() : ''
            };
            
            return {
                rows: kacaData,
                footer: footerData
            };
        }

        // Current search query state
        let currentLogSearchQuery = '';

        // Helper function to check if input is a date filter
        function isDateFilter(input) {
            // Check for dd/mm/yy, dd/mm, or dd format
            const datePatterns = [
                /^\d{1,2}\/\d{1,2}\/\d{2}$/,  // dd/mm/yy
                /^\d{1,2}\/\d{1,2}$/,          // dd/mm
                /^\d{1,2}$/                     // dd
            ];
            return datePatterns.some(pattern => pattern.test(input));
        }

        // Helper function to parse date filter
        function parseDateFilter(input) {
            const today = new Date();
            const currentYear = today.getFullYear();
            const currentMonth = today.getMonth() + 1; // getMonth() returns 0-11
            
            if (input.includes('/')) {
                const parts = input.split('/');
                if (parts.length === 3) {
                    // dd/mm/yy format
                    const day = parseInt(parts[0]);
                    const month = parseInt(parts[1]);
                    const year = parseInt(parts[2]) + (parts[2] < 50 ? 2000 : 1900);
                    return { day, month, year };
                } else if (parts.length === 2) {
                    // dd/mm format
                    const day = parseInt(parts[0]);
                    const month = parseInt(parts[1]);
                    return { day, month, year: currentYear };
                }
            } else {
                // dd format
                const day = parseInt(input);
                return { day, month: currentMonth, year: currentYear };
            }
            return null;
        }

        // Helper function to check if entry date matches filter
        function matchesDateFilter(entryDate, filterDate) {
            if (!filterDate) return false;
            
            const entryDay = entryDate.getDate();
            const entryMonth = entryDate.getMonth() + 1;
            const entryYear = entryDate.getFullYear();
            
            return entryDay === filterDate.day && 
                   entryMonth === filterDate.month && 
                   entryYear === filterDate.year;
        }

        // Function to detect duplicate No. SJ entries and show warnings in placeholder
        function updateDuplicateWarnings() {
            const searchInput = document.getElementById('logSearchInput');
            
            if (!searchInput) return;
            
            // Count occurrences of each No. SJ
            const sjCounts = {};
            inputLogHistory.forEach(entry => {
                const sj = (entry.data?.nomorSJ || '').trim();
                if (sj) {
                    sjCounts[sj] = (sjCounts[sj] || 0) + 1;
                }
            });
            
            // Find duplicates (more than 1 occurrence)
            const duplicates = Object.entries(sjCounts)
                .filter(([sj, count]) => count > 1)
                .sort((a, b) => b[1] - a[1]); // Sort by count descending
            
            if (duplicates.length === 0) {
                // No duplicates, normal placeholder
                searchInput.classList.remove('search-with-warning');
                searchInput.placeholder = 'Search';
                return;
            }
            
            // Show warning styling and update placeholder
            searchInput.classList.add('search-with-warning');
            
            // Create simple warning text with duplicate numbers (max 3)
            const maxDisplay = 3;
            const displayDuplicates = duplicates.slice(0, maxDisplay);
            let warningText = '⚠️ ';
            
            displayDuplicates.forEach(([sj, count]) => {
                warningText += `${sj}(${count}) `;
            });
            
            // Add "..." if there are more than 3 duplicates
            if (duplicates.length > maxDisplay) {
                warningText += '...';
            }
            
            searchInput.placeholder = warningText.trim();
        }

        function applyLogSearch() {
            const input = document.getElementById('logSearchInput');
            currentLogSearchQuery = (input && input.value ? input.value : '').trim();
            renderInputLog();
        }

        // Reset log search filter
        function resetLogSearchFilter() {
            const input = document.getElementById('logSearchInput');
            if (input) {
                input.value = '';
                currentLogSearchQuery = '';
                renderInputLog();
            }
        }

        // Render input log entries (respects currentLogSearchQuery)
        function renderInputLog() {
            const container = document.getElementById('inputLogContainer');
            
            if (inputLogHistory.length === 0) {
                container.innerHTML = `
                    <div class="no-log-message">
                        <p>Belum ada log input</p>
                        <p class="log-hint">Log akan tersimpan otomatis saat Anda menekan Print Sekarang</p>
                    </div>
                `;
                return;
            }
            
            // Filter by search query if present
            let filtered = inputLogHistory;
            if (currentLogSearchQuery) {
                const q = currentLogSearchQuery.toLowerCase();
                
                // Check for special sorting commands
                if (q === '=') {
                    // Filter to show only duplicate No. SJ entries
                    const sjCounts = {};
                    inputLogHistory.forEach(entry => {
                        const sj = (entry.data?.nomorSJ || '').trim();
                        if (sj) {
                            sjCounts[sj] = (sjCounts[sj] || 0) + 1;
                        }
                    });
                    
                    const duplicateSJs = Object.keys(sjCounts).filter(sj => sjCounts[sj] > 1);
                    filtered = inputLogHistory.filter(entry => {
                        const sj = (entry.data?.nomorSJ || '').trim();
                        return duplicateSJs.includes(sj);
                    });
                } else if (q === '1-2') {
                    // Sort No SJ from small to large (ascending)
                    filtered = inputLogHistory.slice().sort((a, b) => {
                        const sjA = parseInt(a.data.nomorSJ) || 0;
                        const sjB = parseInt(b.data.nomorSJ) || 0;
                        return sjA - sjB;
                    });
                } else if (q === '2-1') {
                    // Sort No SJ from large to small (descending)
                    filtered = inputLogHistory.slice().sort((a, b) => {
                        const sjA = parseInt(a.data.nomorSJ) || 0;
                        const sjB = parseInt(b.data.nomorSJ) || 0;
                        return sjB - sjA;
                    });
                } else if (isDateFilter(q)) {
                    // Filter by date
                    filtered = inputLogHistory.filter(entry => {
                        try {
                            const entryDate = new Date(entry.data.tanggal);
                            const searchDate = parseDateFilter(q);
                            return matchesDateFilter(entryDate, searchDate);
                        } catch (_) { return false; }
                    });
                } else {
                    // Regular text search
                    filtered = inputLogHistory.filter(entry => {
                        try {
                            const d = entry.data || {};
                            const fields = [
                                d.namaToko,
                                d.alias,
                                d.alamat,
                                d.tanggal,
                                d.nomorSJ,
                                d.supir,
                                d.noKendaraan
                            ].map(v => (v || '').toString().toLowerCase());

                            // Search inside kaca rows too
                            const kaca = d.kacaData || {};
                            const rows = Array.isArray(kaca) ? kaca : (kaca.rows || []);
                            const rowsText = rows.map(r => [r.jenisKaca, r.pwd, r.noDo, r.ukuran, r.box, r.lbr, r.totalLbr]
                                .map(v => (v || '').toString().toLowerCase()).join(' ')).join(' ');

                            return fields.some(text => text.includes(q)) || rowsText.includes(q);
                        } catch (_) { return false; }
                    });
                }
            }

            if (filtered.length === 0) {
                container.innerHTML = `
                    <div class="no-log-message">
                        <p>Tidak ada hasil untuk pencarian tersebut</p>
                        <p class="log-hint">Coba kata kunci lain atau kosongkan pencarian</p>
                    </div>
                `;
                return;
            }

            let html = '';
            filtered.forEach((entry) => {
                const timestamp = new Date(entry.timestamp).toLocaleString('id-ID', {
                    day: '2-digit',
                    month: '2-digit',
                    year: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
                
                // Format date for compact display
                const compactDate = new Date(entry.data.tanggal).toLocaleDateString('id-ID', {
                    day: '2-digit',
                    month: '2-digit',
                    year: '2-digit'
                });
                
                // Format kaca data for display
                const kacaDataDisplay = formatKacaDataForDisplay(entry.data.kacaData);
                
                html += `
                    <div class="log-entry" onclick="toggleLogDetailsById(${entry.id})" title="Klik untuk melihat detail lengkap" style="padding-left: 10px;">
                        <div class="log-entry-header" style="margin-bottom: 0px;">
                            <span class="log-timestamp">${timestamp}</span>
                            <span class="log-toggle-icon">📋</span>
                        </div>
                        
                        <!-- Default view (compact single line) -->
                        <div class="log-content-default" id="log-default-${entry.id}">
                            <div class="log-compact-line">
                                <span class="log-compact-item">
                                    <span class="log-compact-label">🏪</span>
                                    <span class="log-compact-value">${entry.data.namaToko}</span>
                                </span>
                                ${entry.data.alias ? `
                                <span class="log-compact-separator">|</span>
                                <span class="log-compact-item">
                                    <span class="log-compact-label">🏷️</span>
                                    <span class="log-compact-value">${entry.data.alias}</span>
                                </span>` : ''}
                                <span class="log-compact-separator">|</span>
                                <span class="log-compact-item">
                                    <span class="log-compact-label">📅</span>
                                    <span class="log-compact-value">${compactDate}</span>
                                </span>
                                <span class="log-compact-separator">|</span>
                                <span class="log-compact-item">
                                    <span class="log-compact-label">📄</span>
                                    <span class="log-compact-value">${entry.data.nomorSJ}</span>
                                </span>
                            </div>
                        </div>
                        
                        <!-- Detailed view (hidden by default) -->
                        <div class="log-content-detailed" id="log-detailed-${entry.id}" style="display: none;">
                            <div class="log-item">
                                <span class="log-label">Nama Toko</span>
                                <span class="log-sep">:</span>
                                <span class="log-value">${entry.data.namaToko}</span>
                            </div>
                            <div class="log-item">
                                <span class="log-label">Alias</span>
                                <span class="log-sep">:</span>
                                <span class="log-value">${entry.data.alias || '-'}</span>
                            </div>
                            <div class="log-item">
                                <span class="log-label">Tanggal</span>
                                <span class="log-sep">:</span>
                                <span class="log-value">${formatDateForDisplay(entry.data.tanggal)}</span>
                            </div>
                            <div class="log-item">
                                <span class="log-label">No. SJ</span>
                                <span class="log-sep">:</span>
                                <span class="log-value">${entry.data.nomorSJ}</span>
                            </div>
                            <div class="log-item">
                                <span class="log-label">Data Kaca</span>
                                <span class="log-sep">:</span>
                                <span class="log-value">${kacaDataDisplay}</span>
                            </div>
                            
                            <!-- Action buttons for detailed view -->
                            <div class="log-actions-detailed" style="padding-top: 4px;">
                                <button type="button" class="btn-load-data" onclick="loadInputFromLogById(${entry.id}); event.stopPropagation();" title="Muat data ke form">
                                    🔄 Muat ke Form
                                </button>
                                <button type="button" class="btn-edit-log" onclick="editLogEntryById(${entry.id}); event.stopPropagation();" title="Edit log ini">
                                    ✏️ Edit
                                </button>
                                <button type="button" class="btn-delete-log" onclick="deleteLogEntryById(${entry.id}); event.stopPropagation();" title="Hapus log ini">
                                    🗑️ Hapus
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
            
            // Update duplicate warnings after rendering
            updateDuplicateWarnings();
        }

        // Function to format kaca data for display in log
        function formatKacaDataForDisplay(kacaData) {
            if (!kacaData || !kacaData.rows || kacaData.rows.length === 0) {
                return 'Tidak ada data kaca';
            }
            
            const rows = kacaData.rows;
            const footer = kacaData.footer;
            
            let displayText = '';
            
            if (rows.length === 1) {
                const row = rows[0];
                displayText = `${row.jenisKaca} - ${row.ukuran} - ${row.totalLbr}`;
            } else {
                displayText = `${rows.length} baris data kaca (Total: ${calculateTotalFromKacaData(rows)} LBR)`;
            }
            
            // Add footer information (exclude grand total to avoid duplicate Total LBR)
            if (footer.cont || footer.seal) {
                const footerInfo = [];
                if (footer.cont) footerInfo.push(`CONT: ${footer.cont}`);
                if (footer.seal) footerInfo.push(`SEAL: ${footer.seal}`);
                
                if (footerInfo.length > 0) {
                    displayText += ` | ${footerInfo.join(', ')}`;
                }
            }
            
            return displayText;
        }

        // Function to calculate total from kaca data
        function calculateTotalFromKacaData(kacaData) {
            let total = 0;
            
            // Handle both old format (array) and new format (object with rows)
            const rows = Array.isArray(kacaData) ? kacaData : (kacaData.rows || []);
            
            rows.forEach(row => {
                if (row.totalLbr) {
                    const match = row.totalLbr.match(/^(\d+(?:\.\d+)?)/);
                    if (match) {
                        total += parseFloat(match[1]);
                    }
                }
            });
            
            return Math.round(total);
        }

        // Load input from log entry to form
        function loadInputFromLog(index, isEditing = false) {
            const entry = inputLogHistory[index];
            if (!entry) return;
            
            // If not editing, clear any existing editing state
            if (!isEditing) {
                cancelEditing();
            }
            
            // Fill form fields
            document.getElementById('namaToko').value = entry.data.namaToko;
            const aliasField = document.getElementById('alias');
            if (aliasField) aliasField.value = entry.data.alias || '';
            document.getElementById('alamat').value = entry.data.alamat;
            document.getElementById('tanggal').value = entry.data.tanggal;
            document.getElementById('nomorSJ').value = entry.data.nomorSJ;
            document.getElementById('supir').value = entry.data.supir;
            document.getElementById('noKendaraan').value = entry.data.noKendaraan;
            
            // Load kaca data if available
            if (entry.data.kacaData) {
                // Handle both old format (array) and new format (object with rows)
                const hasData = Array.isArray(entry.data.kacaData) ? 
                    entry.data.kacaData.length > 0 : 
                    (entry.data.kacaData.rows && entry.data.kacaData.rows.length > 0);
                
                if (hasData) {
                    loadKacaDataFromLog(entry.data.kacaData);
                    console.log('🔄 Loading kaca data from log entry:', entry.data.kacaData);
                } else {
                    console.log('ℹ️ No kaca data found in log entry');
                }
            } else {
                console.log('ℹ️ No kacaData field in log entry');
            }
            
            // Auto-resize textarea
            const alamatField = document.getElementById('alamat');
            if (alamatField) {
                autoResizeTextarea(alamatField);
            }
            
            // Show success message
            alert(`LOG dari: ${entry.data.namaToko}`);
            
            console.log('🔄 Loaded input from log entry:', entry);
        }

        // Function to load kaca data from log
        function loadKacaDataFromLog(kacaData) {
            const tbody = document.getElementById('kacaTableBody');
            if (!tbody) return;
            
            // Handle both old format (array) and new format (object with rows)
            const rows = Array.isArray(kacaData) ? kacaData : (kacaData.rows || []);
            const footer = kacaData.footer || {};
            
            // Clear existing rows
            tbody.innerHTML = '';
            
            // Add rows based on log data
            rows.forEach((rowData, index) => {
                const newRow = document.createElement('tr');
                const rowId = Date.now() + Math.random();
                
                // Build cells without embedding unescaped values
                newRow.innerHTML = `
                    <td>
                        <input type="text" placeholder="Jenis Kaca" class="jenis-kaca" onchange="calculateTotalLbr(this)" list="datalistJenisKaca" autocomplete="off" autocapitalize="none" spellcheck="false">
                    </td>
                    <td class="pwd-input">
                        <input type="text" placeholder="PWD" class="pwd" maxlength="3">
                    </td>
                    <td class="no-do-input">
                        <input type="text" placeholder="No DO" class="no-do">
                    </td>
                    <td>
                        <input type="text" placeholder="Ukuran" class="ukuran" onchange="calculateTotalLbr(this)" list="datalistUkuran" autocomplete="off" autocapitalize="none" spellcheck="false">
                    </td>
                    <td class="harga-input">
                        <input type="text" placeholder="Harga Jual" class="harga-jual" onchange="calculateTotalLbr(this)" oninput="calculateTotalLbr(this)">
                    </td>
                    <td class="box-input">
                        <input type="text" placeholder="0 BOX" class="box" onchange="calculateTotalLbr(this)" oninput="calculateTotalLbr(this)">
                    </td>
                    <td class="lbr-input">
                        <input type="text" placeholder="0 LBR" class="lbr" onchange="calculateTotalLbr(this)" oninput="calculateTotalLbr(this)">
                    </td>
                    <td class="total-lbr">
                        <input type="text" placeholder="0 LBR" class="total-lbr-input" readonly>
                    </td>
                `;
                
                // Assign values safely to avoid HTML attribute issues with quotes
                const jenisEl = newRow.querySelector('.jenis-kaca');
                const pwdEl = newRow.querySelector('.pwd');
                const noDoEl = newRow.querySelector('.no-do');
                const ukuranEl = newRow.querySelector('.ukuran');
                const hargaEl = newRow.querySelector('.harga-jual');
                const boxEl = newRow.querySelector('.box');
                const lbrEl = newRow.querySelector('.lbr');
                const totalEl = newRow.querySelector('.total-lbr-input');
                if (jenisEl) jenisEl.value = rowData.jenisKaca || '';
                if (pwdEl) pwdEl.value = rowData.pwd || '';
                if (noDoEl) noDoEl.value = rowData.noDo || '';
                if (ukuranEl) ukuranEl.value = rowData.ukuran || '';
                // Set harga jual and mark it as manually set to prevent auto-update from overwriting it
                if (hargaEl) {
                    const loadedHargaJual = rowData.hargaJual || rowData.harga || '';
                    if (loadedHargaJual) {
                        hargaEl.value = loadedHargaJual;
                        // Mark harga jual as manually set to prevent auto-update from overwriting it
                        hargaEl.setAttribute('data-manual-harga', 'true');
                    }
                    // Add event listener to allow user to edit harga jual
                    // When user changes harga jual, remove the flag so it can be updated if needed
                    hargaEl.addEventListener('input', function() {
                        // Remove flag when user manually edits harga jual
                        this.removeAttribute('data-manual-harga');
                    });
                    hargaEl.addEventListener('change', function() {
                        // Remove flag when user manually edits harga jual
                        this.removeAttribute('data-manual-harga');
                    });
                }
                if (boxEl) boxEl.value = rowData.box || '';
                if (lbrEl) lbrEl.value = rowData.lbr || '';
                if (totalEl) totalEl.value = rowData.totalLbr || '';
                
                // Recalculate row total to ensure correct value after loading
                // Using lbr input as reference; function will read both BOX and LBR
                if (typeof calculateTotalLbr === 'function' && (boxEl || lbrEl)) {
                    const refInput = lbrEl || boxEl;
                    try { calculateTotalLbr(refInput); } catch (_) {}
                }
                
                // Attach event listeners for jenis kaca and ukuran (same as in addKacaRow)
                if (jenisEl) {
                    jenisEl.setAttribute('autocomplete', 'off');
                    jenisEl.setAttribute('autocapitalize', 'none');
                    jenisEl.setAttribute('spellcheck', 'false');
                    jenisEl.addEventListener('focus', updateKacaSuggestionsFromLogs, { once: true });
                    // Update ukuran dropdown when jenis kaca changes
                    jenisEl.addEventListener('change', function() {
                        const jenisValue = this.value.trim();
                        if (ukuranEl) {
                            updateUkuranByJenisKaca(jenisValue, ukuranEl);
                        }
                    });
                    jenisEl.addEventListener('input', function() {
                        const jenisValue = this.value.trim();
                        if (ukuranEl && jenisValue) {
                            updateUkuranByJenisKaca(jenisValue, ukuranEl);
                        }
                    });
                }
                
                // Attach event listeners for ukuran with harga tracking (same as in addKacaRow)
                if (ukuranEl) {
                    ukuranEl.setAttribute('autocomplete', 'off');
                    ukuranEl.setAttribute('autocapitalize', 'none');
                    ukuranEl.setAttribute('spellcheck', 'false');
                    
                    // Use a flag to prevent multiple updates in quick succession
                    let isSelectingFromDatalist = false;
                    
                    // Debounce utility function
                    const debounce = (func, wait) => {
                        let timeout;
                        return function executedFunction(...args) {
                            const later = () => {
                                clearTimeout(timeout);
                                func.apply(this, args);
                            };
                            clearTimeout(timeout);
                            timeout = setTimeout(later, wait);
                        };
                    };
                    
                    // Helper function to update harga from selected ukuran
                    const updateHargaFromSelectedUkuran = function(inputElement, forceUpdate = false) {
                        updateHargaUkuranLogic(inputElement, forceUpdate);
                    };
                    
                    // Debounced update function
                    const debouncedUpdateHarga = debounce((input) => {
                        updateHargaFromSelectedUkuran(input, true);
                    }, 300);
                    
                    // Track when user selects from datalist
                    ukuranEl.addEventListener('change', function() {
                        isSelectingFromDatalist = true;
                        // Force update
                        updateHargaFromSelectedUkuran(this, true);
                        setTimeout(() => {
                            isSelectingFromDatalist = false;
                        }, 1000);
                    });
                    
                    // Listen to input event with debouncing
                    ukuranEl.addEventListener('input', function() {
                        debouncedUpdateHarga(this);
                    });
                    
                    // Listen to blur event
                    ukuranEl.addEventListener('blur', function() {
                        setTimeout(() => {
                            updateHargaFromSelectedUkuran(this, true);
                        }, 150);
                    });
                    
                    // Listen to keyup for Enter/Tab
                    ukuranEl.addEventListener('keyup', function(e) {
                        if (e.key === 'Enter' || e.key === 'Tab' || e.key === 'ArrowDown' || e.key === 'ArrowUp') {
                            setTimeout(() => {
                                updateHargaFromSelectedUkuran(this, true);
                            }, 100);
                        }
                    });
                    
                    // Initial update based on loaded data
                    if (jenisEl && jenisEl.value.trim() && ukuranEl.value.trim()) {
                        updateUkuranByJenisKaca(jenisEl.value.trim(), ukuranEl);
                        setTimeout(() => {
                            if (ukuranEl.value.trim()) {
                                updateHargaFromSelectedUkuran(ukuranEl, true);
                            }
                        }, 200);
                    } else if (ukuranEl.value.trim()) {
                        updateKacaSuggestionsFromLogs();
                        setTimeout(() => {
                            if (ukuranEl.value.trim()) {
                                updateHargaFromSelectedUkuran(ukuranEl, true);
                            }
                        }, 200);
                    }
                }
                
                tbody.appendChild(newRow);
            });
            
            // Load footer data (CONT and SEAL)
            if (footer.cont) {
                const contInput = document.querySelector('.cont-input');
                if (contInput) contInput.value = footer.cont;
            }
            
            if (footer.seal) {
                const sealInput = document.querySelector('.seal-input');
                if (sealInput) sealInput.value = footer.seal;
            }
            
            // Update grand total and refresh print data after rows populated
            setTimeout(() => {
                try { updateGrandTotal(); } catch (_) {}
                const printModal = document.getElementById('printModalOverlay');
                if (printModal && printModal.style.display === 'flex') {
                    try { refreshPrintData(); } catch (_) {}
                }
            }, 150);
            
            console.log('🔄 Loaded kaca data from log:', { rows, footer });
        }

        // Export input log to file
        // Removed exportInputLog (not used anymore)

        // Function to format kaca data for CSV export
        // Removed formatKacaDataForCSV (not used anymore)

        // Clear all input logs
        async function clearInputLog() {
            if (confirm('Apakah Anda yakin ingin menghapus semua log input? Tindakan ini tidak dapat dibatalkan.')) {
                try {
                    // Collect all log entry IDs before clearing
                    const logEntryIds = inputLogHistory.map(entry => entry.id).filter(id => id != null);
                    
                    // Clear input logs
                    inputLogHistory = [];
                    saveInputLogToStorage();
                    renderInputLog();
                    
                    // Delete related stok entries
                    if (logEntryIds.length > 0) {
                        // Ensure stokData is loaded
                        if (typeof window.stokData === 'undefined' || !Array.isArray(window.stokData)) {
                            try {
                                if (typeof loadData === 'function') {
                                    await loadData();
                                } else {
                                    window.stokData = [];
                                }
                            } catch (e) {
                                console.warn('Failed to load stokData:', e);
                                window.stokData = [];
                            }
                        }
                        
                        const currentStokData = window.stokData || [];
                        
                        // Find all stok entries linked to these log entries
                        const stokEntriesToDelete = currentStokData.filter(entry => 
                            entry.logEntryId != null && logEntryIds.includes(entry.logEntryId)
                        );
                        
                        console.log(`🗑️ Found ${stokEntriesToDelete.length} stok entries linked to ${logEntryIds.length} log entries`);
                        
                        // Delete each stok entry from IndexedDB and arrays
                        for (const stokEntry of stokEntriesToDelete) {
                            try {
                                // Remove from arrays
                                if (Array.isArray(window.stokData)) {
                                    const index = window.stokData.findIndex(e => e.id === stokEntry.id);
                                    if (index !== -1) {
                                        window.stokData.splice(index, 1);
                                    }
                                }
                                
                                if (typeof stokData !== 'undefined' && Array.isArray(stokData)) {
                                    stokData = stokData.filter(e => e.id !== stokEntry.id);
                                }
                                
                                // Delete from IndexedDB
                                if (typeof deleteEntryFromDB === 'function') {
                                    await deleteEntryFromDB(stokEntry.id);
                                }
                            } catch (error) {
                                console.error('Error deleting stok entry:', stokEntry.id, error);
                            }
                        }
                        
                        // Update UI if functions are available
                        if (typeof updateStokTable === 'function') {
                            updateStokTable();
                        }
                        if (typeof updateTotalSisa === 'function') {
                            updateTotalSisa();
                        }
                        if (typeof updateNamaTokoList === 'function') {
                            updateNamaTokoList();
                        }
                        if (typeof updateJenisKacaList === 'function') {
                            updateJenisKacaList();
                        }
                        if (typeof updateUkuranKacaList === 'function') {
                            updateUkuranKacaList();
                        }
                        
                        console.log(`✅ Deleted ${stokEntriesToDelete.length} related stok entries`);
                    }
                    
                    alert('Semua log input dan data terkait di riwayat stok telah dihapus!');
                    console.log('🗑️ Cleared all input logs and related stok entries');
                } catch (error) {
                    console.error('Error clearing logs:', error);
                    alert('Terjadi kesalahan saat menghapus log. Beberapa data mungkin tidak terhapus.');
                }
            }
        }

        // Edit a specific log entry: load into form for editing (entry will be replaced when saved)
        function editLogEntry(index) {
            const entry = inputLogHistory[index];
            if (!entry) return;
            
            // Store reference to entry being edited
            editingLogEntry = { entry: entry, index: index };
            
            // Load to form
            loadInputFromLog(index, true);
            
            // Show editing indicator
            showEditingIndicator();
        }

        // Show editing mode indicator
        function showEditingIndicator() {
            // Remove existing indicator
            const existing = document.getElementById('editingIndicator');
            if (existing) existing.remove();
            
            // Create new indicator
            const indicator = document.createElement('div');
            indicator.id = 'editingIndicator';
            indicator.className = 'editing-indicator';
            indicator.innerHTML = '✏️ Mode Edit';
            document.body.appendChild(indicator);
        }

        // Hide editing mode indicator
        function hideEditingIndicator() {
            const indicator = document.getElementById('editingIndicator');
            if (indicator) indicator.remove();
        }

        // Cancel editing and restore original entry
        function cancelEditing() {
            if (editingLogEntry) {
                editingLogEntry = null;
                hideEditingIndicator();
                console.log('❌ Editing cancelled');
            }
        }

        // Delete a specific log entry
        async function deleteLogEntry(index) {
            const entry = inputLogHistory[index];
            if (!entry) return;
            if (confirm('Hapus log ini? Tindakan ini tidak dapat dibatalkan.')) {
                // Get log entry ID and nomorSJ from the entry to delete related stok transactions
                const logEntryId = entry.id;
                const nomorSJ = entry.data?.nomorSJ || '';
                
                // Delete related stok transactions if logEntryId exists
                if (logEntryId) {
                    try {
                        // Ensure stokData is loaded
                        if (typeof window.stokData === 'undefined' || !Array.isArray(window.stokData)) {
                            if (typeof loadData === 'function') {
                                await loadData();
                            } else {
                                window.stokData = [];
                            }
                        }
                        
                        // Find all stok transactions with matching logEntryId (more precise than nota)
                        const currentStokData = window.stokData || [];
                        const transactionsToDelete = currentStokData.filter(stokEntry => {
                            return stokEntry.logEntryId === logEntryId;
                        });
                        
                        if (transactionsToDelete.length > 0) {
                            // Delete from IndexedDB and array
                            for (const transaction of transactionsToDelete) {
                                // Delete from IndexedDB
                                let deleteFunc = null;
                                if (typeof window.deleteEntryFromDB === 'function') {
                                    deleteFunc = window.deleteEntryFromDB;
                                } else if (typeof deleteEntryFromDB === 'function') {
                                    deleteFunc = deleteEntryFromDB;
                                }
                                
                                if (deleteFunc) {
                                    try {
                                        await deleteFunc(transaction.id);
                                    } catch (error) {
                                        console.error(`Error deleting transaction ID ${transaction.id} from DB:`, error);
                                    }
                                }
                                
                                // Remove from stokData array
                                const stokIndex = window.stokData.findIndex(e => e.id === transaction.id);
                                if (stokIndex !== -1) {
                                    window.stokData.splice(stokIndex, 1);
                                }
                            }
                            
                            // Update UI
                            if (typeof updateStokTable === 'function') {
                                updateStokTable();
                            }
                            if (typeof updateTotalSisa === 'function') {
                                updateTotalSisa();
                            }
                            if (typeof updateJenisKacaList === 'function') {
                                updateJenisKacaList();
                            }
                            if (typeof updateUkuranKacaList === 'function') {
                                updateUkuranKacaList();
                            }
                        }
                    } catch (error) {
                        console.error('Error deleting related stok transactions:', error);
                    }
                }
                
                // Delete the log entry
                inputLogHistory.splice(index, 1);
                saveInputLogToStorage();
                renderInputLog();
                alert('Log berhasil dihapus.');
            }
        }

        // Helper function to format date for display
        function formatDateForDisplay(dateString) {
            if (!dateString) return 'Tidak ada tanggal';
            
            const date = new Date(dateString);
            if (isNaN(date.getTime())) return dateString;
            
            return date.toLocaleDateString('id-ID', {
                day: '2-digit',
                month: 'long',
                year: 'numeric'
            });
        }

        // Load input log when page loads
        document.addEventListener('DOMContentLoaded', function() {
            loadInputLogFromStorage();
            // Reset search filter on page load
            resetLogSearchFilter();
            // Build initial suggestions (once after initial log load)
            updateKacaSuggestionsFromLogs();
            // Update supir and kendaraan suggestions with a small delay to ensure data is loaded
            setTimeout(function() {
                updateSupirDanKendaraanSuggestions();
            }, 100);
            // Disable browser autocomplete on existing inputs to avoid duplicate dropdowns
            document.querySelectorAll('input.jenis-kaca, input.ukuran').forEach(el => {
                el.setAttribute('autocomplete', 'off');
                el.setAttribute('autocapitalize', 'none');
                el.setAttribute('spellcheck', 'false');
            });
            
            // Ensure restore file input has proper multiple attribute
            const restoreInput = document.getElementById('restoreLogFileInput');
            if (restoreInput) {
                restoreInput.setAttribute('multiple', 'multiple');
            }
            
            // Add event listeners to update suggestions when input fields are focused
            const supirInput = document.getElementById('supir');
            const noKendaraanInput = document.getElementById('noKendaraan');
            
            if (supirInput) {
                supirInput.addEventListener('focus', function() {
                    updateSupirDanKendaraanSuggestions();
                });
            }
            
            if (noKendaraanInput) {
                noKendaraanInput.addEventListener('focus', function() {
                    updateSupirDanKendaraanSuggestions();
                });
            }
        });

        // Export input log to CSV (Excel compatible)
        function exportInputLogToCSV() {
            if (!inputLogHistory || inputLogHistory.length === 0) {
                alert('Tidak ada log untuk diexport.');
                return;
            }

            // Header dengan nama yang lebih jelas dan rapi
            const header = [
                'Timestamp',
                'Nama Toko',
                'Alias',
                'Alamat',
                'Tanggal',
                'Nomor SJ',
                'Supir',
                'No Kendaraan',
                'Jenis Kaca PWD',
                'No DO',
                'Ukuran=Box@Lbr',
                'Harga Jual',
                'Total Lebar',
                'Container',
                'Seal',
                'Grand Total'
            ];

            // Helper function untuk format field - format sederhana tanpa quote berlebihan
            const formatCSVField = (val) => {
                if (val === null || val === undefined) return '';
                let str = String(val).trim();
                // Replace newlines dengan spasi
                str = str.replace(/\n/g, ' ').replace(/\r/g, ' ');
                // Hanya quote jika mengandung separator atau quote
                if (str.includes(separator) || str.includes('"')) {
                    return '"' + str.replace(/"/g, '""') + '"';
                }
                return str;
            };

            const buildJenisKacaPwd = (row = {}) => {
                const jenis = (row.jenisKaca || '').toString().trim();
                const pwd = (row.pwd || '').toString().trim();
                if (!jenis && !pwd) return '';
                if (jenis && pwd) return `${jenis} ${pwd}`;
                return jenis || pwd;
            };

            const buildUkuranBoxLbr = (row = {}) => {
                const ukuran = (row.ukuran || '').toString().trim();
                const box = (row.box || '').toString().trim();
                const lbr = (row.lbr || '').toString().trim();
                if (!ukuran && !box && !lbr) return '';
                return `${ukuran}=${box}@${lbr}`;
            };

            const lines = [];
            // Gunakan semicolon untuk kompatibilitas Excel Indonesia (lebih umum digunakan)
            const separator = ';';
            
            // Add UTF-8 BOM for Excel compatibility
            lines.push('\uFEFF' + header.map(formatCSVField).join(separator));

            inputLogHistory.forEach(entry => {
                const d = entry.data || {};
                const kaca = d.kacaData || {};
                const rows = Array.isArray(kaca) ? kaca : (kaca.rows || []);
                const footer = kaca.footer || {};

                // Jika ada rows, buat satu baris per row kaca untuk lebih rapi
                if (rows && rows.length > 0) {
                    rows.forEach((row, idx) => {
                        const rec = [
                            idx === 0 ? (entry.timestamp || '') : '', // Timestamp hanya di baris pertama
                            idx === 0 ? (d.namaToko || '') : '',
                            idx === 0 ? (d.alias || '') : '',
                            idx === 0 ? (d.alamat || '').replace(/\n/g, ' ') : '',
                            idx === 0 ? (d.tanggal || '') : '',
                            idx === 0 ? (d.nomorSJ || '') : '',
                            idx === 0 ? (d.supir || '') : '',
                            idx === 0 ? (d.noKendaraan || '') : '',
                            buildJenisKacaPwd(row),
                            row.noDo || '',
                            buildUkuranBoxLbr(row),
                            row.hargaJual || row.harga || '',
                            row.totalLbr || '',
                            idx === rows.length - 1 ? (footer.cont || '') : '', // Footer hanya di baris terakhir
                            idx === rows.length - 1 ? (footer.seal || '') : '',
                            idx === rows.length - 1 ? (footer.grandTotal || '') : ''
                        ];
                        lines.push(rec.map(formatCSVField).join(separator));
                    });
                } else {
                    // Jika tidak ada rows, tetap export data utama
                    const rec = [
                        entry.timestamp || '',
                        d.namaToko || '',
                        d.alias || '',
                        (d.alamat || '').replace(/\n/g, ' '),
                        d.tanggal || '',
                        d.nomorSJ || '',
                        d.supir || '',
                        d.noKendaraan || '',
                        '', '', '', '', '', // Kolom kaca kosong (Jenis Kaca+PWD s/d Harga Jual)
                        footer.cont || '',
                        footer.seal || '',
                        footer.grandTotal || ''
                    ];
                    lines.push(rec.map(formatCSVField).join(separator));
                }
            });

            // Gunakan \r\n untuk line ending Windows dan pastikan format benar
            const csvContent = lines.join('\r\n');
            // Gunakan text/csv untuk CSV dengan semicolon separator
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'input_log_history.csv';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Import from new CSV format (one row per kaca item)
        function importInputLogFromCSVNewFormat(lines, header, rawHeader) {
            const hidx = Object.fromEntries(header.map((h,i)=>[h,i]));
            const imported = [];
            let currentEntry = null;
            let currentRows = [];

            const getValue = (row, key) => {
                const idx = hidx[key];
                if (idx === undefined) return '';
                const val = (row[idx] || '').replace(/^\"|\"$/g, '').trim();
                return val;
            };

            for (let i = 1; i < lines.length; i++) {
                const row = parseCSVLine(lines[i]);
                if (!row || row.length === 0) continue;

                const timestamp = getValue(row, 'timestamp');
                const namaToko = getValue(row, 'namaToko');
                
                // If this row has timestamp and namaToko, it's a new entry (or first row of entry)
                if (timestamp && namaToko) {
                    // Save previous entry if exists
                    if (currentEntry) {
                        currentEntry.data.kacaData.rows = currentRows;
                        imported.push(currentEntry);
                    }
                    
                    // Start new entry
                    const alias = getValue(row, 'alias');
                    const alamat = getValue(row, 'alamat').replace(/\\n/g, '\n');
                    const tanggal = getValue(row, 'tanggal');
                    const nomorSJ = getValue(row, 'nomorSJ');
                    const supir = getValue(row, 'supir');
                    const noKendaraan = getValue(row, 'noKendaraan');

                    currentEntry = {
                        id: Date.now() + i,
                        timestamp: timestamp || new Date().toISOString(),
                        data: {
                            namaToko,
                            alias,
                            alamat,
                            tanggal,
                            nomorSJ,
                            supir,
                            noKendaraan,
                            kacaData: {
                                rows: [],
                                footer: {
                                    cont: '',
                                    seal: '',
                                    grandTotal: ''
                                }
                            }
                        }
                    };
                    currentRows = [];
                }
                
                // Get footer values (only from rows that have them, typically last row of entry)
                const cont = getValue(row, 'cont');
                const seal = getValue(row, 'seal');
                const grandTotal = getValue(row, 'grandTotal');
                if (currentEntry && (cont || seal || grandTotal)) {
                    currentEntry.data.kacaData.footer.cont = cont || currentEntry.data.kacaData.footer.cont;
                    currentEntry.data.kacaData.footer.seal = seal || currentEntry.data.kacaData.footer.seal;
                    currentEntry.data.kacaData.footer.grandTotal = grandTotal || currentEntry.data.kacaData.footer.grandTotal;
                }

                // Parse kaca row data (use normalized keys)
                const jenisKacaPwd = getValue(row, 'jenisKacaPwd');
                const noDo = getValue(row, 'noDo');
                const ukuranBoxLbr = getValue(row, 'ukuranBoxLbr');
                const hargaJual = getValue(row, 'hargaJual');
                const totalLbr = getValue(row, 'totalLbr');

                // Parse jenisKacaPwd: format "Jenis PWD" or "Jenis" or "PWD"
                // Smart parsing: only separate if last part looks like PWD
                // PWD criteria: 3 chars or less, letters only, AND previous parts don't contain numbers
                // This prevents "FL 2MM KCC" from being split (because "2MM" contains number)
                let jenisKaca = '';
                let pwd = '';
                if (jenisKacaPwd) {
                    const parts = jenisKacaPwd.trim().split(/\s+/);
                    if (parts.length >= 2) {
                        const lastPart = parts[parts.length - 1];
                        const previousParts = parts.slice(0, -1).join(' ');
                        // Check if last part looks like PWD: 3 characters or less, letters only
                        const isLikelyPWD = lastPart.length <= 3 && /^[A-Za-z]+$/.test(lastPart);
                        // Also check if previous parts contain numbers - if yes, likely the whole thing is jenis kaca
                        const previousHasNumbers = /\d/.test(previousParts);
                        
                        if (isLikelyPWD && !previousHasNumbers) {
                            // Separate: last part is PWD (and previous parts don't have numbers)
                            jenisKaca = previousParts;
                            pwd = lastPart;
                        } else {
                            // Last part is part of jenis kaca, not PWD
                            // This handles cases like "FL 2MM KCC" where KCC is part of jenis kaca
                            jenisKaca = parts.join(' ');
                            pwd = '';
                        }
                    } else {
                        jenisKaca = jenisKacaPwd;
                        pwd = '';
                    }
                }

                // Parse ukuranBoxLbr: format "Ukuran=Box@Lbr"
                let ukuran = '';
                let box = '';
                let lbr = '';
                if (ukuranBoxLbr) {
                    const match = ukuranBoxLbr.match(/^(.+?)=(.+?)@(.+)$/);
                    if (match) {
                        ukuran = match[1];
                        box = match[2];
                        lbr = match[3];
                    } else {
                        ukuran = ukuranBoxLbr;
                    }
                }

                // Only add row if there's actual kaca data
                if (jenisKaca || pwd || noDo || ukuran || box || lbr || hargaJual || totalLbr) {
                    currentRows.push({
                        jenisKaca,
                        pwd,
                        noDo,
                        ukuran,
                        box,
                        lbr,
                        hargaJual: hargaJual || '',
                        totalLbr
                    });
                }
            }

            // Save last entry
            if (currentEntry) {
                currentEntry.data.kacaData.rows = currentRows;
                imported.push(currentEntry);
            }

            // Merge strategy: append imported at the beginning (newer first)
            inputLogHistory = [...imported, ...inputLogHistory];

            saveInputLogToStorage();
            renderInputLog();
            updateKacaSuggestionsFromLogs();
            
            // Process stok transactions from imported log entries
            processStokFromImportedLogs(imported);
        }

        // Handle import CSV for input log
        function handleImportLogFile(event) {
            const file = event.target.files && event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const text = e.target.result;
                    importInputLogFromCSV(text);
                    alert('Import log berhasil.');
                } catch (err) {
                    console.error('Import CSV error:', err);
                    alert('Gagal import CSV: ' + err.message);
                } finally {
                    // reset input so same file can be chosen again later
                    event.target.value = '';
                }
            };
            reader.readAsText(file, 'utf-8');
        }

        // Trigger restore file selection
        function triggerRestoreFileSelection() {
            const input = document.getElementById('restoreLogFileInput');
            if (input) {
                // Ensure multiple attribute is set
                input.setAttribute('multiple', 'multiple');
                console.log('Triggering restore file selection, multiple:', input.multiple);
                input.click();
            } else {
                console.error('Restore file input not found');
            }
        }

        // Handle restore from multiple backup files
        function handleRestoreLogFiles(event) {
            console.log('=== RESTORE FUNCTION CALLED ===');
            const files = event.target.files;
            console.log('Selected files:', files);
            console.log('Number of files:', files ? files.length : 0);
            
            if (!files || files.length === 0) {
                console.log('No files selected - exiting');
                alert('Tidak ada file yang dipilih');
                return;
            }
            
            // Debug: log file names and details
            console.log('=== FILE DETAILS ===');
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                console.log(`File ${i + 1}:`, {
                    name: file.name,
                    size: file.size,
                    type: file.type,
                    lastModified: new Date(file.lastModified)
                });
            }
            
            // Show progress dialog
            console.log('Creating progress dialog...');
            const progressDialog = showRestoreProgressDialog(files.length);
            
            processRestoreFiles(files, progressDialog)
                .then(() => {
                    hideRestoreProgressDialog(progressDialog);
                    alert(`Restore berhasil! ${files.length} file backup telah diproses.`);
                })
                .catch(err => {
                    hideRestoreProgressDialog(progressDialog);
                    console.error('Restore error:', err);
                    alert('Gagal restore: ' + err.message);
                })
                .finally(() => {
                    // Reset file input to allow selecting same files again
                    event.target.value = '';
                    console.log('File input reset');
                });
        }

        // Show restore progress dialog
        function showRestoreProgressDialog(totalFiles) {
            const dialog = document.createElement('div');
            dialog.id = 'restoreProgressDialog';
            dialog.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.5);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 10000;
            `;
            
            const content = document.createElement('div');
            content.style.cssText = `
                background: white;
                padding: 30px;
                border-radius: 12px;
                text-align: center;
                box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
                max-width: 400px;
                width: 90%;
            `;
            
            content.innerHTML = `
                <h3 style="margin: 0 0 20px 0; color: #333;">🔄 Memproses Restore</h3>
                <div id="restoreProgressText">Membaca file 1 dari ${totalFiles}...</div>
                <div style="margin: 20px 0;">
                    <div style="background: #f0f0f0; border-radius: 10px; height: 20px; overflow: hidden;">
                        <div id="restoreProgressBar" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); height: 100%; width: 0%; transition: width 0.3s ease;"></div>
                    </div>
                </div>
                <div id="restoreStatusText" style="font-size: 14px; color: #666; margin-top: 10px;">Memulai proses...</div>
            `;
            
            dialog.appendChild(content);
            document.body.appendChild(dialog);
            return dialog;
        }

        // Hide restore progress dialog
        function hideRestoreProgressDialog(dialog) {
            if (dialog && dialog.parentNode) {
                dialog.parentNode.removeChild(dialog);
            }
        }

        // Process multiple restore files
        async function processRestoreFiles(files, progressDialog) {
            console.log('=== PROCESSING RESTORE FILES ===');
            const allLogs = new Map(); // Use Map to store logs by ID, keeping only the latest
            const fileArray = Array.from(files);
            console.log('Processing', fileArray.length, 'files');
            
            for (let i = 0; i < fileArray.length; i++) {
                const file = fileArray[i];
                const progressText = document.getElementById('restoreProgressText');
                const progressBar = document.getElementById('restoreProgressBar');
                const statusText = document.getElementById('restoreStatusText');
                
                console.log(`\n--- Processing file ${i + 1}/${fileArray.length}: ${file.name} ---`);
                
                if (progressText) progressText.textContent = `Membaca file ${i + 1} dari ${fileArray.length}: ${file.name}`;
                if (statusText) statusText.textContent = `Memproses ${file.name}...`;
                
                try {
                    console.log('Reading file content...');
                    const fileContent = await readFileAsText(file);
                    console.log('File content length:', fileContent.length, 'characters');
                    console.log('First 200 chars:', fileContent.substring(0, 200));
                    
                    let logs = [];
                    
                    // Determine file type and parse accordingly
                    if (file.name.toLowerCase().endsWith('.json')) {
                        console.log('Parsing as JSON...');
                        logs = parseJSONToLogs(fileContent);
                        console.log(`✅ Parsed JSON file ${file.name}:`, logs.length, 'entries');
                    } else if (file.name.toLowerCase().endsWith('.csv')) {
                        console.log('Parsing as CSV...');
                        logs = parseCSVToLogs(fileContent);
                        console.log(`✅ Parsed CSV file ${file.name}:`, logs.length, 'entries');
                    } else {
                        console.warn(`❌ Unsupported file type: ${file.name}`);
                        if (statusText) statusText.textContent = `Peringatan: File ${file.name} tidak didukung (hanya CSV/JSON)`;
                        continue;
                    }
                    
                    // Debug: log sample entries
                    if (logs.length > 0) {
                        console.log('Sample log entry:', logs[0]);
                    }
                    
                    // Merge logs, keeping the latest version of each entry
                    let mergedCount = 0;
                    logs.forEach(log => {
                        if (log.id && log.timestamp) {
                            const existingLog = allLogs.get(log.id);
                            if (!existingLog || new Date(log.timestamp) > new Date(existingLog.timestamp)) {
                                allLogs.set(log.id, log);
                                mergedCount++;
                            }
                        } else {
                            console.warn('Log entry missing ID or timestamp:', log);
                        }
                    });
                    
                    console.log(`Merged ${mergedCount} new/updated entries from ${file.name}`);
                    if (statusText) statusText.textContent = `File ${file.name} berhasil diproses (${logs.length} entri, ${mergedCount} baru/diupdate)`;
                    
                } catch (err) {
                    console.error(`❌ Error processing file ${file.name}:`, err);
                    console.error('Error stack:', err.stack);
                    if (statusText) statusText.textContent = `Error: File ${file.name} gagal diproses - ${err.message}`;
                }
                
                // Update progress bar
                const progress = ((i + 1) / fileArray.length) * 100;
                if (progressBar) progressBar.style.width = progress + '%';
                console.log(`Progress: ${progress.toFixed(1)}%`);
            }
            
            // Convert Map back to array and sort by timestamp (newest first)
            console.log('\n=== FINALIZING RESTORE ===');
            console.log('Total unique logs collected:', allLogs.size);
            
            const mergedLogs = Array.from(allLogs.values()).sort((a, b) => 
                new Date(b.timestamp) - new Date(a.timestamp)
            );
            
            console.log('Final merged logs count:', mergedLogs.length);
            console.log('Sample final log:', mergedLogs[0]);
            
            const statusText = document.getElementById('restoreStatusText');
            if (statusText) statusText.textContent = `Menggabungkan ${mergedLogs.length} entri unik...`;
            
            // Replace current log history with merged logs
            console.log('Replacing inputLogHistory...');
            inputLogHistory = mergedLogs;
            
            console.log('Saving to storage...');
            saveInputLogToStorage();
            
            console.log('Rendering log display...');
            renderInputLog();
            
            // Process stok transactions from restored log entries
            console.log('Processing stok transactions from restored logs...');
            if (typeof processStokFromImportedLogs === 'function') {
                try {
                    await processStokFromImportedLogs(mergedLogs);
                    console.log('✅ Stok transactions processed from restored logs');
                } catch (error) {
                    console.error('⚠️ Error processing stok from restored logs:', error);
                }
            } else {
                console.warn('⚠️ processStokFromImportedLogs function not available');
            }
            
            if (statusText) statusText.textContent = `Restore selesai! ${mergedLogs.length} entri log telah dipulihkan.`;
            console.log('✅ Restore process completed successfully');
        }

        // Read file as text (Promise-based)
        function readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result);
                reader.onerror = e => reject(new Error('Gagal membaca file: ' + file.name));
                reader.readAsText(file, 'utf-8');
            });
        }

        // Parse CSV content to log entries
        function parseCSVToLogs(csvText) {
            const lines = csvText.replace(/\r/g, '').split('\n').filter(l => l.trim().length > 0);
            if (lines.length <= 1) return [];
            
            const header = parseCSVLine(lines[0]).map(h => h.replace(/^\"|\"$/g,''));
            const required = ['timestamp','namaToko','alamat','tanggal','nomorSJ','supir','noKendaraan','kacaRows'];
            
            for (const key of required) {
                if (!header.includes(key)) throw new Error('Header CSV tidak valid, kurang kolom: ' + key);
            }
            
            const hidx = Object.fromEntries(header.map((h,i)=>[h,i]));
            const logs = [];
            
            for (let i = 1; i < lines.length; i++) {
                try {
                    const fields = parseCSVLine(lines[i]);
                    const getField = (name) => (fields[hidx[name]] || '').replace(/^\"|\"$/g,'');
                    
                    // Parse kaca rows - support both old format (kacaRows string) and new format (separate columns)
                    let kacaRows = [];
                    const kacaRowsStr = getField('kacaRows');
                    if (kacaRowsStr) {
                        // Old format: kacaRows as string separated by ||
                        kacaRows = kacaRowsStr.split('||').map(rowStr => {
                            const vals = rowStr.split('|');
                            return {
                                jenisKaca: vals[0] || '',
                                pwd: vals[1] || '',
                                noDo: vals[2] || '',
                                ukuran: vals[3] || '',
                                hargaJual: vals[4] || vals[7] || '', // Support both old and new format
                                box: vals[5] || vals[4] || '', // Support both old and new format
                                lbr: vals[6] || vals[5] || '', // Support both old and new format
                                totalLbr: vals[7] || vals[6] || '' // Support both old and new format
                            };
                        });
                    } else {
                        // New format: separate columns
                        const jenisKacaPwd = getField('Jenis Kaca PWD') || '';
                        const noDo = getField('No DO') || '';
                        const ukuranBoxLbr = getField('Ukuran=Box@Lbr') || '';
                        const hargaJual = getField('Harga Jual') || '';
                        const totalLbr = getField('Total Lebar') || '';
                        
                        // Parse jenisKacaPwd (format: "jenis pwd" or "jenis" or "pwd")
                        // Smart parsing: only separate if last part looks like PWD
                        // PWD criteria: 3 chars or less, letters only, AND previous parts don't contain numbers
                        // This prevents "FL 2MM KCC" from being split (because "2MM" contains number)
                        const jenisKacaPwdParts = jenisKacaPwd.trim().split(/\s+/);
                        let jenisKaca = '';
                        let pwd = '';
                        if (jenisKacaPwdParts.length >= 2) {
                            const lastPart = jenisKacaPwdParts[jenisKacaPwdParts.length - 1];
                            const previousParts = jenisKacaPwdParts.slice(0, -1).join(' ');
                            // Check if last part looks like PWD: 3 characters or less, letters only
                            const isLikelyPWD = lastPart.length <= 3 && /^[A-Za-z]+$/.test(lastPart);
                            // Also check if previous parts contain numbers - if yes, likely the whole thing is jenis kaca
                            const previousHasNumbers = /\d/.test(previousParts);
                            
                            if (isLikelyPWD && !previousHasNumbers) {
                                // Separate: last part is PWD (and previous parts don't have numbers)
                                jenisKaca = previousParts;
                                pwd = lastPart;
                            } else {
                                // Last part is part of jenis kaca, not PWD
                                // This handles cases like "FL 2MM KCC" where KCC is part of jenis kaca
                                jenisKaca = jenisKacaPwdParts.join(' ');
                                pwd = '';
                            }
                        } else if (jenisKacaPwdParts.length === 1) {
                            jenisKaca = jenisKacaPwdParts[0];
                            pwd = '';
                        }
                        
                        // Parse ukuranBoxLbr (format: "ukuran=box@lbr")
                        let ukuran = '';
                        let box = '';
                        let lbr = '';
                        if (ukuranBoxLbr) {
                            const parts = ukuranBoxLbr.split('@');
                            if (parts.length === 2) {
                                const ukuranBox = parts[0].split('=');
                                ukuran = ukuranBox[0] || '';
                                box = ukuranBox[1] || '';
                                lbr = parts[1] || '';
                            } else {
                                ukuran = ukuranBoxLbr;
                            }
                        }
                        
                        if (jenisKaca || ukuran || noDo || hargaJual || box || lbr || totalLbr) {
                            kacaRows.push({
                                jenisKaca: jenisKaca.trim(),
                                pwd: pwd.trim(),
                                noDo: noDo.trim(),
                                ukuran: ukuran.trim(),
                                hargaJual: hargaJual.trim(),
                                box: box.trim(),
                                lbr: lbr.trim(),
                                totalLbr: totalLbr.trim()
                            });
                        }
                    }
                    
                    const log = {
                        id: Date.now() + Math.random(), // Generate new ID for restore
                        timestamp: getField('timestamp'),
                        data: {
                            namaToko: getField('namaToko'),
                            alias: getField('alias') || '',
                            alamat: getField('alamat').replace(/\\n/g, '\n'),
                            tanggal: getField('tanggal'),
                            nomorSJ: getField('nomorSJ'),
                            supir: getField('supir'),
                            noKendaraan: getField('noKendaraan'),
                            kacaData: {
                                rows: kacaRows,
                                footer: {
                                    cont: getField('kacaFooterCont') || '',
                                    seal: getField('kacaFooterSeal') || '',
                                    grandTotal: getField('kacaFooterGrandTotal') || ''
                                }
                            }
                        }
                    };
                    
                    logs.push(log);
                } catch (err) {
                    console.warn(`Gagal parse baris ${i + 1}:`, err);
                }
            }
            
            return logs;
        }

        // Parse JSON content to log entries
        function parseJSONToLogs(jsonText) {
            try {
                const data = JSON.parse(jsonText);
                
                // Handle different JSON formats
                let logs = [];
                
                if (Array.isArray(data)) {
                    // Direct array of logs
                    logs = data;
                } else if (data.logs && Array.isArray(data.logs)) {
                    // Object with logs property
                    logs = data.logs;
                } else if (data.inputLogHistory && Array.isArray(data.inputLogHistory)) {
                    // Object with inputLogHistory property
                    logs = data.inputLogHistory;
                } else {
                    throw new Error('Format JSON tidak dikenali. Harus berupa array atau object dengan property logs/inputLogHistory');
                }
                
                // Validate and clean log entries
                const validLogs = logs.filter(log => {
                    return log && 
                           typeof log === 'object' && 
                           log.timestamp && 
                           log.data && 
                           typeof log.data === 'object';
                }).map(log => {
                    // Ensure ID exists
                    if (!log.id) {
                        log.id = Date.now() + Math.random();
                    }
                    
                    // Ensure data structure is complete
                    if (!log.data.kacaData) {
                        log.data.kacaData = { rows: [], footer: {} };
                    }
                    
                    return log;
                });
                
                console.log(`Parsed JSON: ${validLogs.length} valid entries from ${logs.length} total entries`);
                return validLogs;
                
            } catch (err) {
                console.error('JSON parse error:', err);
                throw new Error('Gagal memparse file JSON: ' + err.message);
            }
        }

        function importInputLogFromCSV(csvText) {
            const lines = csvText.replace(/\r/g, '').split('\n').filter(l => l.trim().length > 0);
            if (lines.length <= 1) throw new Error('CSV kosong');
            const rawHeader = parseCSVLine(lines[0]).map(h => h.replace(/^\"|\"$/g,'').trim());

            // Mapping header user-friendly ke key names
            const headerMapping = {
                'Timestamp': 'timestamp',
                'Nama Toko': 'namaToko',
                'Alias': 'alias',
                'Alamat': 'alamat',
                'Tanggal': 'tanggal',
                'Nomor SJ': 'nomorSJ',
                'Supir': 'supir',
                'No Kendaraan': 'noKendaraan',
                'Jenis Kaca PWD': 'jenisKacaPwd',
                'No DO': 'noDo',
                'Ukuran=Box@Lbr': 'ukuranBoxLbr',
                'Harga Jual': 'hargaJual',
                'Total Lebar': 'totalLbr',
                'Container': 'cont',
                'Seal': 'seal',
                'Grand Total': 'grandTotal'
            };

            // Normalize header: map user-friendly names to key names, keep original if no mapping
            const header = rawHeader.map(h => headerMapping[h] || h);

            // Support both old CSVs (with key names) and new ones (with user-friendly names)
            // Also support new export format (one row per kaca row)
            // Check if it's new format: has 'jenisKacaPwd' (after mapping) or has both 'Timestamp' and 'Nama Toko' in raw header
            const isNewFormat = header.includes('jenisKacaPwd') || 
                               (rawHeader.includes('Timestamp') && rawHeader.includes('Nama Toko') && rawHeader.includes('Jenis Kaca PWD'));
            
            if (isNewFormat) {
                // New format: one row per kaca item, need to group by entry
                return importInputLogFromCSVNewFormat(lines, header, rawHeader);
            }

            // Old format: check required fields
            const required = ['timestamp','namaToko','alamat','tanggal','nomorSJ','supir','noKendaraan','kacaRows'];
            const missing = required.filter(key => !header.includes(key));
            if (missing.length > 0) {
                throw new Error('Header CSV tidak valid, kurang kolom: ' + missing.join(', '));
            }

            const hidx = Object.fromEntries(header.map((h,i)=>[h,i]));
            const imported = [];

            for (let i = 1; i < lines.length; i++) {
                const row = parseCSVLine(lines[i]);
                if (!row || row.length === 0) continue;
                const safe = idx => (row[hidx[idx]] || '').replace(/^\"|\"$/g,'');

                const timestamp = safe('timestamp');
                const namaToko = safe('namaToko');
                const alias = header.includes('alias') ? safe('alias') : '';
                const alamat = safe('alamat').replace(/\\n/g, '\n');
                const tanggal = safe('tanggal');
                const nomorSJ = safe('nomorSJ');
                const supir = safe('supir');
                const noKendaraan = safe('noKendaraan');
                const kacaRows = safe('kacaRows');
                const kacaFooterCont = safe('kacaFooterCont');
                const kacaFooterSeal = safe('kacaFooterSeal');
                const kacaFooterGrandTotal = safe('kacaFooterGrandTotal');

                const rows = kacaRows.split('||').filter(Boolean).map(r => {
                    const parts = r.split('|');
                    return {
                        jenisKaca: parts[0] || '',
                        pwd: parts[1] || '',
                        noDo: parts[2] || '',
                        ukuran: parts[3] || '',
                        box: parts[4] || '',
                        lbr: parts[5] || '',
                        totalLbr: parts[6] || ''
                    };
                });

                const entry = {
                    id: Date.now() + i,
                    timestamp: timestamp || new Date().toISOString(),
                    data: {
                        namaToko,
                        alias,
                        alamat,
                        tanggal,
                        nomorSJ,
                        supir,
                        noKendaraan,
                        kacaData: {
                            rows,
                            footer: {
                                cont: kacaFooterCont,
                                seal: kacaFooterSeal,
                                grandTotal: kacaFooterGrandTotal
                            }
                        }
                    }
                };
                imported.push(entry);
            }

            // Merge strategy: append imported at the beginning (newer first)
            inputLogHistory = [...imported, ...inputLogHistory];
            // No limit on log entries - keep all data

            saveInputLogToStorage();
            renderInputLog();
            updateKacaSuggestionsFromLogs();
            
            // Process stok transactions from imported log entries
            processStokFromImportedLogs(imported);
        }

        // Simple CSV line parser handling quoted fields
        // Auto-detect separator: semicolon (;) or comma (,)
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            // Auto-detect separator: check if line contains semicolon (more common in Excel Indonesia)
            // If both exist, prefer semicolon
            const hasSemicolon = line.includes(';');
            const hasComma = line.includes(',');
            const separator = (hasSemicolon && !hasComma) || (hasSemicolon && hasComma) ? ';' : ',';
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    if (inQuotes && line[i+1] === '"') { // escaped quote
                        current += '"';
                        i++;
                    } else {
                        inQuotes = !inQuotes;
                    }
                } else if (char === separator && !inQuotes) {
                    result.push(current);
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current);
            return result;
        }

        // Maintain unique suggestions for Jenis Kaca and Ukuran from stok data (case-insensitive, trimmed)
        function updateKacaSuggestionsFromLogs() {
            try {
                const jenisMap = new Map(); // key: normalized, value: display or {display, sisa, harga}
                const ukuranMap = new Map(); // key: normalized, value: display or {display, sisa, harga}

                const normalize = (s) => String(s || '')
                    .toLowerCase()
                    .replace(/\s+/g, ' ')
                    .trim();

                // Get data from stokData (prioritize stok data with available stock)
                let stokDataArray = [];
                if (typeof window.stokData !== 'undefined' && Array.isArray(window.stokData)) {
                    stokDataArray = window.stokData;
                } else if (typeof stokData !== 'undefined' && Array.isArray(stokData)) {
                    stokDataArray = stokData;
                }

                if (stokDataArray.length > 0) {
                    // Group data by Tebal Kaca, Ukuran Kaca, dan Harga Beli
                    const groupedData = {};
                    
                    stokDataArray.forEach((entry) => {
                        if (!entry.tebal || !entry.ukuran) return;
                        
                        const hargaKey = entry.harga !== undefined && entry.harga > 0 ? entry.harga : 'noharga';
                        const key = `${entry.tebal}-${entry.ukuran}-${hargaKey}`;

                        if (!groupedData[key]) {
                            groupedData[key] = { 
                                tebal: entry.tebal, 
                                ukuran: entry.ukuran, 
                                hargaMasuk: hargaKey !== 'noharga' ? entry.harga : undefined,
                                totalMasuk: 0, 
                                totalKeluar: 0, 
                                totalSisa: 0 
                            };
                        }

                        if (
                            groupedData[key].hargaMasuk === undefined &&
                            entry.masuk > 0 &&
                            entry.harga !== undefined &&
                            entry.harga > 0
                        ) {
                            groupedData[key].hargaMasuk = entry.harga;
                        }

                        groupedData[key].totalMasuk += entry.masuk;
                        groupedData[key].totalKeluar += entry.keluar;
                        groupedData[key].totalSisa = groupedData[key].totalMasuk - groupedData[key].totalKeluar;
                    });

                    // Process grouped data to build suggestions (only items with stock > 0)
                    // Store data with stock info for jenis kaca and ukuran
                    const jenisDataMap = new Map(); // key: normalized, value: { display, sisa, harga }
                    const ukuranDataMap = new Map(); // key: normalized, value: { display, sisa, harga }
                    
                    for (const key in groupedData) {
                        const data = groupedData[key];
                        if (data.totalSisa > 0) {
                            const jenisNorm = normalize(data.tebal);
                            const ukuranNorm = normalize(data.ukuran);
                            
                            // For jenis kaca: combine all ukuran and stock info
                            if (jenisNorm) {
                                if (!jenisDataMap.has(jenisNorm)) {
                                    jenisDataMap.set(jenisNorm, {
                                        display: data.tebal,
                                        sisa: 0,
                                        harga: []
                                    });
                                }
                                const jenisInfo = jenisDataMap.get(jenisNorm);
                                jenisInfo.sisa += data.totalSisa;
                                if (data.hargaMasuk && data.hargaMasuk > 0 && !jenisInfo.harga.includes(data.hargaMasuk)) {
                                    jenisInfo.harga.push(data.hargaMasuk);
                                }
                            }
                            
                            // For ukuran: keep stocks with different harga separate - don't combine them
                            if (ukuranNorm) {
                                const hargaKey = data.hargaMasuk !== undefined && data.hargaMasuk > 0 ? data.hargaMasuk : 'noharga';
                                const uniqueKey = `${ukuranNorm}-harga${hargaKey}`;
                                
                                if (!ukuranDataMap.has(uniqueKey)) {
                                    ukuranDataMap.set(uniqueKey, {
                                        display: data.ukuran,
                                        sisa: 0,
                                        harga: []
                                    });
                                }
                                const ukuranInfo = ukuranDataMap.get(uniqueKey);
                                ukuranInfo.sisa += data.totalSisa;
                                if (data.hargaMasuk && data.hargaMasuk > 0 && !ukuranInfo.harga.includes(data.hargaMasuk)) {
                                    ukuranInfo.harga.push(data.hargaMasuk);
                                }
                            }
                        }
                    }
                    
                    // Build jenis and ukuran maps with stock info
                    jenisDataMap.forEach((info, norm) => {
                        jenisMap.set(norm, info);
                    });
                    
                    ukuranDataMap.forEach((info, norm) => {
                        ukuranMap.set(norm, info);
                    });
                }

                // Fallback to log history if stokData not available or empty
                if (jenisMap.size === 0 && ukuranMap.size === 0) {
                    (inputLogHistory || []).forEach(entry => {
                        const rows = Array.isArray(entry.data?.kacaData) ? entry.data.kacaData : (entry.data?.kacaData?.rows || []);
                        rows.forEach(row => {
                            if (row.jenisKaca) {
                                const disp = String(row.jenisKaca).trim();
                                const key = normalize(disp);
                                if (key && !jenisMap.has(key)) jenisMap.set(key, disp);
                            }
                            if (row.ukuran) {
                                const disp = String(row.ukuran).trim();
                                const key = normalize(disp);
                                if (key && !ukuranMap.has(key)) ukuranMap.set(key, disp);
                            }
                        });
                    });
                }

                const sortCI = (a, b) => {
                    const aVal = typeof a === 'string' ? a : a.display;
                    const bVal = typeof b === 'string' ? b : b.display;
                    return aVal.toLowerCase().localeCompare(bVal.toLowerCase());
                };
                
                // Build option HTML with stock info
                const buildOptionHTML = (item) => {
                    if (typeof item === 'string') {
                        // Fallback from log history (no stock info)
                        return `<option value="${item.replace(/"/g, '&quot;')}"></option>`;
                    } else {
                        // From stokData (with stock info)
                        let stockInfo = '';
                        
                        if (item.sisa > 0) {
                            if (item.harga && item.harga.length > 0) {
                                const hargaText = item.harga.length === 1 
                                    ? `Rp ${item.harga[0].toLocaleString('id-ID')}`
                                    : item.harga.map(h => `Rp ${h.toLocaleString('id-ID')}`).join(' / ');
                                stockInfo = `Harga: ${hargaText}, Sisa: ${item.sisa.toLocaleString('id-ID')}`;
                            } else {
                                stockInfo = `Sisa: ${item.sisa.toLocaleString('id-ID')}`;
                            }
                        }
                        
                        // Value is jenis kaca (baris pertama), text content is stockInfo only (baris kedua)
                        return `<option value="${item.display.replace(/"/g, '&quot;')}" data-stock="${item.sisa}" data-harga="${item.harga ? item.harga.join(',') : ''}">${stockInfo ? stockInfo.replace(/"/g, '&quot;') : item.display.replace(/"/g, '&quot;')}</option>`;
                    }
                };
                
                const jenisValues = Array.from(jenisMap.values()).sort(sortCI);
                const ukuranValues = Array.from(ukuranMap.values()).sort(sortCI);

                const jenisList = document.getElementById('datalistJenisKaca');
                const ukuranList = document.getElementById('datalistUkuran');
                if (jenisList) jenisList.innerHTML = jenisValues.map(buildOptionHTML).join('');
                if (ukuranList) ukuranList.innerHTML = ukuranValues.map(buildOptionHTML).join('');
            } catch (e) {
                console.warn('Failed updating kaca suggestions:', e);
            }
        }

        // Function to update supir and noKendaraan suggestions from input log history
        function updateSupirDanKendaraanSuggestions() {
            try {
                const supirSet = new Set();
                const noKendaraanSet = new Set();

                // Collect unique values from inputLogHistory
                (inputLogHistory || []).forEach(entry => {
                    const data = entry.data || {};
                    if (data.supir) {
                        const supirValue = String(data.supir).trim();
                        if (supirValue) {
                            supirSet.add(supirValue);
                        }
                    }
                    if (data.noKendaraan) {
                        const noKendaraanValue = String(data.noKendaraan).trim();
                        if (noKendaraanValue) {
                            noKendaraanSet.add(noKendaraanValue);
                        }
                    }
                });

                // Sort and create options
                const supirValues = Array.from(supirSet).sort((a, b) => 
                    a.toLowerCase().localeCompare(b.toLowerCase())
                );
                const noKendaraanValues = Array.from(noKendaraanSet).sort((a, b) => 
                    a.toLowerCase().localeCompare(b.toLowerCase())
                );

                // Update datalists
                const supirList = document.getElementById('datalistSupir');
                const noKendaraanList = document.getElementById('datalistNoKendaraan');
                
                if (supirList) {
                    supirList.innerHTML = supirValues.map(value => 
                        `<option value="${value.replace(/"/g, '&quot;')}"></option>`
                    ).join('');
                }
                
                if (noKendaraanList) {
                    noKendaraanList.innerHTML = noKendaraanValues.map(value => 
                        `<option value="${value.replace(/"/g, '&quot;')}"></option>`
                    ).join('');
                }
            } catch (e) {
                // Silently handle errors
            }
        }

        // Function to update ukuran dropdown based on selected jenis kaca
        function updateUkuranByJenisKaca(jenisKaca, ukuranInput) {
            try {
                if (!jenisKaca || !jenisKaca.trim()) {
                    // If jenis kaca is empty, show all ukuran
                    updateKacaSuggestionsFromLogs();
                    return;
                }

                const normalize = (s) => String(s || '')
                    .toLowerCase()
                    .replace(/\s+/g, ' ')
                    .trim();

                const jenisKacaNorm = normalize(jenisKaca);
                const ukuranMap = new Map(); // key: normalized, value: { display, sisa, harga }

                // Get data from stokData
                let stokDataArray = [];
                if (typeof window.stokData !== 'undefined' && Array.isArray(window.stokData)) {
                    stokDataArray = window.stokData;
                } else if (typeof stokData !== 'undefined' && Array.isArray(stokData)) {
                    stokDataArray = stokData;
                }

                if (stokDataArray.length > 0) {
                    // Group data by Tebal Kaca, Ukuran Kaca, dan Harga Beli
                    const groupedData = {};
                    
                    stokDataArray.forEach((entry) => {
                        if (!entry.tebal || !entry.ukuran) return;
                        
                        // Filter by jenis kaca
                        const entryJenisNorm = normalize(entry.tebal);
                        if (entryJenisNorm !== jenisKacaNorm) return;
                        
                        const hargaKey = entry.harga !== undefined && entry.harga > 0 ? entry.harga : 'noharga';
                        const key = `${entry.tebal}-${entry.ukuran}-${hargaKey}`;

                        if (!groupedData[key]) {
                            groupedData[key] = { 
                                tebal: entry.tebal, 
                                ukuran: entry.ukuran, 
                                hargaMasuk: hargaKey !== 'noharga' ? entry.harga : undefined,
                                totalMasuk: 0, 
                                totalKeluar: 0, 
                                totalSisa: 0 
                            };
                        }

                        if (
                            groupedData[key].hargaMasuk === undefined &&
                            entry.masuk > 0 &&
                            entry.harga !== undefined &&
                            entry.harga > 0
                        ) {
                            groupedData[key].hargaMasuk = entry.harga;
                        }

                        groupedData[key].totalMasuk += entry.masuk;
                        groupedData[key].totalKeluar += entry.keluar;
                        groupedData[key].totalSisa = groupedData[key].totalMasuk - groupedData[key].totalKeluar;
                    });

                    // Process grouped data to build ukuran suggestions (only items with stock > 0)
                    // Keep stocks with different harga separate - don't combine them
                    const ukuranEntries = [];
                    
                    for (const key in groupedData) {
                        const data = groupedData[key];
                        if (data.totalSisa > 0) {
                            // Create separate entry for each ukuran+harga combination
                            ukuranEntries.push({
                                display: data.ukuran,
                                sisa: data.totalSisa,
                                harga: data.hargaMasuk !== undefined && data.hargaMasuk > 0 ? [data.hargaMasuk] : []
                            });
                        }
                    }
                    
                    // Build ukuran map - use unique key for each ukuran+harga combination
                    ukuranEntries.forEach((entry) => {
                        const ukuranNorm = normalize(entry.display);
                        const hargaKey = entry.harga.length > 0 ? entry.harga[0] : 'noharga';
                        // Create unique key that includes both ukuran and harga
                        const uniqueKey = `${ukuranNorm}-harga${hargaKey}`;
                        
                        // Store entry with unique key to keep stocks with different harga separate
                        ukuranMap.set(uniqueKey, entry);
                    });
                }

                // Fallback to log history if stokData not available or empty
                if (ukuranMap.size === 0) {
                    (inputLogHistory || []).forEach(entry => {
                        const rows = Array.isArray(entry.data?.kacaData) ? entry.data.kacaData : (entry.data?.kacaData?.rows || []);
                        rows.forEach(row => {
                            if (row.jenisKaca && row.ukuran) {
                                const rowJenisNorm = normalize(row.jenisKaca);
                                if (rowJenisNorm === jenisKacaNorm) {
                                    const disp = String(row.ukuran).trim();
                                    const key = normalize(disp);
                                    if (key && !ukuranMap.has(key)) {
                                        ukuranMap.set(key, disp);
                                    }
                                }
                            }
                        });
                    });
                }

                // Build option HTML with stock info
                const sortCI = (a, b) => {
                    const aVal = typeof a === 'string' ? a : a.display;
                    const bVal = typeof b === 'string' ? b : b.display;
                    return aVal.toLowerCase().localeCompare(bVal.toLowerCase());
                };

                const ukuranValues = Array.from(ukuranMap.values()).sort(sortCI);
                
                // Calculate display counts to identify duplicates
                const displayCounts = {};
                ukuranValues.forEach(item => {
                    const display = typeof item === 'string' ? item : item.display;
                    displayCounts[display] = (displayCounts[display] || 0) + 1;
                });

                const ukuranList = document.getElementById('datalistUkuran');
                
                const buildOptionHTML = (item) => {
                    let valueText = typeof item === 'string' ? item : item.display;
                    let hasPriceInValue = false;
                    
                    // Append price to value if there are duplicates with same display
                    if (displayCounts[valueText] > 1 && typeof item !== 'string' && item.harga && item.harga.length > 0) {
                        const hargaFormatted = item.harga[0].toLocaleString('id-ID');
                        valueText = `${valueText} (Rp ${hargaFormatted})`;
                        hasPriceInValue = true;
                    }

                    if (typeof item === 'string') {
                        return `<option value="${valueText.replace(/"/g, '&quot;')}"></option>`;
                    } else {
                        let stockInfo = '';
                        
                        if (item.sisa > 0) {
                            if (item.harga && item.harga.length > 0) {
                                // If price is already in value (duplicate case), don't show it in label
                                if (hasPriceInValue) {
                                    stockInfo = `Sisa: ${item.sisa.toLocaleString('id-ID')}`;
                                } else {
                                    const hargaText = item.harga.length === 1 
                                        ? `Rp ${item.harga[0].toLocaleString('id-ID')}`
                                        : item.harga.map(h => `Rp ${h.toLocaleString('id-ID')}`).join(' / ');
                                    stockInfo = `Harga: ${hargaText}, Sisa: ${item.sisa.toLocaleString('id-ID')}`;
                                }
                            } else {
                                stockInfo = `Sisa: ${item.sisa.toLocaleString('id-ID')}`;
                            }
                        }
                        
                        // Value includes price if duplicate, text content is stockInfo only
                        return `<option value="${valueText.replace(/"/g, '&quot;')}" data-stock="${item.sisa}" data-harga="${item.harga ? item.harga.join(',') : ''}">${stockInfo ? stockInfo.replace(/"/g, '&quot;') : item.display.replace(/"/g, '&quot;')}</option>`;
                    }
                };

                if (ukuranList) {
                    // Always update datalist, but prevent dropdown from showing if value was just selected
                    ukuranList.innerHTML = ukuranValues.map(buildOptionHTML).join('');
                    
                    // After updating datalist, trigger harga update for all ukuran inputs with values
                    // This ensures harga is refreshed when datalist changes
                    if (ukuranInput) {
                        requestAnimationFrame(() => {
                            // Trigger update for the specific input that triggered this update
                            if (ukuranInput.value.trim()) {
                                // Find the updateHargaFromSelectedUkuran function in the input's scope
                                // We'll trigger it via a custom event or direct call if available
                                const event = new CustomEvent('datalistUpdated', { bubbles: true });
                                ukuranInput.dispatchEvent(event);
                            }
                        });
                    }
                }
            } catch (e) {
                console.warn('Failed updating ukuran by jenis kaca:', e);
            }
        }

        // Removed testLogKacaData (not used anymore)

        // Make test function globally available
        // Removed window.testLogKacaData binding

        // Simple test function to verify log kaca data
        // Removed quickTestLogKaca (not used anymore)

        // Make quick test function globally available
        // Removed window.quickTestLogKaca binding

        // Test function to verify auto-fill kaca data from log
        function testAutoFillKacaData() {
            console.log('🧪 Testing Auto-Fill Kaca Data from Log...');
            
            // Check if there are any log entries
            if (inputLogHistory.length === 0) {
                console.log('❌ No log entries found. Please save a log first.');
                return;
            }
            
            // Get the first log entry
            const firstLog = inputLogHistory[0];
            console.log('📊 First log entry:', firstLog);
            
            // Check if it has kaca data
            if (!firstLog.data.kacaData) {
                console.log('❌ No kacaData found in log entry');
                return;
            }
            
            console.log('✅ Kaca data found in log entry:', firstLog.data.kacaData);
            
            // Test the auto-fill function
            console.log('🔄 Testing auto-fill function...');
            
            // Clear current form first
            document.getElementById('namaToko').value = '';
            document.getElementById('alamat').value = '';
            document.getElementById('tanggal').value = '';
            document.getElementById('nomorSJ').value = '';
            document.getElementById('supir').value = '';
            document.getElementById('noKendaraan').value = '';
            
            // Clear kaca table
            const tbody = document.getElementById('kacaTableBody');
            if (tbody) {
                tbody.innerHTML = '';
            }
            
            // Clear footer inputs
            const contInput = document.querySelector('.cont-input');
            const sealInput = document.querySelector('.seal-input');
            if (contInput) contInput.value = '';
            if (sealInput) sealInput.value = '';
            
            console.log('🧹 Form cleared for testing');
            
            // Now test the auto-fill
            setTimeout(() => {
                console.log('🔄 Calling loadInputFromLog(0)...');
                loadInputFromLog(0);
                
                // Check results after a delay
                setTimeout(() => {
                    console.log('🔍 Checking auto-fill results...');
                    
                    // Check form fields
                    const namaToko = document.getElementById('namaToko').value;
                    const alamat = document.getElementById('alamat').value;
                    const tanggal = document.getElementById('tanggal').value;
                    const nomorSJ = document.getElementById('nomorSJ').value;
                    const supir = document.getElementById('supir').value;
                    const noKendaraan = document.getElementById('noKendaraan').value;
                    
                    console.log('📝 Form fields filled:', {
                        namaToko: namaToko || 'empty',
                        alamat: alamat || 'empty',
                        tanggal: tanggal || 'empty',
                        nomorSJ: nomorSJ || 'empty',
                        supir: supir || 'empty',
                        noKendaraan: noKendaraan || 'empty'
                    });
                    
                    // Check kaca table
                    const kacaRows = document.querySelectorAll('#kacaTableBody tr');
                    console.log('📊 Kaca table rows after auto-fill:', kacaRows.length);
                    
                    if (kacaRows.length > 0) {
                        console.log('✅ Kaca data auto-filled successfully');
                        
                        // Check first row data
                        const firstRow = kacaRows[0];
                        const jenisKaca = firstRow.querySelector('.jenis-kaca')?.value || '';
                        const pwd = firstRow.querySelector('.pwd')?.value || '';
                        const noDo = firstRow.querySelector('.no-do')?.value || '';
                        const ukuran = firstRow.querySelector('.ukuran')?.value || '';
                        const box = firstRow.querySelector('.box')?.value || '';
                        const lbr = firstRow.querySelector('.lbr')?.value || '';
                        const totalLbr = firstRow.querySelector('.total-lbr-input')?.value || '';
                        
                        console.log('🔍 First kaca row data:', {
                            jenisKaca: jenisKaca || 'empty',
                            pwd: pwd || 'empty',
                            noDo: noDo || 'empty',
                            ukuran: ukuran || 'empty',
                            box: box || 'empty',
                            lbr: lbr || 'empty',
                            totalLbr: totalLbr || 'empty'
                        });
                    } else {
                        console.log('❌ No kaca rows found after auto-fill');
                    }
                    
                    // Check footer data
                    const contValue = contInput ? contInput.value : '';
                    const sealValue = sealInput ? sealInput.value : '';
                    
                    console.log('📋 Footer data after auto-fill:', {
                        cont: contValue || 'empty',
                        seal: sealValue || 'empty'
                    });
                    
                    if (contValue || sealValue) {
                        console.log('✅ Footer data auto-filled successfully');
                    } else {
                        console.log('ℹ️ No footer data to auto-fill');
                    }
                    
                }, 1000);
                
            }, 500);
            
            console.log('🧪 Auto-fill test completed');
        }

        // Make test function globally available
        window.testAutoFillKacaData = testAutoFillKacaData;

        // Debug function to check auto-fill issue
        function debugAutoFillIssue() {
            console.log('🐛 Debugging Auto-Fill Issue...');
            
            // Check if there are log entries
            console.log('📊 Number of log entries:', inputLogHistory.length);
            
            if (inputLogHistory.length > 0) {
                const firstLog = inputLogHistory[0];
                console.log('📋 First log entry structure:', firstLog);
                
                // Check kaca data structure
                if (firstLog.data.kacaData) {
                    console.log('✅ kacaData exists in log entry');
                    console.log('📊 kacaData type:', typeof firstLog.data.kacaData);
                    console.log('📊 kacaData is array:', Array.isArray(firstLog.data.kacaData));
                    console.log('📊 kacaData content:', firstLog.data.kacaData);
                    
                    if (Array.isArray(firstLog.data.kacaData)) {
                        console.log('📊 Array length:', firstLog.data.kacaData.length);
                    } else if (firstLog.data.kacaData.rows) {
                        console.log('📊 Rows length:', firstLog.data.kacaData.rows.length);
                        console.log('📊 Footer data:', firstLog.data.kacaData.footer);
                    }
                } else {
                    console.log('❌ No kacaData in log entry');
                }
                
                // Test the condition logic
                const kacaData = firstLog.data.kacaData;
                if (kacaData) {
                    const hasData = Array.isArray(kacaData) ? 
                        kacaData.length > 0 : 
                        (kacaData.rows && kacaData.rows.length > 0);
                    
                    console.log('🔍 Condition check result:', hasData);
                    console.log('🔍 Array.isArray(kacaData):', Array.isArray(kacaData));
                    
                    if (Array.isArray(kacaData)) {
                        console.log('🔍 kacaData.length > 0:', kacaData.length > 0);
                    } else {
                        console.log('🔍 kacaData.rows exists:', !!kacaData.rows);
                        console.log('🔍 kacaData.rows.length > 0:', kacaData.rows && kacaData.rows.length > 0);
                    }
                }
                
            } else {
                console.log('❌ No log entries found');
            }
            
            // Check if loadKacaDataFromLog function exists
            console.log('🔍 loadKacaDataFromLog function exists:', typeof loadKacaDataFromLog === 'function');
            
            // Check if kaca table exists
            const tbody = document.getElementById('kacaTableBody');
            console.log('🔍 kacaTableBody exists:', !!tbody);
            
            console.log('🐛 Debug completed');
        }

        // Make debug function globally available
        window.debugAutoFillIssue = debugAutoFillIssue;

        // Function to toggle log details view
        function toggleLogDetails(index) {
            const defaultView = document.getElementById(`log-default-${index}`);
            const detailedView = document.getElementById(`log-detailed-${index}`);
            const logEntry = defaultView.closest('.log-entry');
            const toggleIcon = logEntry.querySelector('.log-toggle-icon');
            
            if (detailedView.style.display === 'none') {
                // Show detailed view
                defaultView.style.display = 'none';
                detailedView.style.display = 'block';
                toggleIcon.textContent = '📋';
                toggleIcon.style.transform = 'rotate(180deg)';
            } else {
                // Show default view
                defaultView.style.display = 'block';
                detailedView.style.display = 'none';
                toggleIcon.textContent = '📋';
                toggleIcon.style.transform = 'rotate(0deg)';
            }
        }

        // Helper: find log index by unique id
        function findLogIndexById(logId) {
            return inputLogHistory.findIndex(entry => entry && entry.id === logId);
        }

        // Toggle by id (used after search rendering)
        function toggleLogDetailsById(logId) {
            const defaultView = document.getElementById(`log-default-${logId}`);
            const detailedView = document.getElementById(`log-detailed-${logId}`);
            if (!defaultView || !detailedView) return;
            const logEntry = defaultView.closest('.log-entry');
            const toggleIcon = logEntry ? logEntry.querySelector('.log-toggle-icon') : null;
            
            if (detailedView.style.display === 'none') {
                defaultView.style.display = 'none';
                detailedView.style.display = 'block';
                if (toggleIcon) {
                    toggleIcon.textContent = '📋';
                    toggleIcon.style.transform = 'rotate(180deg)';
                }
            } else {
                defaultView.style.display = 'block';
                detailedView.style.display = 'none';
                if (toggleIcon) {
                    toggleIcon.textContent = '📋';
                    toggleIcon.style.transform = 'rotate(0deg)';
                }
            }
        }

        // Wrappers by id to keep button actions working after filtering
        function loadInputFromLogById(logId) {
            const idx = findLogIndexById(logId);
            if (idx >= 0) loadInputFromLog(idx);
        }
        function editLogEntryById(logId) {
            const idx = findLogIndexById(logId);
            if (idx >= 0) editLogEntry(idx);
        }
        async function deleteLogEntryById(logId) {
            const idx = findLogIndexById(logId);
            if (idx >= 0) await deleteLogEntry(idx);
        }

        // Test function to verify new log display
        function testNewLogDisplay() {
            console.log('🧪 Testing New Log Display...');
            
            // Check if there are log entries
            if (inputLogHistory.length === 0) {
                console.log('❌ No log entries found. Please save a log first.');
                return;
            }
            
            console.log('✅ Log entries found:', inputLogHistory.length);
            
            // Check if new log structure exists
            const logEntries = document.querySelectorAll('.log-entry');
            console.log('📊 Number of log entries in DOM:', logEntries.length);
            
            if (logEntries.length > 0) {
                const firstLogEntry = logEntries[0];
                
                // Check for default view
                const defaultView = firstLogEntry.querySelector('.log-content-default');
                if (defaultView) {
                    console.log('✅ Default view found');
                    console.log('📊 Default view display:', defaultView.style.display);
                } else {
                    console.log('❌ Default view not found');
                }
                
                // Check for detailed view
                const detailedView = firstLogEntry.querySelector('.log-content-detailed');
                if (detailedView) {
                    console.log('✅ Detailed view found');
                    console.log('📊 Detailed view display:', detailedView.style.display);
                } else {
                    console.log('❌ Detailed view not found');
                }
                
                // Check for toggle icon
                const toggleIcon = firstLogEntry.querySelector('.log-toggle-icon');
                if (toggleIcon) {
                    console.log('✅ Toggle icon found');
                    console.log('📊 Toggle icon text:', toggleIcon.textContent);
                } else {
                    console.log('❌ Toggle icon not found');
                }
                
                // Check for load button in detailed view
                const loadButton = firstLogEntry.querySelector('.btn-load-data');
                if (loadButton) {
                    console.log('✅ Load button found in detailed view');
                } else {
                    console.log('❌ Load button not found');
                }
                
                // Test toggle functionality
                console.log('🔄 Testing toggle functionality...');
                const logIndex = 0; // Test with first log entry
                
                // Get initial state
                const initialDefaultDisplay = defaultView.style.display;
                const initialDetailedDisplay = detailedView.style.display;
                
                console.log('📊 Initial state:', {
                    default: initialDefaultDisplay,
                    detailed: initialDetailedDisplay
                });
                
                // Test toggle
                toggleLogDetails(logIndex);
                
                setTimeout(() => {
                    const afterToggleDefaultDisplay = defaultView.style.display;
                    const afterToggleDetailedDisplay = detailedView.style.display;
                    
                    console.log('📊 After toggle state:', {
                        default: afterToggleDefaultDisplay,
                        detailed: afterToggleDetailedDisplay
                    });
                    
                    if (afterToggleDefaultDisplay !== initialDefaultDisplay || 
                        afterToggleDetailedDisplay !== initialDetailedDisplay) {
                        console.log('✅ Toggle functionality working');
                    } else {
                        console.log('❌ Toggle functionality not working');
                    }
                    
                    // Toggle back
                    setTimeout(() => {
                        toggleLogDetails(logIndex);
                        console.log('🔄 Toggled back to original state');
                    }, 500);
                    
                }, 100);
                
            } else {
                console.log('❌ No log entries found in DOM');
            }
            
            console.log('🧪 New log display test completed');
        }

        // Make test function globally available
        window.testNewLogDisplay = testNewLogDisplay;

        // Test function to verify compact log display
        function testCompactLogDisplay() {
            console.log('🧪 Testing Compact Log Display...');
            
            // Check if there are log entries
            if (inputLogHistory.length === 0) {
                console.log('❌ No log entries found. Please save a log first.');
                return;
            }
            
            console.log('✅ Log entries found:', inputLogHistory.length);
            
            // Check if new compact structure exists
            const logEntries = document.querySelectorAll('.log-entry');
            console.log('📊 Number of log entries in DOM:', logEntries.length);
            
            if (logEntries.length > 0) {
                const firstLogEntry = logEntries[0];
                
                // Check for compact line
                const compactLine = firstLogEntry.querySelector('.log-compact-line');
                if (compactLine) {
                    console.log('✅ Compact line found');
                    
                    // Check compact items
                    const compactItems = compactLine.querySelectorAll('.log-compact-item');
                    console.log('📊 Number of compact items:', compactItems.length);
                    
                    compactItems.forEach((item, index) => {
                        const label = item.querySelector('.log-compact-label');
                        const value = item.querySelector('.log-compact-value');
                        
                        console.log(`📋 Compact item ${index + 1}:`, {
                            label: label ? label.textContent : 'not found',
                            value: value ? value.textContent : 'not found'
                        });
                    });
                    
                    // Check separators
                    const separators = compactLine.querySelectorAll('.log-compact-separator');
                    console.log('📊 Number of separators:', separators.length);
                    
                } else {
                    console.log('❌ Compact line not found');
                }
                
                // Check for default view
                const defaultView = firstLogEntry.querySelector('.log-content-default');
                if (defaultView) {
                    console.log('✅ Default view found');
                    console.log('📊 Default view display:', defaultView.style.display);
                } else {
                    console.log('❌ Default view not found');
                }
                
                // Check for detailed view
                const detailedView = firstLogEntry.querySelector('.log-content-detailed');
                if (detailedView) {
                    console.log('✅ Detailed view found');
                    console.log('📊 Detailed view display:', detailedView.style.display);
                } else {
                    console.log('❌ Detailed view not found');
                }
                
                // Test compact layout
                console.log('🔄 Testing compact layout...');
                
                // Check if layout is horizontal
                const computedStyle = window.getComputedStyle(compactLine);
                const flexDirection = computedStyle.flexDirection;
                console.log('📊 Flex direction:', flexDirection);
                
                if (flexDirection === 'row') {
                    console.log('✅ Compact layout is horizontal (desktop)');
                } else if (flexDirection === 'column') {
                    console.log('✅ Compact layout is vertical (mobile)');
                } else {
                    console.log('❌ Unexpected flex direction:', flexDirection);
                }
                
                // Test text overflow
                const compactValues = compactLine.querySelectorAll('.log-compact-value');
                compactValues.forEach((value, index) => {
                    const computedStyle = window.getComputedStyle(value);
                    const textOverflow = computedStyle.textOverflow;
                    const overflow = computedStyle.overflow;
                    const whiteSpace = computedStyle.whiteSpace;
                    
                    console.log(`📊 Text overflow for value ${index + 1}:`, {
                        textOverflow: textOverflow,
                        overflow: overflow,
                        whiteSpace: whiteSpace
                    });
                });
                
            } else {
                console.log('❌ No log entries found in DOM');
            }
            
            console.log('🧪 Compact log display test completed');
        }

        // Make test function globally available
        window.testCompactLogDisplay = testCompactLogDisplay;

        // Test function to verify container height matching
        function testContainerHeightMatching() {
            console.log('🧪 Testing Container Height Matching...');
            
            // Get container elements
            const leftSection = document.querySelector('.left-section');
            const rightSection = document.querySelector('.right-section');
            const mainLayout = document.querySelector('.main-layout');
            
            if (!leftSection || !rightSection || !mainLayout) {
                console.log('❌ Container elements not found');
                return;
            }
            
            console.log('✅ Container elements found');
            
            // Get computed styles
            const leftHeight = leftSection.offsetHeight;
            const rightHeight = rightSection.offsetHeight;
            const mainLayoutHeight = mainLayout.offsetHeight;
            
            console.log('📊 Container heights:', {
                leftSection: leftHeight + 'px',
                rightSection: rightHeight + 'px',
                mainLayout: mainLayoutHeight + 'px'
            });
            
            // Check if heights match
            const heightDifference = Math.abs(leftHeight - rightHeight);
            const tolerance = 10; // 10px tolerance for minor differences
            
            if (heightDifference <= tolerance) {
                console.log('✅ Container heights match (within tolerance)');
                console.log('📊 Height difference:', heightDifference + 'px');
            } else {
                console.log('❌ Container heights do not match');
                console.log('📊 Height difference:', heightDifference + 'px');
            }
            
            // Check flex properties
            const leftComputedStyle = window.getComputedStyle(leftSection);
            const rightComputedStyle = window.getComputedStyle(rightSection);
            const mainLayoutComputedStyle = window.getComputedStyle(mainLayout);
            
            console.log('📊 Flex properties:', {
                mainLayoutAlignItems: mainLayoutComputedStyle.alignItems,
                leftSectionFlex: leftComputedStyle.flex,
                rightSectionFlex: rightComputedStyle.flex,
                rightSectionDisplay: rightComputedStyle.display,
                rightSectionFlexDirection: rightComputedStyle.flexDirection
            });
            
            // Check if right section has flex column
            if (rightComputedStyle.display === 'flex' && rightComputedStyle.flexDirection === 'column') {
                console.log('✅ Right section has flex column layout');
            } else {
                console.log('❌ Right section does not have flex column layout');
            }
            
            // Check log container properties
            const logContainer = document.querySelector('.log-container');
            if (logContainer) {
                const logContainerComputedStyle = window.getComputedStyle(logContainer);
                console.log('📊 Log container properties:', {
                    flex: logContainerComputedStyle.flex,
                    minHeight: logContainerComputedStyle.minHeight,
                    overflowY: logContainerComputedStyle.overflowY
                });
            }
            
            // Check log actions properties
            const logActions = document.querySelector('.log-actions');
            if (logActions) {
                const logActionsComputedStyle = window.getComputedStyle(logActions);
                console.log('📊 Log actions properties:', {
                    marginTop: logActionsComputedStyle.marginTop,
                    flexShrink: logActionsComputedStyle.flexShrink
                });
            }
            
            // Test responsive behavior
            const isMobile = window.innerWidth <= 768;
            console.log('📱 Device type:', isMobile ? 'Mobile' : 'Desktop');
            
            if (isMobile) {
                console.log('📱 Mobile layout: Containers should stack vertically');
            } else {
                console.log('🖥️ Desktop layout: Containers should have matching heights');
            }
            
            console.log('🧪 Container height matching test completed');
        }

            // Make test function globally available
            window.testContainerHeightMatching = testContainerHeightMatching;

            // Toggle visibility of Log Input History section when header is clicked
            (function initLogHistoryToggle() {
                try {
                    const logHeader = document.querySelector('.right-section .log-header');
                    const logContainer = document.getElementById('inputLogContainer');
                    const logActions = document.querySelector('.right-section .log-actions');
                    const logHeaderActions = document.querySelector('.right-section .log-header-actions');
                    const rightSection = document.querySelector('.right-section');
                    if (!logHeader || !logContainer || !logActions) return;

                    // Keep log container always visible
                    logContainer.style.display = '';
                    logActions.style.display = 'flex';
                    logHeader.setAttribute('aria-expanded', 'true');
                    logHeader.style.marginBottom = '8px';
                    
                    // Keep header actions always visible
                    if (logHeaderActions) {
                        logHeaderActions.style.opacity = '1';
                    }
                } catch (error) {
                    console.error('Failed to initialize Log Input History toggle:', error);
                }
            })();

            // Toggle FAB for showing/hiding log action buttons
            function toggleLogFab(btn) {
                try {
                    const section = btn.closest('.right-section');
                    if (!section) return;
                    const isOpen = section.classList.toggle('log-fab-open');
                    // Optionally focus search when opening
                    if (isOpen) {
                        const search = section.querySelector('#logSearchInput');
                        if (search) search.focus();
                    }
                } catch (error) {
                    console.error('Failed to toggle log FAB:', error);
                }
            }

            // IndexedDB-backed persistence + auto-refresh for GitHub Pages (frontend-only)
            (function enhanceLogPersistenceAndRefresh() {
                try {
                    function openLogDB() {
                        return new Promise((resolve, reject) => {
                            const req = window.indexedDB.open('sj-logs-db', 1);
                            req.onupgradeneeded = () => {
                                const db = req.result;
                                if (!db.objectStoreNames.contains('kv')) {
                                    db.createObjectStore('kv', { keyPath: 'key' });
                                }
                            };
                            req.onsuccess = () => resolve(req.result);
                            req.onerror = () => reject(req.error);
                        });
                    }

                    async function idbSet(key, value) {
                        try {
                            const db = await openLogDB();
                            await new Promise((resolve, reject) => {
                                const tx = db.transaction('kv', 'readwrite');
                                tx.oncomplete = resolve;
                                tx.onerror = () => reject(tx.error);
                                tx.objectStore('kv').put({ key, value });
                            });
                            db.close();
                        } catch (e) {
                            console.warn('IDB set failed; continuing with localStorage only', e);
                        }
                    }

                    async function idbGet(key) {
                        try {
                            const db = await openLogDB();
                            const val = await new Promise((resolve, reject) => {
                                const tx = db.transaction('kv', 'readonly');
                                tx.onerror = () => reject(tx.error);
                                const req = tx.objectStore('kv').get(key);
                                req.onsuccess = () => resolve(req.result ? req.result.value : undefined);
                                req.onerror = () => reject(req.error);
                            });
                            db.close();
                            return val;
                        } catch (e) {
                            console.warn('IDB get failed; falling back to localStorage', e);
                            return undefined;
                        }
                    }

                    const originalLoad = typeof loadInputLogFromStorage === 'function' ? loadInputLogFromStorage : null;
                    const originalSave = typeof saveInputLogToStorage === 'function' ? saveInputLogToStorage : null;

                    window.loadInputLogFromStorage = async function() {
                        try {
                            const fromIDB = await idbGet('inputLogHistory');
                            if (Array.isArray(fromIDB)) {
                                inputLogHistory = fromIDB;
                                if (typeof renderInputLog === 'function') renderInputLog();
                                if (typeof updateKacaSuggestionsFromLogs === 'function') updateKacaSuggestionsFromLogs();
                                if (typeof updateSupirDanKendaraanSuggestions === 'function') updateSupirDanKendaraanSuggestions();
                                if (typeof window.refreshNomorSJWarningNow === 'function') window.refreshNomorSJWarningNow();
                                return;
                            }
                        } catch (e) {
                            console.warn('Load from IndexedDB failed, will try fallback', e);
                        }

                        if (originalLoad) {
                            try { originalLoad(); return; } catch (e) { console.warn('Original load failed', e); }
                        }
                        try {
                            const saved = (typeof storageManager !== 'undefined' && storageManager.load)
                                ? storageManager.load('inputLogHistory') : null;
                            if (saved) {
                                inputLogHistory = saved;
                                if (typeof renderInputLog === 'function') renderInputLog();
                                if (typeof updateSupirDanKendaraanSuggestions === 'function') updateSupirDanKendaraanSuggestions();
                            }
                        } catch (e) {
                            console.warn('Fallback localStorage load failed', e);
                        }
                    };

                    window.saveInputLogToStorage = function() {
                        try {
                            if (typeof storageManager !== 'undefined' && storageManager.save) {
                                storageManager.save('inputLogHistory', inputLogHistory);
                            }
                            if (typeof updateKacaSuggestionsFromLogs === 'function') updateKacaSuggestionsFromLogs();
                            if (typeof updateSupirDanKendaraanSuggestions === 'function') updateSupirDanKendaraanSuggestions();
                            if (typeof window.refreshNomorSJWarningNow === 'function') window.refreshNomorSJWarningNow();
                        } catch (e) {
                            console.warn('localStorage save fallback failed', e);
                        }
                        idbSet('inputLogHistory', inputLogHistory);
                        console.log('💾 Input log mirrored to IndexedDB:', inputLogHistory.length, 'entries');
                    };

                    window.addEventListener('storage', function(e) {
                        try {
                            if (e && e.key === 'inputLogHistory' && e.newValue) {
                                const parsed = JSON.parse(e.newValue);
                                if (Array.isArray(parsed)) {
                                    inputLogHistory = parsed;
                                    if (typeof renderInputLog === 'function') renderInputLog();
                                    if (typeof updateKacaSuggestionsFromLogs === 'function') updateKacaSuggestionsFromLogs();
                                    if (typeof window.refreshNomorSJWarningNow === 'function') window.refreshNomorSJWarningNow();
                                }
                            }
                        } catch (err) {
                            console.warn('Failed to process storage event', err);
                        }
                    });

                    if (document.readyState === 'loading') {
                        document.addEventListener('DOMContentLoaded', () => {
                            if (typeof window.loadInputLogFromStorage === 'function') window.loadInputLogFromStorage();
                        });
                    } else {
                        if (typeof window.loadInputLogFromStorage === 'function') window.loadInputLogFromStorage();
                    }
                } catch (error) {
                    console.warn('Enhance persistence/init failed; app will continue with existing storage only', error);
                }
            })();

            // UI: Tampilkan ukuran pemakaian storage (origin) dan ukuran log IndexedDB (perkiraan)
            (function initStorageUsageIndicator() {
                try {
                    function ensureBadgeEl() {
                        let badge = document.getElementById('storageUsageBadge');
                        if (badge) return badge;
                        badge = document.createElement('div');
                        badge.id = 'storageUsageBadge';
                        badge.textContent = 'Storage: ...';
                        badge.style.fontSize = '12px';
                        badge.style.color = '#555';
                        badge.style.padding = '4px 8px';
                        badge.style.border = '1px solid #e1e5e9';
                        badge.style.borderRadius = '12px';
                        badge.style.background = '#f8f9fa';
                        badge.style.display = 'inline-block';
                        badge.style.marginLeft = '8px';
                        badge.style.whiteSpace = 'nowrap';

                        // Place next to refresh button in kaca-header
                        const refreshBtn = document.querySelector('.btn-refresh-page');
                        if (refreshBtn && refreshBtn.parentNode) {
                            refreshBtn.parentNode.insertBefore(badge, refreshBtn.nextSibling);
                            return badge;
                        }
                        // Fallback: append to body
                        document.body.appendChild(badge);
                        return badge;
                    }

                    function formatBytes(bytes) {
                        if (!bytes && bytes !== 0) return '...';
                        if (bytes < 1024) return bytes + ' B';
                        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
                        if (bytes < 1024 * 1024 * 1024) return (bytes / 1024 / 1024).toFixed(2) + ' MB';
                        return (bytes / 1024 / 1024 / 1024).toFixed(2) + ' GB';
                    }

                    async function readLogRecordBytes() {
                        // Read IDB record and estimate bytes via Blob of JSON
                        try {
                            const open = (name, ver=1) => new Promise((res, rej) => {
                                const req = indexedDB.open(name, ver);
                                req.onsuccess = () => res(req.result);
                                req.onerror = () => rej(req.error);
                            });
                            const db = await open('sj-logs-db', 1);
                            const value = await new Promise((res, rej) => {
                                const tx = db.transaction('kv', 'readonly');
                                const req = tx.objectStore('kv').get('inputLogHistory');
                                req.onsuccess = () => res(req.result ? req.result.value : undefined);
                                req.onerror = () => rej(req.error);
                            });
                            db.close();
                            const json = JSON.stringify(value || []);
                            return new Blob([json]).size; // UTF-8 size approximation
                        } catch (_) {
                            return undefined;
                        }
                    }

                    async function measureAndRender() {
                        const badge = ensureBadgeEl();
                        try {
                            const est = await (navigator.storage && navigator.storage.estimate ? navigator.storage.estimate() : Promise.resolve({}));
                            const usage = est && typeof est.usage === 'number' ? est.usage : undefined;
                            const quota = est && typeof est.quota === 'number' ? est.quota : undefined;
                            const logBytes = await readLogRecordBytes();
                            
                            const parts = [];
                            if (usage !== undefined) parts.push('Used ' + formatBytes(usage));
                            if (quota !== undefined) {
                                const remaining = quota - (usage || 0);
                                const remainingPercent = quota > 0 ? Math.round(((quota - (usage || 0)) / quota) * 100) : 0;
                                parts.push('of ' + formatBytes(quota) + ' (' + remainingPercent + '% free)');
                            }
                            if (logBytes !== undefined) parts.push('(Log ' + formatBytes(logBytes) + ')');
                            
                            // Add color coding based on remaining space
                            if (quota && usage !== undefined) {
                                const remainingPercent = ((quota - usage) / quota) * 100;
                                if (remainingPercent < 10) {
                                    badge.style.background = '#ffebee';
                                    badge.style.borderColor = '#f44336';
                                    badge.style.color = '#c62828';
                                } else if (remainingPercent < 25) {
                                    badge.style.background = '#fff3e0';
                                    badge.style.borderColor = '#ff9800';
                                    badge.style.color = '#e65100';
                                } else {
                                    badge.style.background = '#f8f9fa';
                                    badge.style.borderColor = '#e1e5e9';
                                    badge.style.color = '#555';
                                }
                            }
                            
                            badge.textContent = parts.length ? parts.join(' ') : 'Storage: N/A';
                        } catch (e) {
                            const badgeEl = ensureBadgeEl();
                            badgeEl.textContent = 'Storage: N/A';
                            badgeEl.style.background = '#f8f9fa';
                            badgeEl.style.borderColor = '#e1e5e9';
                            badgeEl.style.color = '#555';
                        }
                    }

                    // Expose manual refresh
                    window.refreshStorageUsageDisplay = measureAndRender;

                    // Initial render after DOM ready
                    if (document.readyState === 'loading') {
                        document.addEventListener('DOMContentLoaded', measureAndRender);
                    } else {
                        measureAndRender();
                    }

                    // Periodic refresh
                    setInterval(measureAndRender, 10000);

                    // Refresh after localStorage cross-tab updates
                    window.addEventListener('storage', () => measureAndRender());
                } catch (err) {
                    // No-op if anything fails; UI remains unaffected
                }
            })();
    </script>


  <div class="container" style="padding-bottom: 10px;">
    <div class="header";>
      <h1>STOCK</h1>
    </div>
    
    <!-- Left Column for Form Input -->
    <div class="left-column">
      <button class="toggle-section-btn" id="toggleFormBtn">
        <span>Input Form</span>
        <i class="fas fa-chevron-down"></i>
      </button>
      <form id="stokForm">
        
        <input type="text" id="nama" placeholder="Nama Toko" required list="namaTokoList">
        <datalist id="namaTokoList"></datalist>
        <input type="date" id="tanggalStok" required>
        <script>
          // Set tanggal otomatis saat form dimuat - khusus untuk form stok
          (function() {
            function setTodayDate() {
              // Pastikan hanya mengambil input tanggal dari form stok, bukan Surat Jalan
              const stokForm = document.getElementById('stokForm');
              if (stokForm) {
                const tanggalInput = stokForm.querySelector('#tanggalStok');
                if (tanggalInput && !tanggalInput.value) {
                  // Set tanggal default ke hari ini - sama seperti Surat Jalan
                  tanggalInput.valueAsDate = new Date();
                  // Force trigger untuk memastikan browser update display
                  tanggalInput.dispatchEvent(new Event('input', { bubbles: true }));
                }
              }
            }
            
            // Try immediately
            setTodayDate();
            
            // Try when DOM is ready
            if (document.readyState === 'loading') {
              document.addEventListener('DOMContentLoaded', function() {
                setTimeout(setTodayDate, 50);
                setTimeout(setTodayDate, 200);
              });
            } else {
              setTimeout(setTodayDate, 50);
              setTimeout(setTodayDate, 200);
            }
            
            // Try after a longer delay as fallback
            setTimeout(setTodayDate, 500);
            setTimeout(setTodayDate, 1000);
          })();
        </script>
        <input type="text" id="nota" placeholder="No. Nota" required>
        
        <!-- Input Tebal Kaca dengan Satuan -->
        <div class="input-with-unit">
          <input type="text" id="tebal" placeholder="Jenis Kaca : [FL 2MM MGL]" min="1" required list="jenisKacaList">
          <datalist id="jenisKacaList"></datalist>
        </div>
        
        <input type="text" id="ukuran" placeholder="Ukuran Kaca : [60X48] [3660X2440]" required list="ukuranKacaList">
        <datalist id="ukuranKacaList"></datalist>
        <input type="number" id="harga" placeholder="Harga Beli" min="0" step="0.01" class="field-pembelian">
        <input type="number" id="hargaJual" placeholder="Harga Jual" min="0" step="0.01" class="field-penjualan" style="display: none;" disabled>
        <input type="number" id="masuk" placeholder="Kaca Masuk" min="0" oninput="toggleJumlahMasukKeluar()" class="field-pembelian">
        <input type="number" id="keluar" placeholder="Kaca Keluar" min="0" oninput="toggleJumlahMasukKeluar()" class="field-penjualan" style="display: none;" disabled>
        <button type="button" id="submitBtn" onclick="tambahData()">Tambah Data</button>
        <button type="button" id="cancelEditBtn" class="cancel-edit-btn action-btn" onclick="cancelEdit()" style="display: none;">Batal Edit</button>
      </form>
    </div>

    <!-- Right Column for Total Sisa per Jenis -->
    <div class="right-column">
      <div id="totalSisaContainer" class="total-sisa-container">
        <table id="jenisTable"style="margin-top:0px;">
          <thead>
            <tr>
              <th>Jenis Kaca</th>
              <th>Ukuran Kaca</th>
              <th>Harga</th>
              <th>Kaca Masuk</th>
              <th>Kaca Keluar</th>
              <th>Sisa Stok</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- Riwayat Stok -->
  <div class="container" style="flex-direction: column; padding-top: 0px;">
    <div class="right-column" style="width: 100%;">
      
      <!-- Status Bar -->
      <div id="statusBar" class="status-bar" style="display: none;"></div>
      
      <!-- Action Menu -->
      <div class="action-menu" style="padding-bottom: 5px;">
        <div class="action-group">
          <button class="action-btn export-btn" onclick="exportToExcel()">
            <i class="fas fa-file-excel"></i> Export Riwayat
          </button>
          <button class="action-btn export-btn" onclick="exportStock()">
            <i class="fas fa-file-excel"></i> Export Stock
          </button>
          <button class="action-btn clear-btn" onclick="clearData()">
            <i class="fas fa-trash"></i> Clear Data
          </button>
        </div>
        <!-- Search Box -->
        <div class="search-container" style="margin-left: 0px;">
          <div class="search-box">
            <i class="fas fa-search"></i>
            <input type="text" id="searchInput" placeholder="Cari data..." oninput="performSearch()">
            <button class="search-clear-btn" id="searchClearBtn" onclick="clearSearch()" style="display: none;">
              <i class="fas fa-times"></i>
            </button>
          </div>
        </div>
      </div>
      
      <div class="riwayat-stok-container">
        <table id="stokTable">
          <thead>
            <tr>
              <th>No</th>
              <th>Nama</th>
              <th>Tanggal</th>
              <th>Nota</th>
              <th>Jenis Kaca</th>
              <th>Ukuran</th>
              <th>Harga Beli</th>
              <th>Harga Jual</th>
              <th>Masuk</th>
              <th>Keluar</th>
              <th>Sisa</th>
              <th>Aksi</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </div>

  <div class="footer">
    <p>&copy; Rian v18.12.25 | PT.Hasta Harmonis | <a href="#">Privacy Policy</a></p>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <script>
    let stokData = [];
    let currentlyEditingId = null;
    let db = null;
    const DB_NAME = 'StokKacaDB';
    const DB_VERSION = 1;
    const STORE_NAME = 'stokData';
    // Flag to prevent auto-overwrite when user mengisi harga beli/manual
    let hargaManualOverride = false;

    // Initialize IndexedDB
    function initDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);

        request.onerror = () => {
          console.error('IndexedDB error:', request.error);
          reject(request.error);
        };

        request.onsuccess = () => {
          db = request.result;
          resolve(db);
        };

        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          if (!db.objectStoreNames.contains(STORE_NAME)) {
            const objectStore = db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: false });
            objectStore.createIndex('id', 'id', { unique: true });
            objectStore.createIndex('tanggal', 'tanggal', { unique: false });
            objectStore.createIndex('nama', 'nama', { unique: false });
          }
        };
      });
    }

    // Load all data from IndexedDB
    async function loadData() {
      try {
        if (!db) {
          await initDB();
        }

        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_NAME], 'readonly');
          const store = transaction.objectStore(STORE_NAME);
          const request = store.getAll();

          request.onsuccess = () => {
            stokData = request.result || [];
            window.stokData = stokData; // Make it globally accessible for tooltip
            console.log('Data loaded:', stokData.length, 'entries');
            resolve(stokData);
          };

          request.onerror = () => {
            console.error('Error loading data:', request.error);
            reject(request.error);
          };
        });
      } catch (error) {
        console.error('Error in loadData:', error);
        stokData = [];
        return [];
      }
    }

    // Save data to IndexedDB (saves all data in stokData array)
    async function saveData() {
      try {
        if (!db) {
          await initDB();
        }

        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_NAME], 'readwrite');
          const store = transaction.objectStore(STORE_NAME);
          
          // Clear existing data first
          const clearRequest = store.clear();
          
          clearRequest.onsuccess = () => {
            // Add all data
            if (stokData.length === 0) {
              showStatus("Data berhasil disimpan (0 baris)", "saving");
              setTimeout(() => document.getElementById('statusBar').style.display = 'none', 2000);
              resolve();
              return;
            }

            let completed = 0;
            let hasError = false;

            stokData.forEach((item) => {
              const request = store.add(item);
              
              request.onsuccess = () => {
                completed++;
                if (completed === stokData.length && !hasError) {
                  showStatus("Data berhasil disimpan (" + stokData.length + " baris)", "saving");
                  setTimeout(() => document.getElementById('statusBar').style.display = 'none', 2000);
                  resolve();
                }
              };

              request.onerror = () => {
                if (!hasError) {
                  hasError = true;
                  const errorMsg = "Gagal menyimpan data: " + request.error.message;
                  showStatus(errorMsg, "error");
                  console.error("Error saving data:", request.error);
                  setTimeout(() => document.getElementById('statusBar').style.display = 'none', 5000);
                  reject(request.error);
                }
              };
            });
          };

          clearRequest.onerror = () => {
            const errorMsg = "Gagal menghapus data lama: " + clearRequest.error.message;
            showStatus(errorMsg, "error");
            console.error("Error clearing store:", clearRequest.error);
            setTimeout(() => document.getElementById('statusBar').style.display = 'none', 5000);
            reject(clearRequest.error);
          };
        });
      } catch (error) {
        let errorMessage = "Gagal menyimpan data: ";
        if (error.name === 'QuotaExceededError' || error.code === 22) {
          errorMessage += "Penyimpanan penuh. IndexedDB mendukung penyimpanan besar, tetapi browser mungkin membatasi. Silakan coba lagi atau export data ke Excel.";
        } else {
          errorMessage += error.message;
        }
        showStatus(errorMessage, "error");
        console.error("Error in saveData:", error);
        setTimeout(() => document.getElementById('statusBar').style.display = 'none', 5000);
      }
    }

    // Add single entry to IndexedDB
    async function addEntry(entry) {
      try {
        if (!db) {
          await initDB();
        }

        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_NAME], 'readwrite');
          const store = transaction.objectStore(STORE_NAME);
          const request = store.add(entry);

          request.onsuccess = () => {
            resolve(entry);
          };

          request.onerror = () => {
            reject(request.error);
          };
        });
      } catch (error) {
        console.error('Error adding entry:', error);
        throw error;
      }
    }

    // Update single entry in IndexedDB
    async function updateEntry(entry) {
      try {
        if (!db) {
          await initDB();
        }

        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_NAME], 'readwrite');
          const store = transaction.objectStore(STORE_NAME);
          const request = store.put(entry);

          request.onsuccess = () => {
            resolve(entry);
          };

          request.onerror = () => {
            reject(request.error);
          };
        });
      } catch (error) {
        console.error('Error updating entry:', error);
        throw error;
      }
    }

    // Delete single entry from IndexedDB
    async function deleteEntryFromDB(id) {
      try {
        if (!db) {
          await initDB();
        }

        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_NAME], 'readwrite');
          const store = transaction.objectStore(STORE_NAME);
          const request = store.delete(id);

          request.onsuccess = () => {
            resolve();
          };

          request.onerror = () => {
            reject(request.error);
          };
        });
      } catch (error) {
        console.error('Error deleting entry:', error);
        throw error;
      }
    }

    // Initialize date field with today's date
    document.addEventListener('DOMContentLoaded', async function() {
      // Initialize IndexedDB and load data
      try {
        await initDB();
        await loadData();
      } catch (error) {
        console.error('Error initializing database:', error);
        showStatus("Error memuat database. Menggunakan data kosong.", "error");
        stokData = [];
      }

      // Set tanggal default ke hari ini - khusus untuk form stok
      const stokForm = document.getElementById('stokForm');
      if (stokForm) {
        const tanggalInput = stokForm.querySelector('input[type="date"]#tanggal');
        if (tanggalInput && !tanggalInput.value) {
          tanggalInput.valueAsDate = new Date();
          // Force trigger untuk memastikan browser update display
          tanggalInput.dispatchEvent(new Event('input', { bubbles: true }));
        }
      }
      
      // Initialize form mode
      setFormMode('pembelian');
      
      updateStokTable();
      updateTotalSisa();
      updateNamaTokoList();
      updateJenisKacaList();
      updateUkuranKacaList();
      
      // Add Enter key functionality to form inputs
      setupEnterKeyNavigation();
      // Update placeholder when harga beli berubah
      const hargaInput = document.getElementById('harga');
      if (hargaInput) {
        hargaInput.addEventListener('input', () => {
          // Jika user mengetik harga sendiri, jangan timpa otomatis
          hargaManualOverride = hargaInput.value.trim() !== '';
          updateHargaJualPlaceholder();
        });
      }
      
      // Monitor tebal and ukuran fields for datalist selection changes
      // This is a more aggressive polling mechanism to catch datalist selections
      const tebalField = document.getElementById('tebal');
      const ukuranField = document.getElementById('ukuran');
      let lastTebalValue = tebalField?.value.trim() || '';
      let lastUkuranValue = ukuranField?.value.trim() || '';
      
      // Function to handle tebal change
      const handleTebalValueChange = function() {
        updateHargaBeliPlaceholder(); // Update placeholder first
        updateUkuranKacaList();
        fillHargaFromSelectedJenisKaca();
        updateHargaJualPlaceholder();
      };
      
      // Function to handle ukuran change
      const handleUkuranValueChange = function() {
        updateHargaBeliPlaceholder(); // Update placeholder first
        fillHargaFromSelectedJenisKaca();
        updateHargaJualPlaceholder();
      };
      
      // More aggressive polling - check every 50ms for faster response
      const checkInterval = setInterval(function() {
        if (tebalField) {
          const currentTebal = tebalField.value.trim();
          if (currentTebal !== lastTebalValue) {
            lastTebalValue = currentTebal;
            // Use requestAnimationFrame for immediate update
            requestAnimationFrame(function() {
              handleTebalValueChange();
            });
          }
        }
        
        if (ukuranField) {
          const currentUkuran = ukuranField.value.trim();
          if (currentUkuran !== lastUkuranValue) {
            lastUkuranValue = currentUkuran;
            // Use requestAnimationFrame for immediate update
            requestAnimationFrame(function() {
              handleUkuranValueChange();
            });
          }
        }
      }, 50); // Check every 50ms - very aggressive for immediate response
      
      // Also use requestAnimationFrame loop for even faster detection
      function checkFieldsWithRAF() {
        if (tebalField) {
          const currentTebal = tebalField.value.trim();
          if (currentTebal !== lastTebalValue) {
            lastTebalValue = currentTebal;
            handleTebalValueChange();
          }
        }
        
        if (ukuranField) {
          const currentUkuran = ukuranField.value.trim();
          if (currentUkuran !== lastUkuranValue) {
            lastUkuranValue = currentUkuran;
            handleUkuranValueChange();
          }
        }
        
        requestAnimationFrame(checkFieldsWithRAF);
      }
      requestAnimationFrame(checkFieldsWithRAF);
      
      // Also listen for mouse clicks anywhere on the page (to catch datalist option clicks)
      document.addEventListener('click', function(e) {
        // Check if click was on or near the tebal or ukuran input
        const target = e.target;
        if (tebalField && (target === tebalField || tebalField.contains(target))) {
          setTimeout(function() {
            const currentTebal = tebalField.value.trim();
            if (currentTebal !== lastTebalValue) {
              lastTebalValue = currentTebal;
            hargaManualOverride = false;
              handleTebalValueChange();
            }
          }, 200);
        }
        if (ukuranField && (target === ukuranField || ukuranField.contains(target))) {
          setTimeout(function() {
            const currentUkuran = ukuranField.value.trim();
            if (currentUkuran !== lastUkuranValue) {
              lastUkuranValue = currentUkuran;
            hargaManualOverride = false;
              handleUkuranValueChange();
            }
          }, 200);
        }
      });
      
      // Listen for any mouseup event (when user releases mouse after clicking datalist option)
      document.addEventListener('mouseup', function(e) {
        setTimeout(function() {
          if (tebalField) {
            const currentTebal = tebalField.value.trim();
            if (currentTebal !== lastTebalValue) {
              lastTebalValue = currentTebal;
              hargaManualOverride = false;
              handleTebalValueChange();
            }
          }
          if (ukuranField) {
            const currentUkuran = ukuranField.value.trim();
            if (currentUkuran !== lastUkuranValue) {
              lastUkuranValue = currentUkuran;
              hargaManualOverride = false;
              handleUkuranValueChange();
            }
          }
        }, 150);
      });
      
      // Focus search input on Ctrl+F or Cmd+F
      document.addEventListener('keydown', function(e) {
        if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
          e.preventDefault();
          document.getElementById('searchInput').focus();
        }
        // Handle Ctrl+P or Cmd+P to trigger Print Sekarang
        if ((e.ctrlKey || e.metaKey) && e.key === 'p') {
          e.preventDefault();
          if (typeof handleQuickPrint === 'function') {
            handleQuickPrint();
          }
        }
      });
    });

    // Function to update nama toko autocomplete list
    function updateNamaTokoList() {
      const namaTokoList = document.getElementById('namaTokoList');
      const uniqueNama = [...new Set(stokData.map(item => item.nama))].sort();
      
      namaTokoList.innerHTML = '';
      uniqueNama.forEach(nama => {
        const option = document.createElement('option');
        option.value = nama;
        namaTokoList.appendChild(option);
      });
    }

    // Function to update jenis kaca autocomplete list
    function updateJenisKacaList() {
      const jenisKacaList = document.getElementById('jenisKacaList');
      const groupedData = {};

      // Group data by Tebal Kaca, Ukuran Kaca, dan Harga Beli (untuk membedakan stok berdasarkan harga)
      stokData.forEach((entry) => {
        const hargaKey = entry.harga !== undefined && entry.harga > 0 ? entry.harga : 'noharga';
        const key = `${entry.tebal}-${entry.ukuran}-${hargaKey}`;

        if (!groupedData[key]) {
          groupedData[key] = { 
            tebal: entry.tebal, 
            ukuran: entry.ukuran, 
            hargaMasuk: hargaKey !== 'noharga' ? entry.harga : undefined,
            totalMasuk: 0, 
            totalKeluar: 0, 
            totalSisa: 0 
          };
        }

        // Simpan harga khusus untuk transaksi masuk (harga beli)
        if (
          groupedData[key].hargaMasuk === undefined &&
          entry.masuk > 0 &&
          entry.harga !== undefined &&
          entry.harga > 0
        ) {
          groupedData[key].hargaMasuk = entry.harga;
        }

        groupedData[key].totalMasuk += entry.masuk;
        groupedData[key].totalKeluar += entry.keluar;
        groupedData[key].totalSisa = groupedData[key].totalMasuk - groupedData[key].totalKeluar;
      });

      // Clear the datalist
      jenisKacaList.innerHTML = '';

      // Insert grouped data into the datalist (hanya yang memiliki sisa stok > 0)
      for (const key in groupedData) {
        const data = groupedData[key];
        
        // Hanya tampilkan jika ada sisa stok yang bisa dijual
        if (data.totalSisa > 0) {
          const option = document.createElement('option');
          option.value = data.tebal; // Only the glass type gets filled
          
          // Format: "Jenis Kaca : Ukuran (Harga: Rp X, Sisa: Y)"
          let displayText = `${data.ukuran}`;
          if (data.hargaMasuk !== undefined && data.hargaMasuk > 0) {
            displayText += ` (Harga: Rp ${data.hargaMasuk.toLocaleString('id-ID')}, Sisa: ${data.totalSisa.toLocaleString('id-ID')})`;
          } else {
            displayText += ` (Sisa: ${data.totalSisa.toLocaleString('id-ID')})`;
          }
          
          option.textContent = displayText;
          jenisKacaList.appendChild(option);
        }
      }
      
      // Update placeholder after datalist is updated
      updateHargaBeliPlaceholder();
      updateHargaJualPlaceholder();
    }

    // Function to update ukuran kaca autocomplete list
    function updateUkuranKacaList() {
      const ukuranKacaList = document.getElementById('ukuranKacaList');
      const selectedTebal = document.getElementById('tebal').value;
      const groupedData = {};

      // Group data by Tebal Kaca, Ukuran Kaca, dan Harga Beli (untuk membedakan stok berdasarkan harga)
      stokData.forEach((entry) => {
        const hargaKey = entry.harga !== undefined && entry.harga > 0 ? entry.harga : 'noharga';
        const key = `${entry.tebal}-${entry.ukuran}-${hargaKey}`;

        if (!groupedData[key]) {
          groupedData[key] = { 
            tebal: entry.tebal, 
            ukuran: entry.ukuran, 
            hargaMasuk: hargaKey !== 'noharga' ? entry.harga : undefined,
            totalMasuk: 0, 
            totalKeluar: 0, 
            totalSisa: 0 
          };
        }

        // Catat harga hanya dari transaksi masuk (harga beli)
        if (
          groupedData[key].hargaMasuk === undefined &&
          entry.masuk > 0 &&
          entry.harga !== undefined &&
          entry.harga > 0
        ) {
          groupedData[key].hargaMasuk = entry.harga;
        }

        groupedData[key].totalMasuk += entry.masuk;
        groupedData[key].totalKeluar += entry.keluar;
        groupedData[key].totalSisa = groupedData[key].totalMasuk - groupedData[key].totalKeluar;
      });

      // Clear the datalist
      ukuranKacaList.innerHTML = '';

      // Filter sizes based on selected glass type (hanya yang memiliki sisa stok > 0)
      for (const key in groupedData) {
        const data = groupedData[key];
        
        // If a glass type is selected, only show sizes for that type
        if (selectedTebal && data.tebal !== selectedTebal) {
          continue;
        }
        
        // Hanya tampilkan jika ada sisa stok yang bisa dijual
        if (data.totalSisa > 0) {
          const option = document.createElement('option');
          option.value = data.ukuran; // Only the glass size gets filled
          
          // Format: "Ukuran (Harga: Rp X, Sisa: Y)"
          let displayText = data.ukuran;
          if (data.hargaMasuk !== undefined && data.hargaMasuk > 0) {
            displayText += ` (Harga: Rp ${data.hargaMasuk.toLocaleString('id-ID')}, Sisa: ${data.totalSisa.toLocaleString('id-ID')})`;
          } else {
            displayText += ` (Sisa: ${data.totalSisa.toLocaleString('id-ID')})`;
          }
          
          option.textContent = displayText;
          ukuranKacaList.appendChild(option);
        }
      }
      
      // Update placeholder after datalist is updated
      updateHargaBeliPlaceholder();
      updateHargaJualPlaceholder();
    }

    // Function to update harga beli placeholder
    function updateHargaBeliPlaceholder() {
      const tebalField = document.getElementById('tebal');
      const ukuranField = document.getElementById('ukuran');
      const hargaField = document.getElementById('harga');
      
      if (!tebalField || !ukuranField || !hargaField) {
        return;
      }
      
      const tebal = tebalField.value.trim();
      const ukuran = ukuranField.value.trim();
      
      // Default placeholder
      let placeholderText = 'Harga Beli';
      
      // If both tebal and ukuran are filled, try to get harga
      if (tebal && ukuran) {
        const groupedData = {};
        
        stokData.forEach((entry) => {
          if (entry.tebal === tebal && entry.ukuran === ukuran) {
            const hargaKey = entry.harga !== undefined && entry.harga > 0 ? entry.harga : 'noharga';
            const key = `${entry.tebal}-${entry.ukuran}-${hargaKey}`;
            
            if (!groupedData[key]) {
              groupedData[key] = { 
                hargaMasuk: hargaKey !== 'noharga' ? entry.harga : undefined,
                totalMasuk: 0, 
                totalKeluar: 0, 
                totalSisa: 0 
              };
            }
            
            // Always set hargaMasuk from entry harga if available (prioritize masuk entries)
            if (entry.harga !== undefined && entry.harga > 0) {
              if (groupedData[key].hargaMasuk === undefined) {
                // If not set yet, set it from any entry with harga
                groupedData[key].hargaMasuk = entry.harga;
              } else if (entry.masuk > 0) {
                // If already set but this is a masuk entry, prefer this one (it's the purchase price)
                groupedData[key].hargaMasuk = entry.harga;
              }
              // If hargaMasuk already set and this is not a masuk entry, keep the existing one
            }
            
            groupedData[key].totalMasuk += entry.masuk;
            groupedData[key].totalKeluar += entry.keluar;
            groupedData[key].totalSisa = groupedData[key].totalMasuk - groupedData[key].totalKeluar;
          }
        });
        
        // Get all available harga with stock
        const hargaList = [];
        for (const key in groupedData) {
          const data = groupedData[key];
          // Include all entries with stock > 0 and has harga
          if (data.totalSisa > 0) {
            // Use hargaMasuk if available, otherwise extract from key
            if (data.hargaMasuk !== undefined && data.hargaMasuk > 0) {
              hargaList.push(data.hargaMasuk);
            } else {
              // Fallback: extract harga from key (format: tebal-ukuran-harga)
              const parts = key.split('-');
              if (parts.length >= 3) {
                const hargaFromKey = parts.slice(2).join('-'); // Handle harga that might contain dashes
                if (hargaFromKey !== 'noharga') {
                  const hargaValue = parseFloat(hargaFromKey);
                  if (!isNaN(hargaValue) && hargaValue > 0) {
                    hargaList.push(hargaValue);
                  }
                }
              }
            }
          }
        }
        
        // Unique and sort ascending
        const uniqueSorted = [...new Set(hargaList)].sort((a, b) => a - b);
        
        if (uniqueSorted.length > 0) {
          if (uniqueSorted.length === 1) {
            placeholderText = `Harga Beli | Rp ${uniqueSorted[0].toLocaleString('id-ID')}`;
          } else {
            const displayList = uniqueSorted.map(h => `Rp ${h.toLocaleString('id-ID')}`).join(' / ');
            placeholderText = `Harga Beli | ${displayList}`;
          }
        }
      }
      
      // Always update placeholder, even if field is hidden
      hargaField.setAttribute('placeholder', placeholderText);
      
      // Force update by triggering input event (for compatibility)
      if (hargaField.value === '') {
        // Only update placeholder if field is empty
        hargaField.placeholder = placeholderText;
      }
    }

    // Function to fill harga beli from selected jenis kaca and ukuran
    function fillHargaFromSelectedJenisKaca() {
      const tebal = document.getElementById('tebal').value.trim();
      const ukuran = document.getElementById('ukuran').value.trim();
      const hargaField = document.getElementById('harga');
      
      // Jika user sudah mengisi harga manual, jangan timpa
      if (hargaManualOverride && hargaField && hargaField.value.trim() !== '') {
        updateHargaJualPlaceholder();
        return;
      }

      // Update placeholder first
      updateHargaBeliPlaceholder();
      
      // Only proceed if both tebal and ukuran are filled
      if (!tebal || !ukuran) {
        return;
      }
      
      // Find matching entry with sisa stok > 0
      const groupedData = {};
      
      stokData.forEach((entry) => {
        if (entry.tebal === tebal && entry.ukuran === ukuran) {
          const hargaKey = entry.harga !== undefined && entry.harga > 0 ? entry.harga : 'noharga';
          const key = `${entry.tebal}-${entry.ukuran}-${hargaKey}`;
          
          if (!groupedData[key]) {
            groupedData[key] = { 
              hargaMasuk: hargaKey !== 'noharga' ? entry.harga : undefined,
              totalMasuk: 0, 
              totalKeluar: 0, 
              totalSisa: 0 
            };
          }
          
          if (
            groupedData[key].hargaMasuk === undefined &&
            entry.masuk > 0 &&
            entry.harga !== undefined &&
            entry.harga > 0
          ) {
            groupedData[key].hargaMasuk = entry.harga;
          }
          
          groupedData[key].totalMasuk += entry.masuk;
          groupedData[key].totalKeluar += entry.keluar;
          groupedData[key].totalSisa = groupedData[key].totalMasuk - groupedData[key].totalKeluar;
        }
      });

      // Kumpulkan semua harga dengan stok > 0
      const hargaList = [];
      for (const key in groupedData) {
        const data = groupedData[key];
        if (data.totalSisa > 0 && data.hargaMasuk !== undefined && data.hargaMasuk > 0) {
          hargaList.push(data.hargaMasuk);
        }
      }
      const uniqueSorted = [...new Set(hargaList)].sort((a, b) => a - b);

      // Isi harga otomatis hanya bila tersedia tepat satu harga; jika lebih dari satu, biarkan kosong agar placeholder menampilkan daftar
      if (uniqueSorted.length === 1) {
        hargaField.value = uniqueSorted[0];
      } else {
        hargaField.value = '';
      }

      // Always update placeholder to reflect latest state
      updateHargaJualPlaceholder();
    }

    // Helper: get all harga beli with sisa > 0 for given tebal+ukuran
    function getHargaBeliListWithStock(tebal, ukuran) {
      const groupedData = {};
      stokData.forEach((entry) => {
        if (entry.tebal === tebal && entry.ukuran === ukuran) {
          const hargaKey = entry.harga !== undefined && entry.harga > 0 ? entry.harga : 'noharga';
          const key = `${entry.tebal}-${entry.ukuran}-${hargaKey}`;
          
          if (!groupedData[key]) {
            groupedData[key] = { 
              hargaMasuk: hargaKey !== 'noharga' ? entry.harga : undefined,
              totalMasuk: 0, 
              totalKeluar: 0, 
              totalSisa: 0 
            };
          }

          // Always set hargaMasuk from entry harga if available (prioritize masuk entries)
          if (entry.harga !== undefined && entry.harga > 0) {
            if (groupedData[key].hargaMasuk === undefined) {
              // If not set yet, set it from any entry with harga
              groupedData[key].hargaMasuk = entry.harga;
            } else if (entry.masuk > 0) {
              // If already set but this is a masuk entry, prefer this one (it's the purchase price)
              groupedData[key].hargaMasuk = entry.harga;
            }
            // If hargaMasuk already set and this is not a masuk entry, keep the existing one
          }

          groupedData[key].totalMasuk += entry.masuk;
          groupedData[key].totalKeluar += entry.keluar;
          groupedData[key].totalSisa = groupedData[key].totalMasuk - groupedData[key].totalKeluar;
        }
      });

      // Get all available harga with stock
      const hargaList = [];
      for (const key in groupedData) {
        const data = groupedData[key];
        // Include all entries with stock > 0 and has harga
        if (data.totalSisa > 0) {
          // Use hargaMasuk if available, otherwise extract from key
          if (data.hargaMasuk !== undefined && data.hargaMasuk > 0) {
            hargaList.push(data.hargaMasuk);
          } else {
            // Fallback: extract harga from key (format: tebal-ukuran-harga)
            const parts = key.split('-');
            if (parts.length >= 3) {
              const hargaFromKey = parts.slice(2).join('-'); // Handle harga that might contain dashes
              if (hargaFromKey !== 'noharga') {
                const hargaValue = parseFloat(hargaFromKey);
                if (!isNaN(hargaValue) && hargaValue > 0) {
                  hargaList.push(hargaValue);
                }
              }
            }
          }
        }
      }

      // Unique and sort ascending
      const uniqueSorted = [...new Set(hargaList)].sort((a, b) => a - b);
      return uniqueSorted;
    }

    // Update placeholder harga jual dengan informasi harga beli yang tersedia
    function updateHargaJualPlaceholder() {
      const tebalField = document.getElementById('tebal');
      const ukuranField = document.getElementById('ukuran');
      const hargaJualField = document.getElementById('hargaJual');
      const hargaField = document.getElementById('harga');

      if (!tebalField || !ukuranField || !hargaJualField) {
        return;
      }

      const tebal = tebalField.value.trim();
      const ukuran = ukuranField.value.trim();

      // Default placeholder
      let placeholderText = 'Harga Jual | [Harga Beli]';

      // Hanya relevan di mode penjualan
      if (currentFormMode === 'penjualan' && tebal && ukuran) {
        // Jika harga beli sudah terisi (misal dari klik tabel kanan atau ketikan), pakai itu
        const hargaBeliSelected = hargaField ? parseNumber(hargaField.value) : 0;
        if (hargaBeliSelected > 0) {
          placeholderText = `Harga Jual | Rp ${hargaBeliSelected.toLocaleString('id-ID')}`;
        } else {
          // Jika belum, tampilkan daftar semua harga beli yang punya stok
          const hargaList = getHargaBeliListWithStock(tebal, ukuran);
          if (hargaList.length > 0) {
            if (hargaList.length === 1) {
              placeholderText = `Harga Jual | Rp ${hargaList[0].toLocaleString('id-ID')}`;
            } else {
              const displayList = hargaList.map(h => `Rp ${h.toLocaleString('id-ID')}`).join(' / ');
              placeholderText = `Harga Jual | ${displayList}`;
            }
          }
        }
      }

      // Always update placeholder
      hargaJualField.setAttribute('placeholder', placeholderText);
      hargaJualField.placeholder = placeholderText; // Also set directly for compatibility
    }

    // Function to setup Enter key navigation
    function setupEnterKeyNavigation() {
      const formInputs = [
        'nama',
        'tanggal', 
        'nota',
        'tebal',
        'ukuran',
        'harga',
        'hargaJual',
        'masuk',
        'keluar'
      ];

      formInputs.forEach((inputId, index) => {
        // Langsung cari input dari form stok, bukan dari document
        const stokForm = document.getElementById('stokForm');
        if (!stokForm) return;
        
        // Gunakan querySelector dari stokForm untuk memastikan kita mendapatkan field yang benar
        let input = null;
        if (inputId === 'tanggal') {
          // Khusus untuk tanggal, cari input type="date" di dalam stokForm
          input = stokForm.querySelector('input[type="date"]#tanggal');
        } else {
          // Untuk field lain, gunakan selector biasa dari stokForm
          input = stokForm.querySelector('#' + inputId);
        }
        
        if (input) {
          // Double check: pastikan input benar-benar berada di form stok
          if (!stokForm.contains(input)) {
            return; // Skip field yang tidak berada di form stok
          }
          
          input.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
              e.preventDefault();
              e.stopPropagation(); // Prevent event from bubbling to global listener
              
              // Skip hidden fields based on form mode
              if (currentFormMode === 'pembelian' && (inputId === 'hargaJual' || inputId === 'keluar')) {
                tambahData();
                return;
              }
              if (currentFormMode === 'penjualan' && (inputId === 'harga' || inputId === 'masuk')) {
                tambahData();
                return;
              }
              
              // Special handling for "masuk" field
              if (inputId === 'masuk') {
                const stokForm = document.getElementById('stokForm');
                const masukInput = stokForm ? stokForm.querySelector('#masuk') : null;
                const keluarInput = stokForm ? stokForm.querySelector('#keluar') : null;
                const masukValue = masukInput ? masukInput.value : '';
                const keluarValue = keluarInput ? keluarInput.value : '';
                
                // If masuk has value and keluar is empty, skip keluar and submit
                if (masukValue && masukValue > 0 && (!keluarValue || keluarValue == 0)) {
                  tambahData();
                  return;
                }
              }
              
              // Find next visible input - hanya di form stok
              const stokForm = document.getElementById('stokForm');
              if (!stokForm) {
                tambahData();
                return;
              }
              
              let nextIndex = index + 1;
              while (nextIndex < formInputs.length) {
                const nextInputId = formInputs[nextIndex];
                
                // Gunakan querySelector dari stokForm dengan selector yang lebih spesifik
                let nextInput = null;
                if (nextInputId === 'tanggal') {
                  // Khusus untuk tanggal, cari input type="date" di dalam stokForm
                  nextInput = stokForm.querySelector('input[type="date"]#tanggal');
                } else {
                  // Untuk field lain, gunakan selector biasa dari stokForm
                  nextInput = stokForm.querySelector('#' + nextInputId);
                }
                
                if (nextInput && stokForm.contains(nextInput)) {
                  // Check if field is visible based on mode
                  const isPembelianField = nextInputId === 'harga' || nextInputId === 'masuk';
                  const isPenjualanField = nextInputId === 'hargaJual' || nextInputId === 'keluar';
                  
                  if (currentFormMode === 'pembelian' && isPenjualanField) {
                    nextIndex++;
                    continue;
                  }
                  if (currentFormMode === 'penjualan' && isPembelianField) {
                    nextIndex++;
                    continue;
                  }
                  
                  // Check visibility - simplified check
                  const computedStyle = window.getComputedStyle(nextInput);
                  const isHidden = computedStyle.display === 'none' || 
                                  computedStyle.visibility === 'hidden' ||
                                  nextInput.disabled ||
                                  nextInput.hidden ||
                                  nextInput.type === 'hidden';
                  
                  // If not hidden, focus on it immediately
                  if (!isHidden) {
                    // Use requestAnimationFrame for immediate focus
                    requestAnimationFrame(() => {
                      // Double check field still exists and is in stokForm
                      let verifyInput = null;
                      if (nextInputId === 'tanggal') {
                        verifyInput = stokForm.querySelector('input[type="date"]#tanggal');
                      } else {
                        verifyInput = stokForm.querySelector('#' + nextInputId);
                      }
                      if (verifyInput && stokForm.contains(verifyInput) && !verifyInput.disabled) {
                        verifyInput.focus();
                      }
                    });
                    return;
                  }
                }
                nextIndex++;
              }
              
              // If no next visible input found, submit form
              tambahData();
            }
          });
          
          // Add multiple event listeners for tebal field to handle datalist selection
          if (inputId === 'tebal') {
            const handleTebalChange = function() {
              // Force update placeholder immediately
              hargaManualOverride = false; // reset supaya boleh auto-fill sesuai pilihan baru
              updateHargaBeliPlaceholder();
              updateUkuranKacaList();
              fillHargaFromSelectedJenisKaca();
              updateHargaJualPlaceholder();
              // Kosongkan harga jual agar placeholder terlihat saat di penjualan
              if (currentFormMode === 'penjualan') {
                const hargaJualField = document.getElementById('hargaJual');
                if (hargaJualField) {
                  hargaJualField.value = '';
                }
              }
            };
            // Use multiple events to catch all possible interactions
            input.addEventListener('input', handleTebalChange);
            input.addEventListener('change', handleTebalChange);
            // Use blur with delay to catch datalist selections that don't trigger change immediately
            input.addEventListener('blur', function() {
              setTimeout(handleTebalChange, 150);
            });
            // Listen for keyboard events that might be used to select from datalist
            input.addEventListener('keyup', function(e) {
              // Arrow keys, Enter, or Tab might be used to select from datalist
              if (e.key === 'ArrowDown' || e.key === 'ArrowUp' || e.key === 'Enter' || e.key === 'Tab') {
                setTimeout(handleTebalChange, 100);
              }
            });
            // Also listen for focus events
            input.addEventListener('focus', function() {
              setTimeout(handleTebalChange, 200);
            });
          }
          
          // Add multiple event listeners for ukuran field to handle datalist selection
          if (inputId === 'ukuran') {
            const handleUkuranChange = function() {
              // Force update placeholder immediately
              hargaManualOverride = false; // reset supaya boleh auto-fill sesuai pilihan baru
              updateHargaBeliPlaceholder();
              fillHargaFromSelectedJenisKaca();
              updateHargaJualPlaceholder();
              // Kosongkan harga jual agar placeholder terlihat saat di penjualan
              if (currentFormMode === 'penjualan') {
                const hargaJualField = document.getElementById('hargaJual');
                if (hargaJualField) {
                  hargaJualField.value = '';
                }
              }
            };
            // Use multiple events to catch all possible interactions
            input.addEventListener('input', handleUkuranChange);
            input.addEventListener('change', handleUkuranChange);
            // Use blur with delay to catch datalist selections that don't trigger change immediately
            input.addEventListener('blur', function() {
              setTimeout(handleUkuranChange, 150);
            });
            // Listen for keyboard events that might be used to select from datalist
            input.addEventListener('keyup', function(e) {
              // Arrow keys, Enter, or Tab might be used to select from datalist
              if (e.key === 'ArrowDown' || e.key === 'ArrowUp' || e.key === 'Enter' || e.key === 'Tab') {
                setTimeout(handleUkuranChange, 100);
              }
            });
            // Also listen for focus events
            input.addEventListener('focus', function() {
              setTimeout(handleUkuranChange, 200);
            });
          }
        }
      });
    }

    // Function to perform search
    function performSearch() {
      const searchInput = document.getElementById('searchInput');
      const searchTerm = searchInput ? searchInput.value.trim() : '';
      const searchClearBtn = document.getElementById('searchClearBtn');
      const tableBody = document.getElementById("stokTable");
      if (!tableBody) {
        console.log('❌ stokTable not found');
        return;
      }
      
      const tbody = tableBody.getElementsByTagName('tbody')[0];
      if (!tbody) {
        console.log('❌ tbody not found');
        return;
      }
      
      const rows = Array.from(tbody.querySelectorAll('tr'));
      console.log(`🔍 performSearch called with term: "${searchTerm}", found ${rows.length} rows`);
      
      // Show/hide clear button
      if (searchTerm.length > 0) {
        if (searchClearBtn) searchClearBtn.style.display = 'block';
      } else {
        if (searchClearBtn) searchClearBtn.style.display = 'none';
      }
      
      // Check for sorting patterns: "1-2" (ascending) or "2-1" (descending)
      if (searchTerm === '1-2' || searchTerm === '2-1') {
        console.log(`📊 Sorting by nota: ${searchTerm === '1-2' ? 'ascending' : 'descending'}`);
        // Sort by nota number
        const sortAscending = searchTerm === '1-2';
        
        // First, make sure all rows are visible
        rows.forEach(row => {
          row.style.display = '';
        });
        
        // Extract nota from each row and sort
        const rowsWithNota = rows.map(row => {
          const cells = row.querySelectorAll('td');
          // Nota is in the 4th column (index 3)
          const notaCell = cells[3];
          const notaText = notaCell ? notaCell.textContent.trim() : '';
          
          // Extract numeric part from nota for sorting
          // Handle various nota formats (e.g., "SJ-123", "123", "ABC-456")
          // Try to get the last number in the string (most likely the main number)
          const notaMatches = notaText.match(/\d+/g);
          let notaNumber = 0;
          if (notaMatches && notaMatches.length > 0) {
            // Use the last number found (usually the main number after prefix)
            notaNumber = parseInt(notaMatches[notaMatches.length - 1], 10);
          }
          
          return { row, notaText, notaNumber };
        });
        
        console.log('📋 Nota data:', rowsWithNota.map(r => ({ nota: r.notaText, number: r.notaNumber })));
        
        // Sort by nota number
        rowsWithNota.sort((a, b) => {
          if (sortAscending) {
            // Ascending: small to large
            if (a.notaNumber !== b.notaNumber) {
              return a.notaNumber - b.notaNumber;
            }
            // If numbers are equal, sort by text
            return a.notaText.localeCompare(b.notaText);
          } else {
            // Descending: large to small
            if (a.notaNumber !== b.notaNumber) {
              return b.notaNumber - a.notaNumber;
            }
            // If numbers are equal, sort by text (reverse)
            return b.notaText.localeCompare(a.notaText);
          }
        });
        
        // Clear table and re-append sorted rows
        tbody.innerHTML = '';
        rowsWithNota.forEach((item, index) => {
          // Update row number
          const cells = item.row.querySelectorAll('td');
          if (cells[0]) {
            cells[0].textContent = index + 1;
          }
          // Ensure row is visible
          item.row.style.display = '';
          tbody.appendChild(item.row);
        });
        
        console.log(`✅ Sorted ${rowsWithNota.length} rows by nota (${sortAscending ? 'ascending' : 'descending'})`);
        return;
      }
      
      // Normal search functionality
      if (searchTerm === '') {
        // Show all rows if search is empty
        rows.forEach(row => {
          row.style.display = '';
        });
        return;
      }
      
      const searchTermLower = searchTerm.toLowerCase();
      rows.forEach(row => {
        const cells = row.querySelectorAll('td');
        let found = false;
        
        // Search in all visible columns (skip No and Aksi columns)
        for (let i = 1; i < cells.length - 1; i++) {
          const cellText = cells[i].textContent.toLowerCase();
          if (cellText.includes(searchTermLower)) {
            found = true;
            break;
          }
        }
        
        row.style.display = found ? '' : 'none';
      });
    }

    // Function to clear search
    function clearSearch() {
      document.getElementById('searchInput').value = '';
      document.getElementById('searchClearBtn').style.display = 'none';
      performSearch();
      document.getElementById('searchInput').focus();
    }

    // Function to set form mode (Pembelian/Penjualan)
    let currentFormMode = 'pembelian';
    
    function setFormMode(mode) {
      // Only support pembelian mode
      currentFormMode = 'pembelian';
      const pembelianFields = document.querySelectorAll('.field-pembelian');
      const penjualanFields = document.querySelectorAll('.field-penjualan');
      
      // Always show pembelian fields, hide penjualan fields
      pembelianFields.forEach(field => {
        field.style.display = '';
        field.removeAttribute('disabled');
      });
      penjualanFields.forEach(field => {
        field.style.display = 'none';
        field.value = '';
        field.setAttribute('disabled', 'disabled');
      });

      // Update placeholder harga beli dengan referensi harga beli yang tersedia
      updateHargaBeliPlaceholder();
    }

    // Function to toggle input fields for Masuk/Keluar
    function toggleJumlahMasukKeluar() {
      const masuk = document.getElementById("masuk");
      const keluar = document.getElementById("keluar");

      if (masuk.value && masuk.value > 0) {
        keluar.disabled = true;
        keluar.value = '';
      } else if (keluar.value && keluar.value > 0) {
        masuk.disabled = true;
        masuk.value = '';
      } else {
        masuk.disabled = false;
        keluar.disabled = false;
      }
    }

    // Function to add or update data
    async function tambahData() {
      const nama = document.getElementById("nama").value.trim();
      const tanggal = document.getElementById("tanggalStok").value;
      const nota = document.getElementById("nota").value.trim();
      const tebal = document.getElementById("tebal").value;
      const ukuran = document.getElementById("ukuran").value.trim();
          const harga = parseNumber(document.getElementById("harga").value);
          const hargaJual = parseNumber(document.getElementById("hargaJual").value);
          const masuk = parseNumber(document.getElementById("masuk").value);
          const keluar = parseNumber(document.getElementById("keluar").value);

      if (!nama || !tanggal || !nota || !tebal || !ukuran) {
        alert("Semua field harus diisi !");
        return;
      }

      // Validate based on form mode
      if (currentFormMode === 'pembelian') {
        if (masuk === 0) {
          alert("Harap isi jumlah kaca masuk!");
          return;
        }
      } else {
        if (keluar === 0) {
          alert("Harap isi jumlah kaca keluar!");
          return;
        }
      }

      // Format date for display
      const formattedDate = formatDate(tanggal);

      try {
        if (currentlyEditingId) {
          // Normalize ID to number for comparison
          const normalizedId = typeof currentlyEditingId === 'string' ? parseFloat(currentlyEditingId) : currentlyEditingId;
          
          // Update existing entry - check both stokData and window.stokData
          let index = stokData.findIndex(item => {
            const itemId = typeof item.id === 'string' ? parseFloat(item.id) : item.id;
            return itemId === normalizedId;
          });
          
          // If not found in local stokData, check window.stokData
          if (index === -1 && typeof window !== 'undefined' && typeof window.stokData !== 'undefined' && Array.isArray(window.stokData)) {
            const windowIndex = window.stokData.findIndex(item => {
              const itemId = typeof item.id === 'string' ? parseFloat(item.id) : item.id;
              return itemId === normalizedId;
            });
            if (windowIndex !== -1) {
              // Sync local stokData with window.stokData
              stokData = [...window.stokData];
              index = stokData.findIndex(item => {
                const itemId = typeof item.id === 'string' ? parseFloat(item.id) : item.id;
                return itemId === normalizedId;
              });
            }
          }
          
          if (index !== -1) {
            const updatedEntry = {
              id: currentlyEditingId,
              nama, 
              tanggal: formattedDate, 
              nota, 
              tebal, 
              ukuran, 
              harga,
              hargaJual,
              masuk, 
              keluar
            };
            stokData[index] = updatedEntry;
            
            // Sync dengan window.stokData untuk surat jalan
            if (typeof window !== 'undefined' && typeof window.stokData !== 'undefined' && Array.isArray(window.stokData)) {
              const windowIndex = window.stokData.findIndex(item => {
                const itemId = typeof item.id === 'string' ? parseFloat(item.id) : item.id;
                return itemId === normalizedId;
              });
              if (windowIndex !== -1) {
                window.stokData[windowIndex] = updatedEntry;
              } else {
                // Entry not in window.stokData, add it
                window.stokData.push(updatedEntry);
              }
            } else {
              // Initialize window.stokData if it doesn't exist
              if (typeof window !== 'undefined') {
                window.stokData = [...stokData];
              }
            }
            
            await updateEntry(updatedEntry);
            showStatus("Data berhasil diupdate", "saving");
            setTimeout(() => {
              const statusBar = document.getElementById('statusBar');
              if (statusBar) statusBar.style.display = 'none';
            }, 2000);
            
            // Update tabel dan dropdown lists without page refresh
            updateStokTable();
            updateTotalSisa();
            updateNamaTokoList();
            updateJenisKacaList();
            updateUkuranKacaList();
            
            // Update dropdown surat jalan
            if (typeof updateKacaSuggestionsFromLogs === 'function') {
              updateKacaSuggestionsFromLogs();
            }
            
            // Reset form
            cancelEdit();
            return;
          }
          cancelEdit();
        } else {
          // Add new entry
          const newEntry = {
            id: Date.now(),
            nama, 
            tanggal: formattedDate, 
            nota, 
            tebal, 
            ukuran, 
            harga,
            hargaJual,
            masuk, 
            keluar
          };
          stokData.unshift(newEntry);
          // Sync dengan window.stokData untuk surat jalan
          if (typeof window.stokData !== 'undefined' && Array.isArray(window.stokData)) {
            window.stokData.unshift(newEntry);
          } else {
            window.stokData = [...stokData];
          }
          await addEntry(newEntry);
          showStatus("Data berhasil ditambahkan", "saving");
          setTimeout(() => document.getElementById('statusBar').style.display = 'none', 2000);
        }

        updateStokTable();
        updateTotalSisa();
        updateNamaTokoList();
        updateJenisKacaList();
        updateUkuranKacaList();
        
        // Update dropdown surat jalan tanpa refresh
        if (typeof updateKacaSuggestionsFromLogs === 'function') {
          updateKacaSuggestionsFromLogs();
        }
        
        // Reset form
        document.getElementById("stokForm").reset();
        document.getElementById("tanggalStok").value = new Date().toISOString().split('T')[0];
        toggleJumlahMasukKeluar();
        updateHargaBeliPlaceholder();
        updateHargaJualPlaceholder();
        
        // Auto refresh halaman agar data terupdate
        setTimeout(() => {
          location.reload();
        }, 1); // Delay 500ms untuk memastikan semua update selesai
      } catch (error) {
        console.error('Error in tambahData:', error);
        alert("Terjadi kesalahan saat menyimpan data: " + error.message);
      }
    }

    // Function to calculate current stock at the time of transaction
    // Cache for date parsing to improve performance (global cache)
    if (!window._dateCache) {
      window._dateCache = new Map();
    }
    if (!window._parseDateCached) {
      window._parseDateCached = (dateStr) => {
        if (!window._dateCache.has(dateStr)) {
          window._dateCache.set(dateStr, new Date(dateStr.split('/').reverse().join('/')));
        }
        return window._dateCache.get(dateStr);
      };
    }
    
    function calculateCurrentStock(entry) {
      // Get all entries of the same type (tebal + ukuran + harga beli)
      const sameTypeEntries = stokData.filter(e => 
        e.tebal === entry.tebal && 
        e.ukuran === entry.ukuran &&
        ((e.harga ?? null) === (entry.harga ?? null))
      );
      
      // Sort by date and ID (oldest first) - using cached date parsing
      sameTypeEntries.sort((a, b) => {
        const dateA = window._parseDateCached(a.tanggal);
        const dateB = window._parseDateCached(b.tanggal);
        if (dateA - dateB !== 0) return dateA - dateB;
        return a.id - b.id; // For entries with same date, sort by ID
      });
      
      // Find all entries up to and including this one
      const entryIndex = sameTypeEntries.findIndex(e => e.id === entry.id);
      const entriesUpToThis = sameTypeEntries.slice(0, entryIndex + 1);
      
      // Calculate total masuk and keluar
      const totalMasuk = entriesUpToThis.reduce((sum, e) => sum + e.masuk, 0);
      const totalKeluar = entriesUpToThis.reduce((sum, e) => sum + e.keluar, 0);
      
      return totalMasuk - totalKeluar;
    }

    // Helper: parse number supporting thousand separators (., ,)
    function parseNumber(value) {
      if (value === undefined || value === null) return 0;
      if (typeof value === 'number') return isNaN(value) ? 0 : value;
      const cleaned = value.toString().replace(/[.,](?=\d{3}(\D|$))/g, '').replace(',', '.');
      const num = parseFloat(cleaned);
      return isNaN(num) ? 0 : num;
    }

    // Function to format date as dd/mm/yyyy
    function formatDate(dateString) {
      const date = new Date(dateString);
      const day = String(date.getDate()).padStart(2, '0');
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const year = date.getFullYear();
      return `${day}/${month}/${year}`;
    }

    // Function to update Riwayat Stok table
    function updateStokTable() {
      const tableBody = document.getElementById("stokTable").getElementsByTagName('tbody')[0];
      tableBody.innerHTML = ""; // Clear the table body

      // Use window.stokData if available (for sync with surat jalan), otherwise use local stokData
      const dataSource = (typeof window !== 'undefined' && typeof window.stokData !== 'undefined' && Array.isArray(window.stokData)) 
        ? window.stokData 
        : stokData;
      
      // Sync local stokData with window.stokData if available
      if (typeof window !== 'undefined' && typeof window.stokData !== 'undefined' && Array.isArray(window.stokData)) {
        stokData = [...window.stokData];
      }

      // Sort by ID (newest first) - ID is created with Date.now() so higher ID = newer entry
      // This ensures the most recently added entries appear at the top
      const sortedData = [...dataSource].sort((a, b) => {
        // Primary sort: by ID (newest first)
        const idA = a.id || 0;
        const idB = b.id || 0;
        if (idB !== idA) {
          return idB - idA;
        }
        // Secondary sort: by date (newest first) if IDs are equal - using cached date parsing
        const parseDateCached = window._parseDateCached || ((dateStr) => new Date(dateStr.split('/').reverse().join('/')));
        const dateA = parseDateCached(a.tanggal);
        const dateB = parseDateCached(b.tanggal);
        return dateB - dateA;
      });

      sortedData.forEach((entry, index) => {
        const currentStock = calculateCurrentStock(entry);
        
        // Determine if this is a pembelian (masuk > 0) or penjualan (keluar > 0)
        // Only show edit button for pembelian entries (masuk > 0)
        // For penjualan entries (keluar > 0), editing should be done in log surat jalan
        const isPembelian = entry.masuk > 0;
        
        const row = tableBody.insertRow();
        row.innerHTML = `
          <td>${index + 1}</td>
          <td>${entry.nama}</td>
          <td>${entry.tanggal}</td>
          <td>${entry.nota}</td>
          <td>${entry.tebal}</td>
          <td>${entry.ukuran}</td>
          <td>${entry.harga ? entry.harga.toLocaleString('id-ID') : '-'}</td>
          <td>${entry.hargaJual ? entry.hargaJual.toLocaleString('id-ID') : '-'}</td>
          <td class="masuk">${entry.masuk.toLocaleString('id-ID')}</td>
          <td class="keluar">${entry.keluar.toLocaleString('id-ID')}</td>
          <td class="sisa">${currentStock.toLocaleString('id-ID')}</td>
          <td style="padding-left: 25px;padding-right: 0px;padding-top: 5px;padding-bottom: 5px;">
            <div class="action-buttons-container">
              ${isPembelian ? `
              <button class="row-action-btn edit-btn" onclick="editEntry(${entry.id})" title="Edit data pembelian">
                <i class="fas fa-edit"></i>
              </button>
              ` : `
              <button class="row-action-btn edit-btn" style="display: none;" title="Edit penjualan dilakukan di log surat jalan">
                <i class="fas fa-edit"></i>
              </button>
              `}
              ${isPembelian ? `
              <button class="row-action-btn delete-btn" onclick="deleteEntry(${entry.id})" title="Hapus data pembelian">
                <i class="fas fa-trash"></i>
              </button>
              ` : `
              <button class="row-action-btn delete-btn" style="display: none;" title="Hapus penjualan dilakukan di log surat jalan">
                <i class="fas fa-trash"></i>
              </button>
              `}
            </div>
          </td>
        `;
      });
      
      // Reapply search if there's a search term
      const searchInput = document.getElementById('searchInput');
      if (searchInput && searchInput.value.trim() !== '') {
        performSearch();
      }
    }

    // Function to edit an entry
    function editEntry(id) {
      // Normalize ID to number for comparison (handle both string and number IDs)
      const normalizedId = typeof id === 'string' ? parseFloat(id) : id;
      
      // Check both stokData and window.stokData for the entry
      let entry = stokData.find(item => {
        const itemId = typeof item.id === 'string' ? parseFloat(item.id) : item.id;
        return itemId === normalizedId;
      });
      
      if (!entry && typeof window !== 'undefined' && typeof window.stokData !== 'undefined' && Array.isArray(window.stokData)) {
        entry = window.stokData.find(item => {
          const itemId = typeof item.id === 'string' ? parseFloat(item.id) : item.id;
          return itemId === normalizedId;
        });
        
        // Sync local stokData if entry found in window.stokData
        if (entry) {
          const localIndex = stokData.findIndex(item => {
            const itemId = typeof item.id === 'string' ? parseFloat(item.id) : item.id;
            return itemId === normalizedId;
          });
          if (localIndex === -1) {
            // Entry not in local stokData, add it
            stokData.push(entry);
          } else {
            // Entry exists but might be outdated, update it
            stokData[localIndex] = entry;
          }
        }
      }
      if (!entry) {
        console.warn('Entry not found with id:', id, 'normalized:', normalizedId);
        console.log('Available IDs in stokData:', stokData.map(e => e.id).slice(0, 10));
        return;
      }

      // Only allow editing for pembelian entries (masuk > 0)
      // For penjualan entries (keluar > 0), editing should be done in log surat jalan
      if (entry.keluar > 0 && entry.masuk === 0) {
        alert('Data penjualan tidak dapat diedit di sini. Silakan edit di log surat jalan.');
        return;
      }

      // Always use pembelian mode
      setFormMode('pembelian');

      // Format date for input field (yyyy-mm-dd)
      const [day, month, year] = entry.tanggal.split('/');
      const formattedDate = `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;

      // Fill the form with entry data
      document.getElementById("nama").value = entry.nama;
      document.getElementById("tanggalStok").value = formattedDate;
      document.getElementById("nota").value = entry.nota;
      document.getElementById("tebal").value = entry.tebal;
      document.getElementById("ukuran").value = entry.ukuran;
      document.getElementById("harga").value = entry.harga || '';
      document.getElementById("hargaJual").value = entry.hargaJual || '';
      document.getElementById("masuk").value = entry.masuk;
      document.getElementById("keluar").value = entry.keluar;
      updateHargaBeliPlaceholder();
      updateHargaJualPlaceholder();

      // Set editing mode
      currentlyEditingId = id;
      document.getElementById("stokForm").classList.add("edit-mode");
      document.getElementById("submitBtn").textContent = "Update Data";
      document.getElementById("cancelEditBtn").style.display = "block";

      // Scroll to form
      document.getElementById("stokForm").scrollIntoView({ behavior: 'smooth' });
    }

    // Function to cancel edit
    function cancelEdit() {
      currentlyEditingId = null;
      document.getElementById("stokForm").reset();
      document.getElementById("tanggalStok").value = new Date().toISOString().split('T')[0];
      document.getElementById("stokForm").classList.remove("edit-mode");
      document.getElementById("submitBtn").textContent = "Tambah Data";
      document.getElementById("cancelEditBtn").style.display = "none";
      // Reset to default mode (pembelian)
      setFormMode('pembelian');
      updateHargaBeliPlaceholder();
    }

    // Function to delete an entry
    async function deleteEntry(id) {
      // Normalize ID to number for comparison (handle both string and number IDs)
      const normalizedId = typeof id === 'string' ? parseFloat(id) : id;
      
      // Check both stokData and window.stokData for the entry
      let entry = stokData.find(item => {
        const itemId = typeof item.id === 'string' ? parseFloat(item.id) : item.id;
        return itemId === normalizedId;
      });
      
      if (!entry && typeof window !== 'undefined' && typeof window.stokData !== 'undefined' && Array.isArray(window.stokData)) {
        entry = window.stokData.find(item => {
          const itemId = typeof item.id === 'string' ? parseFloat(item.id) : item.id;
          return itemId === normalizedId;
        });
        // Sync local stokData if entry found in window.stokData
        if (entry) {
          stokData = [...window.stokData];
        }
      }
      if (!entry) {
        console.warn('Entry not found with id:', id, 'normalized:', normalizedId);
        return;
      }
      
      // Prevent deletion of penjualan entries (keluar > 0, masuk === 0)
      // Penjualan entries should be deleted from log surat jalan
      if (entry.keluar > 0 && entry.masuk === 0) {
        alert('Data penjualan tidak dapat dihapus di sini. Silakan hapus di log surat jalan.');
        return;
      }
      
      if (confirm("Apakah Anda yakin ingin menghapus data ini?")) {
        try {
          // Normalize ID for comparison
          const normalizedId = typeof id === 'string' ? parseFloat(id) : id;
          
          // Remove from local stokData
          stokData = stokData.filter(entry => {
            const itemId = typeof entry.id === 'string' ? parseFloat(entry.id) : entry.id;
            return itemId !== normalizedId;
          });
          
          // Also update window.stokData if it exists (for sync with surat jalan)
          if (typeof window !== 'undefined' && typeof window.stokData !== 'undefined' && Array.isArray(window.stokData)) {
            window.stokData = window.stokData.filter(entry => {
              const itemId = typeof entry.id === 'string' ? parseFloat(entry.id) : entry.id;
              return itemId !== normalizedId;
            });
          }
          
          // Delete from IndexedDB
          await deleteEntryFromDB(id);
          
          // Update UI immediately after deletion
          updateStokTable();
          updateTotalSisa();
          updateNamaTokoList();
          updateJenisKacaList();
          updateUkuranKacaList();
          
          showStatus("Data berhasil dihapus", "saving");
          setTimeout(() => {
            const statusBar = document.getElementById('statusBar');
            if (statusBar) statusBar.style.display = 'none';
          }, 2000);
        } catch (error) {
          console.error('Error deleting entry:', error);
          alert("Terjadi kesalahan saat menghapus data: " + error.message);
          // Still update table even if DB deletion fails
          updateStokTable();
          updateTotalSisa();
        }
      }
    }

    // Function to update Total Sisa per Jenis
    function updateTotalSisa() {
      const totalSisaTableBody = document.getElementById("jenisTable").getElementsByTagName('tbody')[0];
      const groupedData = {};

      // Group data by Tebal Kaca, Ukuran Kaca, dan Harga Beli (agar harga berbeda muncul sebagai baris baru)
      stokData.forEach((entry) => {
        const hargaKey = entry.harga !== undefined ? entry.harga : 'noharga';
        const key = `${entry.tebal}-${entry.ukuran}-${hargaKey}`;

        if (!groupedData[key]) {
          groupedData[key] = { 
            tebal: entry.tebal, 
            ukuran: entry.ukuran, 
            hargaMasuk: hargaKey !== 'noharga' ? entry.harga : undefined,
            totalMasuk: 0, 
            totalKeluar: 0, 
            totalSisa: 0 
          };
        }

        // Bila transaksi masuk dengan harga, simpan hargaMasuk khusus baris tersebut
        if (entry.masuk > 0 && entry.harga !== undefined) {
          groupedData[key].hargaMasuk = entry.harga;
        }

        groupedData[key].totalMasuk += entry.masuk;
        groupedData[key].totalKeluar += entry.keluar;
        groupedData[key].totalSisa = groupedData[key].totalMasuk - groupedData[key].totalKeluar;
      });

      // Clear the table body
      totalSisaTableBody.innerHTML = "";

      // Convert groupedData to array and sort by jenis kaca (tebal) A-Z
      const sortedData = Object.keys(groupedData).map(key => ({
        key: key,
        data: groupedData[key]
      })).sort((a, b) => {
        // Sort by jenis kaca (tebal) A-Z
        const tebalA = (a.data.tebal || '').toUpperCase();
        const tebalB = (b.data.tebal || '').toUpperCase();
        if (tebalA !== tebalB) {
          return tebalA.localeCompare(tebalB);
        }
        // If jenis kaca is the same, sort by ukuran A-Z
        const ukuranA = (a.data.ukuran || '').toUpperCase();
        const ukuranB = (b.data.ukuran || '').toUpperCase();
        return ukuranA.localeCompare(ukuranB);
      });

      // Insert sorted grouped data into the Total Sisa table
      sortedData.forEach(({ data }) => {
        const row = totalSisaTableBody.insertRow();
        const sisaValue = data.totalSisa.toLocaleString('id-ID');
        const sisaClass = data.totalSisa < 0 ? 'sisa negative' : 'sisa';
        const sisaStyle = data.totalSisa < 0 ? 'style="color: #dc3545; font-weight: 600;"' : '';
        
        row.innerHTML = `
          <td>${data.tebal}</td>
          <td>${data.ukuran}</td>
          <td>${data.hargaMasuk !== undefined ? data.hargaMasuk.toLocaleString('id-ID') : '-'}</td>
          <td class="masuk">${data.totalMasuk.toLocaleString('id-ID')}</td>
          <td class="keluar">${data.totalKeluar.toLocaleString('id-ID')}</td>
          <td class="${sisaClass}" ${sisaStyle}>${sisaValue}</td>
        `;
        
        // Add click event to fill form fields
        row.style.cursor = 'pointer';
        row.addEventListener('click', function() {
          document.getElementById('tebal').value = data.tebal;
          document.getElementById('ukuran').value = data.ukuran;
          if (data.hargaMasuk !== undefined) {
            document.getElementById('harga').value = data.hargaMasuk;
          }
          // Perbarui placeholder harga beli dan harga jual sesuai harga beli terpilih
          updateHargaBeliPlaceholder();
          updateHargaJualPlaceholder();
          document.getElementById('keluar').focus();
        });
        
        // Add hover effect
        row.addEventListener('mouseenter', function() {
          this.style.backgroundColor = '#e3f2fd';
        });
        
        row.addEventListener('mouseleave', function() {
          this.style.backgroundColor = '';
        });
      });
      
      // Update jenis kaca autocomplete list
      updateJenisKacaList();
      updateUkuranKacaList(); // Add this line
    }

    // Function to clear all data
    async function clearData() {
      if (confirm("Apakah Anda yakin ingin menghapus semua data? Tindakan ini tidak dapat dibatalkan.")) {
        try {
          if (!db) {
            await initDB();
          }

          // Clear IndexedDB using Promise wrapper
          await new Promise((resolve, reject) => {
            const transaction = db.transaction([STORE_NAME], 'readwrite');
            const store = transaction.objectStore(STORE_NAME);
            const request = store.clear();

            request.onsuccess = () => {
              resolve();
            };

            request.onerror = () => {
              reject(request.error);
            };

            transaction.onerror = () => {
              reject(transaction.error);
            };
          });

          // Clear local arrays
          stokData = [];
          // Also clear window.stokData if it exists (for sync with surat jalan)
          if (typeof window !== 'undefined' && typeof window.stokData !== 'undefined' && Array.isArray(window.stokData)) {
            window.stokData = [];
          }
          
          // Update all UI components without page refresh
          updateStokTable();
          updateTotalSisa();
          updateNamaTokoList();
          updateJenisKacaList();
          updateUkuranKacaList();
          clearSearch();
          
          showStatus("Semua data berhasil dihapus", "saving");
          setTimeout(() => {
            const statusBar = document.getElementById('statusBar');
            if (statusBar) statusBar.style.display = 'none';
          }, 2000);
          
          console.log('🗑️ Cleared all stok data');
        } catch (error) {
          console.error('Error clearing data:', error);
          alert("Terjadi kesalahan saat menghapus data: " + error.message);
        }
      }
    }

    // Function to export data to Excel
    function exportToExcel() {
      try {
        // Use window.stokData if available (for sync with surat jalan), otherwise use local stokData
        const dataSource = (typeof window !== 'undefined' && typeof window.stokData !== 'undefined' && Array.isArray(window.stokData)) 
          ? window.stokData 
          : stokData;
        
        if (!dataSource || dataSource.length === 0) {
          showStatus("Tidak ada data untuk diexport", "error");
          setTimeout(() => {
            const statusBar = document.getElementById('statusBar');
            if (statusBar) statusBar.style.display = 'none';
          }, 2000);
          return;
        }

        // Prepare data for export (without ID column)
        const exportData = dataSource.map(entry => ({
          'Nama Toko': entry.nama || '',
          'Tanggal': entry.tanggal || '',
          'No. Nota': entry.nota || '',
          'Jenis Kaca': entry.tebal || '',
          'Ukuran Kaca': entry.ukuran || '',
          'Harga Beli': entry.harga || 0,
          'Harga Jual': entry.hargaJual || 0,
          'Jumlah Masuk': entry.masuk || 0,
          'Jumlah Keluar': entry.keluar || 0,
          'Sisa Stok': calculateCurrentStock(entry) || 0
        }));

        // Create worksheet
        const ws = XLSX.utils.json_to_sheet(exportData);
        
        // Set column widths for better readability (without ID column)
        const colWidths = [
          { wch: 20 }, // Nama Toko
          { wch: 12 }, // Tanggal
          { wch: 15 }, // No. Nota
          { wch: 20 }, // Jenis Kaca
          { wch: 15 }, // Ukuran Kaca
          { wch: 12 }, // Harga Beli
          { wch: 12 }, // Harga Jual
          { wch: 12 }, // Jumlah Masuk
          { wch: 12 }, // Jumlah Keluar
          { wch: 12 }  // Sisa Stok
        ];
        ws['!cols'] = colWidths;
        
        // Create workbook
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, "Stok Barang Kaca");
        
        // Export to file
        const date = new Date().toISOString().slice(0, 10).replace(/-/g, '');
        const fileName = `Stok_Barang_Kaca_${date}.xlsx`;
        XLSX.writeFile(wb, fileName);
        
        showStatus(`Data berhasil diexport ke Excel (${exportData.length} baris)`, "saving");
        setTimeout(() => {
          const statusBar = document.getElementById('statusBar');
          if (statusBar) statusBar.style.display = 'none';
        }, 2000);
        
        console.log(`✅ Exported ${exportData.length} entries to ${fileName}`);
      } catch (error) {
        console.error('Error exporting to Excel:', error);
        showStatus("Gagal mengexport data: " + error.message, "error");
        setTimeout(() => {
          const statusBar = document.getElementById('statusBar');
          if (statusBar) statusBar.style.display = 'none';
        }, 3000);
      }
    }

    // Function to export Stock data from totalSisaContainer
    function exportStock() {
      try {
        // Use window.stokData if available (for sync with surat jalan), otherwise use local stokData
        const dataSource = (typeof window !== 'undefined' && typeof window.stokData !== 'undefined' && Array.isArray(window.stokData)) 
          ? window.stokData 
          : stokData;
        
        if (!dataSource || dataSource.length === 0) {
          showStatus("Tidak ada data untuk diexport", "error");
          setTimeout(() => {
            const statusBar = document.getElementById('statusBar');
            if (statusBar) statusBar.style.display = 'none';
          }, 2000);
          return;
        }

        // Group data by Tebal Kaca, Ukuran Kaca, dan Harga Beli (same logic as updateTotalSisa)
        const groupedData = {};
        
        dataSource.forEach((entry) => {
          const hargaKey = entry.harga !== undefined ? entry.harga : 'noharga';
          const key = `${entry.tebal}-${entry.ukuran}-${hargaKey}`;

          if (!groupedData[key]) {
            groupedData[key] = { 
              tebal: entry.tebal, 
              ukuran: entry.ukuran, 
              hargaMasuk: hargaKey !== 'noharga' ? entry.harga : undefined,
              totalMasuk: 0, 
              totalKeluar: 0, 
              totalSisa: 0 
            };
          }

          // Bila transaksi masuk dengan harga, simpan hargaMasuk khusus baris tersebut
          if (entry.masuk > 0 && entry.harga !== undefined) {
            groupedData[key].hargaMasuk = entry.harga;
          }

          groupedData[key].totalMasuk += entry.masuk || 0;
          groupedData[key].totalKeluar += entry.keluar || 0;
          groupedData[key].totalSisa = groupedData[key].totalMasuk - groupedData[key].totalKeluar;
        });

        // Convert groupedData to array and sort by jenis kaca (tebal) A-Z
        const sortedData = Object.keys(groupedData).map(key => ({
          key: key,
          data: groupedData[key]
        })).sort((a, b) => {
          // Sort by jenis kaca (tebal) A-Z
          const tebalA = (a.data.tebal || '').toUpperCase();
          const tebalB = (b.data.tebal || '').toUpperCase();
          if (tebalA !== tebalB) {
            return tebalA.localeCompare(tebalB);
          }
          // If jenis kaca is the same, sort by ukuran A-Z
          const ukuranA = (a.data.ukuran || '').toUpperCase();
          const ukuranB = (b.data.ukuran || '').toUpperCase();
          return ukuranA.localeCompare(ukuranB);
        });

        // Prepare data for export
        const exportData = sortedData.map(({ data }) => ({
          'Jenis Kaca': data.tebal || '',
          'Ukuran Kaca': data.ukuran || '',
          'Harga': data.hargaMasuk !== undefined ? data.hargaMasuk : 0,
          'Kaca Masuk': data.totalMasuk || 0,
          'Kaca Keluar': data.totalKeluar || 0,
          'Sisa Stok': data.totalSisa || 0
        }));

        if (exportData.length === 0) {
          showStatus("Tidak ada data stok untuk diexport", "error");
          setTimeout(() => {
            const statusBar = document.getElementById('statusBar');
            if (statusBar) statusBar.style.display = 'none';
          }, 2000);
          return;
        }

        // Create worksheet
        const ws = XLSX.utils.json_to_sheet(exportData);
        
        // Set column widths for better readability
        const colWidths = [
          { wch: 20 }, // Jenis Kaca
          { wch: 15 }, // Ukuran Kaca
          { wch: 12 }, // Harga
          { wch: 12 }, // Kaca Masuk
          { wch: 12 }, // Kaca Keluar
          { wch: 12 }  // Sisa Stok
        ];
        ws['!cols'] = colWidths;
        
        // Create workbook
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, "Stock Summary");
        
        // Export to file
        const date = new Date().toISOString().slice(0, 10).replace(/-/g, '');
        const fileName = `Stock_Summary_${date}.xlsx`;
        XLSX.writeFile(wb, fileName);
        
        showStatus(`Data stok berhasil diexport ke Excel (${exportData.length} baris)`, "saving");
        setTimeout(() => {
          const statusBar = document.getElementById('statusBar');
          if (statusBar) statusBar.style.display = 'none';
        }, 2000);
        
        console.log(`✅ Exported ${exportData.length} stock entries to ${fileName}`);
      } catch (error) {
        console.error('Error exporting stock to Excel:', error);
        showStatus("Gagal mengexport data stok: " + error.message, "error");
        setTimeout(() => {
          const statusBar = document.getElementById('statusBar');
          if (statusBar) statusBar.style.display = 'none';
        }, 3000);
      }
    }

    // Function to import data from Excel
    async function importFromExcel(event) {
      const file = event.target.files[0];
      if (!file) return;

      showStatus("Memproses file Excel...", "loading");
      
      try {
        const data = await file.arrayBuffer();
        const workbook = XLSX.read(data);
        const worksheet = workbook.Sheets[workbook.SheetNames[0]];
        const jsonData = XLSX.utils.sheet_to_json(worksheet);

        // Validate and format imported data
        const importedData = jsonData.map((item, index) => {
          // Handle different column name variations
          const nama = (item['Nama Toko'] || item['Nama'] || item.nama || '').toString().trim();
          const tanggal = item.Tanggal || item.tanggal || '';
          const nota = (item['No. Nota'] || item.Nota || item.nota || '').toString().trim();
          const tebal = (item['Jenis Kaca'] || item.Tebal || item.tebal || '').toString().trim();
          const ukuran = (item['Ukuran Kaca'] || item.Ukuran || item.ukuran || '').toString().trim();
          const harga = item['Harga Beli'] || item['Harga'] || item.harga || 0;
          const hargaJual = item['Harga Jual'] || item.hargaJual || 0;
          const masuk = item['Jumlah Masuk'] || item.Masuk || item.masuk || 0;
          const keluar = item['Jumlah Keluar'] || item.Keluar || item.keluar || 0;
          
          // Generate unique ID if not provided or if invalid
          let id = item.ID;
          if (!id || isNaN(id) || id <= 0) {
            // Generate unique ID based on timestamp and index
            id = Date.now() + index + Math.floor(Math.random() * 10000);
          }

          // Format date - handle multiple formats
          let formattedDate = tanggal;
          if (tanggal instanceof Date) {
            formattedDate = formatDate(tanggal.toISOString());
          } else if (typeof tanggal === 'string' && tanggal.trim()) {
            // Handle various date formats
            if (tanggal.includes('-')) {
              // ISO format or YYYY-MM-DD
              formattedDate = formatDate(tanggal);
            } else if (tanggal.includes('/')) {
              // DD/MM/YYYY or MM/DD/YYYY
              const parts = tanggal.split('/');
              if (parts.length === 3) {
                // Assume DD/MM/YYYY format
                const day = parts[0].padStart(2, '0');
                const month = parts[1].padStart(2, '0');
                const year = parts[2].length === 2 ? '20' + parts[2] : parts[2];
                formattedDate = `${day}/${month}/${year}`;
              } else {
                formattedDate = tanggal;
              }
            } else {
              // Try to parse as Excel serial date
              const excelDate = parseFloat(tanggal);
              if (!isNaN(excelDate) && excelDate > 0) {
                // Excel date serial number (days since 1900-01-01)
                const excelEpoch = new Date(1899, 11, 30);
                const date = new Date(excelEpoch.getTime() + excelDate * 24 * 60 * 60 * 1000);
                formattedDate = formatDate(date.toISOString());
              } else {
                formattedDate = tanggal;
              }
            }
          }

          return {
            id,
            nama: nama,
            tanggal: formattedDate,
            nota: nota,
            tebal: tebal,
            ukuran: ukuran,
            harga: parseNumber(harga),
            hargaJual: parseNumber(hargaJual),
            masuk: parseNumber(masuk),
            keluar: parseNumber(keluar)
          };
        }).filter(item => {
          // Filter out invalid rows - must have nama and tanggal
          return item.nama && item.tanggal && item.tanggal.trim() !== '';
        });

        if (importedData.length === 0) {
          showStatus("Tidak ada data valid untuk diimpor", "error");
          setTimeout(() => {
            const statusBar = document.getElementById('statusBar');
            if (statusBar) statusBar.style.display = 'none';
          }, 2000);
          return;
        }

        if (confirm(`Akan mengimpor ${importedData.length} data. Data yang sama (berdasarkan ID) akan diupdate, data baru akan ditambahkan. Lanjutkan?`)) {
          let updatedCount = 0;
          let addedCount = 0;
          let errorCount = 0;
          
          // Get current data source to check for existing IDs
          const currentStokData = (typeof window !== 'undefined' && typeof window.stokData !== 'undefined' && Array.isArray(window.stokData)) 
            ? window.stokData 
            : stokData;
          
          // Process each imported item
          for (const importedItem of importedData) {
            try {
              // Check if item with same ID exists in both arrays
              const existingIndex = currentStokData.findIndex(item => item.id === importedItem.id);
              const localIndex = stokData.findIndex(item => item.id === importedItem.id);
              
              if (existingIndex !== -1 || localIndex !== -1) {
                // Update existing data
                const targetIndex = localIndex !== -1 ? localIndex : existingIndex;
                if (targetIndex !== -1) {
                  stokData[targetIndex] = importedItem;
                } else {
                  // Entry exists in window.stokData but not in local stokData
                  stokData.push(importedItem);
                }
                
                // Also update window.stokData if it exists
                if (typeof window !== 'undefined' && typeof window.stokData !== 'undefined' && Array.isArray(window.stokData)) {
                  const windowIndex = window.stokData.findIndex(item => item.id === importedItem.id);
                  if (windowIndex !== -1) {
                    window.stokData[windowIndex] = importedItem;
                  } else {
                    window.stokData.push(importedItem);
                  }
                }
                
                await updateEntry(importedItem);
                updatedCount++;
              } else {
                // Generate new unique ID if ID already exists
                let uniqueId = importedItem.id;
                const allStokData = (typeof window !== 'undefined' && typeof window.stokData !== 'undefined' && Array.isArray(window.stokData)) 
                  ? [...window.stokData, ...stokData]
                  : stokData;
                
                while (allStokData.some(item => item.id === uniqueId)) {
                  uniqueId = Date.now() + Math.floor(Math.random() * 1000000);
                }
                importedItem.id = uniqueId;
                
                // Add new data to both arrays
                stokData.unshift(importedItem);
                if (typeof window !== 'undefined') {
                  if (typeof window.stokData === 'undefined' || !Array.isArray(window.stokData)) {
                    window.stokData = [];
                  }
                  window.stokData.unshift(importedItem);
                }
                
                await addEntry(importedItem);
                addedCount++;
              }
            } catch (error) {
              console.error('Error processing imported item:', importedItem, error);
              errorCount++;
            }
          }
          
          // Ensure both arrays are fully synchronized
          // Remove duplicates and ensure consistency
          const uniqueStokData = [];
          const seenIds = new Set();
          
          // First, add all entries from stokData
          for (const entry of stokData) {
            if (!seenIds.has(entry.id)) {
              uniqueStokData.push(entry);
              seenIds.add(entry.id);
            }
          }
          
          // Then, add any entries from window.stokData that aren't in stokData
          if (typeof window !== 'undefined' && typeof window.stokData !== 'undefined' && Array.isArray(window.stokData)) {
            for (const entry of window.stokData) {
              if (!seenIds.has(entry.id)) {
                uniqueStokData.push(entry);
                seenIds.add(entry.id);
              }
            }
          }
          
          // Update both arrays with synchronized data
          stokData = uniqueStokData;
          if (typeof window !== 'undefined') {
            window.stokData = [...stokData];
          }
          
          // Save all data to ensure consistency
          await saveData();
          
          // Reload data from IndexedDB to ensure we have the latest
          await loadData();
          
          // Update all UI components without page refresh
          updateStokTable();
          updateTotalSisa();
          updateNamaTokoList();
          updateJenisKacaList();
          updateUkuranKacaList();
          
          let message = `Berhasil mengimpor ${importedData.length} data`;
          const parts = [];
          if (updatedCount > 0) parts.push(`${updatedCount} diupdate`);
          if (addedCount > 0) parts.push(`${addedCount} ditambahkan`);
          if (errorCount > 0) parts.push(`${errorCount} error`);
          
          if (parts.length > 0) {
            message += ` (${parts.join(', ')})`;
          }
          
          if (errorCount > 0) {
            showStatus(message, "error");
          } else {
            showStatus(message, "saving");
          }
          
          console.log(`✅ Imported ${importedData.length} entries (${updatedCount} updated, ${addedCount} added, ${errorCount} errors)`);
        } else {
          showStatus("Import dibatalkan", "error");
        }
      } catch (error) {
        console.error("Error importing Excel:", error);
        showStatus("Gagal mengimpor: " + error.message, "error");
      } finally {
        event.target.value = ''; // Reset input
        setTimeout(() => document.getElementById('statusBar').style.display = 'none', 2000);
      }
    }


    // Show status message
    function showStatus(message, type) {
      const statusBar = document.getElementById('statusBar');
      statusBar.textContent = message;
      statusBar.className = `status-bar status-${type}`;
      statusBar.style.display = 'block';
    }

    // Toggle sections
    document.querySelectorAll('.toggle-section-btn').forEach(button => {
      button.addEventListener('click', function() {
        const target = document.getElementById('stokForm');
        const icon = this.querySelector('i');
        
        if (target.style.display === 'none') {
          target.style.display = 'flex';
          this.classList.remove('collapsed');
        } else {
          target.style.display = 'none';
          this.classList.add('collapsed');
        }
      });
    });

    // Initialize sections
    document.getElementById('stokForm').style.display = 'flex';
    document.getElementById('totalSisaContainer').style.display = 'block';
  </script>
<script>
        // Quick print from header (uses current print settings, opens modal silently to generate data, then prints)
        function handleQuickPrint() {
            // Open modal to ensure latest data/layout prepared (hidden quickly)
            const modal = document.getElementById('printModalOverlay');
            const prevDisplay = modal.style.display;
            modal.style.display = 'flex';
            document.body.style.overflow = 'hidden';
            try {
                loadFontSizePreference();
                loadFontWeightPreference();
                loadFontFamilyPreference();
                loadColumnSpacingFromStorage();
                refreshPrintData();
                // Small delay to allow DOM updates
                setTimeout(() => {
                    // Auto-save log before printing
                    try { saveCurrentInputToLog(); } catch (e) { console.warn('Auto-save log failed:', e); }
                    // Record transactions to stok
                    // Force update all harga before recording transactions
                    const allUkuranInputs = document.querySelectorAll('#kacaTableBody tr .ukuran');
                    allUkuranInputs.forEach(ukuranInput => {
                        if (ukuranInput.value.trim()) {
                            // Trigger update by dispatching change event
                            ukuranInput.dispatchEvent(new Event('change', { bubbles: true }));
                        }
                    });
                    
                    // Wait a bit longer to ensure all updates complete
                    setTimeout(() => {
                        try { recordStokTransactionsFromSuratJalan(); } catch (e) { console.warn('Record stok transactions failed:', e); }
                        printNow();
                        // Close modal after triggering print
                        hidePrintModal();
                    }, 150);
                }, 50);
            } catch (e) {
                console.error('Quick print error:', e);
                // Fallback: show modal so user can print manually
                modal.style.display = 'flex';
            } finally {
                // Restore body overflow when modal hides via hidePrintModal
            }
        }
        // Utilitas database toko bersama untuk autocomplete dan auto-fill
        function buildTokoMapFromArray(arrayOfToko) {
            const nameToAddress = {};
            if (Array.isArray(arrayOfToko)) {
                arrayOfToko.forEach(entry => {
                    if (entry && entry.nama) {
                        nameToAddress[entry.nama.toLowerCase()] = entry.alamat || '';
                    }
                });
            }
            return nameToAddress;
        }

        function getDatabaseToko() {
            let map = {};
            try {
                const saved = storageManager.load('databaseToko');
                if (saved && typeof saved === 'object') {
                    map = saved;
                }
            } catch (_) {}
            // Hanya gunakan data dari storage tanpa default bawaan
            return map;
        }

        // Tidak lagi memaksa sync dari seed; gunakan storage manager
        function persistDatabaseTokoFromLengkap() {
            try {
                const map = buildTokoMapFromArray(databaseTokoLengkap);
                storageManager.save('databaseToko', map);
            } catch (_) {}
        }

        // Fungsi untuk mengisi alamat otomatis berdasarkan nama toko
        document.getElementById('namaToko').addEventListener('input', function() {
            const rawInput = this.value || '';
            const namaTokoLower = rawInput.toLowerCase();
            const alamatField = document.getElementById('alamat');
            const autocompleteDropdown = document.getElementById('autocompleteDropdown');
            
            // Tampilkan autocomplete jika ada input (case-insensitive, cari di nama/alamat)
            if (namaTokoLower.length > 0) {
                showAutocomplete(namaTokoLower);
            } else {
                hideAutocomplete();
            }
            
            // Auto-fill alamat berdasarkan data dari localStorage (map nama->alamat)
            const map = getDatabaseToko();
            const addressFromMap = map[namaTokoLower];
            if (addressFromMap) {
                alamatField.value = addressFromMap;
                alamatField.style.backgroundColor = '#f8f9fa';
                autoResizeTextarea(alamatField);
            } else {
                alamatField.value = '';
                alamatField.style.backgroundColor = '#fff';
                alamatField.style.height = '80px';
            }
        });

        // Fungsi untuk menampilkan popup daftar toko
        function showTokoList() {
            const popup = document.getElementById('popupOverlay');
            const tokoList = document.getElementById('tokoList');
            
            // Generate daftar toko dari array yang tersimpan (di-load dari localStorage)
            tokoList.innerHTML = '';
            if (!Array.isArray(databaseTokoLengkap) || databaseTokoLengkap.length === 0) {
                const empty = document.createElement('div');
                empty.className = 'no-results';
                empty.textContent = 'Belum ada toko yang tersedia';
                tokoList.appendChild(empty);
            } else {
                databaseTokoLengkap.forEach((toko, index) => {
                    const tokoItem = document.createElement('div');
                    tokoItem.className = 'toko-item';
                    tokoItem.innerHTML = `
                        <div class="toko-nama">🏪 ${toko.nama}</div>
                        <div class="toko-alamat">📍 ${toko.alamat}</div>
                        <div class="action-buttons">
                            <button class="btn-edit" onclick="editToko(${index})">✏️ Edit</button>
                            <button class="btn-delete" onclick="deleteToko(${index})">🗑️ Hapus</button>
                        </div>
                    `;
                    tokoList.appendChild(tokoItem);
                });
            }
            
            popup.style.display = 'flex';
            document.body.style.overflow = 'hidden'; // Prevent scrolling
        }

        // Fungsi untuk menyembunyikan popup
        function hideTokoList() {
            const popup = document.getElementById('popupOverlay');
            popup.style.display = 'none';
            document.body.style.overflow = 'auto'; // Restore scrolling
        }

        // Close popup when clicking outside
        document.getElementById('popupOverlay').addEventListener('click', function(e) {
            if (e.target === this) {
                hideTokoList();
            }
        });

        // Close popup with Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                hideTokoList();
                hideModal();
                hideQuickAddModal();
                hidePrintModal();
            }
            // Handle Ctrl+P or Cmd+P to trigger Print Sekarang
            if ((e.ctrlKey || e.metaKey) && e.key === 'p') {
                e.preventDefault();
                if (typeof handleQuickPrint === 'function') {
                    handleQuickPrint();
                }
            }
        });

        // Refresh page helper
        function refreshPage() {
            try {
                window.location.reload();
            } catch (_) {
                // Fallback: navigate to same URL
                window.location.href = window.location.href;
            }
        }

        // Fungsi untuk menampilkan modal tambah toko
        function showAddModal() {
            const modal = document.getElementById('modalOverlay');
            const modalTitle = document.getElementById('modalTitle');
            const saveBtn = document.getElementById('saveBtn');
            const editIndex = document.getElementById('editIndex');
            
            modalTitle.textContent = '➕ Tambah Toko Baru';
            saveBtn.textContent = 'Simpan';
            editIndex.value = '';
            
            // Reset form
            document.getElementById('modalNamaToko').value = '';
            document.getElementById('modalAlamat').value = '';
            
            modal.style.display = 'flex';
            document.body.style.overflow = 'hidden';
        }

        // Fungsi untuk menampilkan quick add modal
        function showQuickAddModal() {
            const modal = document.getElementById('quickAddModalOverlay');
            
            // Reset form
            document.getElementById('quickAddNamaToko').value = '';
            document.getElementById('quickAddAlamat').value = '';
            
            // Reset ke tab pertama
            showQuickAddTab();
            
            modal.style.display = 'flex';
            document.body.style.overflow = 'hidden';
        }

        // Fungsi untuk menampilkan tab tambah toko
        function showQuickAddTab() {
            const addTab = document.getElementById('quickAddTab');
            const listTab = document.getElementById('quickListTab');
            if (addTab) addTab.classList.add('active');
            if (listTab) listTab.classList.remove('active');
            // Update tab buttons safely tanpa bergantung pada event
            const buttons = Array.from(document.querySelectorAll('.tab-btn'));
            buttons.forEach(btn => btn.classList.remove('active'));
            const addBtn = buttons.find(b => /Tambah Baru/i.test(b.textContent || ''));
            if (addBtn) addBtn.classList.add('active');
        }

        // Fungsi untuk menampilkan tab daftar toko
        function showQuickListTab() {
            const addTab = document.getElementById('quickAddTab');
            const listTab = document.getElementById('quickListTab');
            if (addTab) addTab.classList.remove('active');
            if (listTab) listTab.classList.add('active');
            // Update tab buttons safely tanpa bergantung pada event
            const buttons = Array.from(document.querySelectorAll('.tab-btn'));
            buttons.forEach(btn => btn.classList.remove('active'));
            const listBtn = buttons.find(b => /Lihat Daftar/i.test(b.textContent || ''));
            if (listBtn) listBtn.classList.add('active');
            // Generate daftar toko
            generateQuickTokoList();
        }

        // Fungsi untuk menyembunyikan quick add modal
        function hideQuickAddModal() {
            const modal = document.getElementById('quickAddModalOverlay');
            modal.style.display = 'none';
            document.body.style.overflow = 'auto';
        }

        // Fungsi untuk menampilkan modal edit toko
        function editToko(index) {
            const modal = document.getElementById('modalOverlay');
            const modalTitle = document.getElementById('modalTitle');
            const saveBtn = document.getElementById('saveBtn');
            const editIndex = document.getElementById('editIndex');
            const toko = databaseTokoLengkap[index];
            
            modalTitle.textContent = '✏️ Edit Toko';
            saveBtn.textContent = 'Update';
            editIndex.value = index;
            
            // Isi form dengan data yang ada
            document.getElementById('modalNamaToko').value = toko.nama;
            document.getElementById('modalAlamat').value = toko.alamat;
            
            modal.style.display = 'flex';
            document.body.style.overflow = 'hidden';
        }

        // Fungsi untuk menghapus toko
        function deleteToko(index) {
            if (confirm('Apakah Anda yakin ingin menghapus toko ini?')) {
                databaseTokoLengkap.splice(index, 1);
                // Sinkronkan database autocomplete dan daftar lengkap yang tersimpan
                persistDatabaseTokoFromLengkap();
                persistDatabaseTokoLengkapArray();
                
                // Refresh popup jika sedang terbuka
                if (document.getElementById('popupOverlay').style.display === 'flex') {
                    showTokoList();
                }
                // Refresh quick list tab jika sedang terbuka
                const quickModal = document.getElementById('quickAddModalOverlay');
                const quickListTab = document.getElementById('quickListTab');
                if (quickModal && quickModal.style.display === 'flex' && quickListTab && quickListTab.classList.contains('active')) {
                    generateQuickTokoList();
                }

                alert('Toko berhasil dihapus!');
            }
        }

        // Fungsi untuk menyembunyikan modal
        function hideModal() {
            const modal = document.getElementById('modalOverlay');
            modal.style.display = 'none';
            document.body.style.overflow = 'auto';
        }

        // Handle form modal submission
        document.getElementById('modalForm').addEventListener('submit', function(e) {
            e.preventDefault();
            
            const namaToko = document.getElementById('modalNamaToko').value.trim();
            const alamat = document.getElementById('modalAlamat').value.trim();
            const editIndex = document.getElementById('editIndex').value;
            
            if (!namaToko || !alamat) {
                alert('Mohon lengkapi semua field!');
                return;
            }
            
            if (editIndex === '') {
                // Tambah toko baru
                const newToko = {
                    nama: namaToko,
                    alamat: alamat
                };
                
                databaseTokoLengkap.push(newToko);
                // Sinkronkan database autocomplete dan daftar lengkap yang tersimpan
                persistDatabaseTokoFromLengkap();
                persistDatabaseTokoLengkapArray();
                
                alert('Toko berhasil ditambahkan!');
            } else {
                // Edit toko yang ada
                const index = parseInt(editIndex);
                const oldNama = databaseTokoLengkap[index].nama;
                
                // Update database lengkap
                databaseTokoLengkap[index] = {
                    nama: namaToko,
                    alamat: alamat
                };
                // Sinkronkan database autocomplete dan daftar lengkap yang tersimpan
                persistDatabaseTokoFromLengkap();
                persistDatabaseTokoLengkapArray();
                
                alert('Toko berhasil diupdate!');
            }
            
            hideModal();
            
            // Refresh popup jika sedang terbuka
            if (document.getElementById('popupOverlay').style.display === 'flex') {
                showTokoList();
            }

            // Refresh quick list tab jika sedang terbuka
            const quickModal = document.getElementById('quickAddModalOverlay');
            const quickListTab = document.getElementById('quickListTab');
            if (quickModal && quickModal.style.display === 'flex' && quickListTab && quickListTab.classList.contains('active')) {
                generateQuickTokoList();
            }
        });

        // Close modal when clicking outside
        document.getElementById('modalOverlay').addEventListener('click', function(e) {
            if (e.target === this) {
                hideModal();
            }
        });

        // Close quick add modal when clicking outside
        document.getElementById('quickAddModalOverlay').addEventListener('click', function(e) {
            if (e.target === this) {
                hideQuickAddModal();
            }
        });

        // Handle quick add form submission
        document.getElementById('quickAddForm').addEventListener('submit', function(e) {
            e.preventDefault();
            
            // Normalisasi: simpan Nama apa adanya (preserve case) untuk tampilan,
            // namun lakukan pencarian/duplikasi dengan lower-case key
            const namaInput = document.getElementById('quickAddNamaToko').value.trim();
            const alamatInput = document.getElementById('quickAddAlamat').value.trim();
            const namaKey = namaInput.toLowerCase();
            
            if (!namaInput || !alamatInput) {
                alert('Mohon lengkapi semua field yang wajib diisi!');
                return;
            }
            
            // Tambah toko baru
            const newToko = {
                nama: namaInput,
                alamat: alamatInput
            };
            
            // Cek duplikasi berdasarkan lower-case key
            const existingIndex = databaseTokoLengkap.findIndex(t => (t.nama || '').toLowerCase() === namaKey);
            if (existingIndex >= 0) {
                // Update yang lama untuk menjaga satu sumber truth
                databaseTokoLengkap[existingIndex] = newToko;
            } else {
                databaseTokoLengkap.push(newToko);
            }
            // Sinkronkan database autocomplete dan daftar lengkap yang tersimpan
            persistDatabaseTokoFromLengkap();
            persistDatabaseTokoLengkapArray();
            // Segarkan daftar cepat bila tab "Lihat Daftar" dibuka setelahnya
            try { generateQuickTokoList(); } catch (_) {}
            
            // Auto-fill form utama
            const alamatField = document.getElementById('alamat');
            document.getElementById('namaToko').value = namaInput;
            alamatField.value = alamatInput;
            alamatField.style.backgroundColor = '#f8f9fa';
            
            // Auto-resize textarea
            autoResizeTextarea(alamatField);
            
            alert('Toko berhasil ditambahkan dan form telah diisi otomatis!');
            hideQuickAddModal();
        });

        // Fungsi untuk auto-resize textarea
        function autoResizeTextarea(textarea) {
            // Reset height untuk mendapatkan scrollHeight yang akurat
            textarea.style.height = 'auto';
            
            // Set height berdasarkan konten
            const newHeight = Math.max(80, textarea.scrollHeight);
            textarea.style.height = newHeight + 'px';
        }

        // Fungsi untuk generate baris default tabel kaca
        // Removed generateDefaultKacaRows (not used anymore)

        // Fungsi untuk menambah baris baru
        

        // Fungsi untuk menghapus baris
        

        // Event listener untuk input changes
        document.addEventListener('input', function(e) {
            if (e.target.classList.contains('box') || e.target.classList.contains('lbr')) {
                calculateTotalLbr(e.target);
            }
        });

        // Event listener untuk blur (ketika input kehilangan focus)
        document.addEventListener('blur', function(e) {
            if (e.target.classList.contains('box')) {
                autoAddBoxUnit(e.target);
            } else if (e.target.classList.contains('lbr')) {
                autoAddLbrUnit(e.target);
            }
        }, true);

        // Event listener untuk keydown (ENTER key)
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                const target = e.target;
                
                // Auto-add unit jika user menekan ENTER pada input BOX atau LBR
                if (target.classList.contains('box')) {
                    autoAddBoxUnit(target);
                } else if (target.classList.contains('lbr')) {
                    autoAddLbrUnit(target);
                }
                
                // Navigasi form dengan ENTER - hanya untuk form surat jalan (tokoForm)
                // Cek apakah target berada di dalam form surat jalan
                const tokoForm = target.closest('#tokoForm');
                const stokForm = target.closest('#stokForm');
                
                // Skip jika target berada di form stok
                if (stokForm) {
                    return; // Let setupEnterKeyNavigation() handle it
                }
                
                // Hanya proses jika target berada di form surat jalan
                if (tokoForm) {
                    if (target.id === 'namaToko') {
                        e.preventDefault();
                        const tanggalInput = tokoForm.querySelector('#tanggal');
                        if (tanggalInput) tanggalInput.focus();
                    } else if (target.id === 'tanggal' && tokoForm.contains(target)) {
                        e.preventDefault();
                        const nomorSJInput = tokoForm.querySelector('#nomorSJ');
                        if (nomorSJInput) nomorSJInput.focus();
                    } else if (target.id === 'nomorSJ') {
                        e.preventDefault();
                        const supirInput = tokoForm.querySelector('#supir');
                        if (supirInput) supirInput.focus();
                    } else if (target.id === 'supir') {
                        e.preventDefault();
                        const noKendaraanInput = tokoForm.querySelector('#noKendaraan');
                        if (noKendaraanInput) noKendaraanInput.focus();
                    } else if (target.id === 'noKendaraan') {
                        e.preventDefault();
                        // Focus ke input Jenis Kaca di baris pertama
                        const firstJenisKacaInput = document.querySelector('input.jenis-kaca');
                        if (firstJenisKacaInput) {
                            firstJenisKacaInput.focus();
                            firstJenisKacaInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }
                    }
                }
                // Note: Form stok navigation is handled by setupEnterKeyNavigation() function
                // which is called separately and only handles fields in the stock form
                // This prevents conflicts between form surat jalan and form stok
                
                // Cek apakah input berada di tabel kaca
                if (target.closest('#kacaTable')) {
                    const currentRow = target.closest('tr');
                    const tbody = document.getElementById('kacaTableBody');
                    const rows = tbody.querySelectorAll('tr');
                    const isLastRow = currentRow === rows[rows.length - 1];
                    
                    // Navigasi antar kolom dalam tabel
                    if (target.classList.contains('jenis-kaca')) {
                        e.preventDefault();
                        const nextInput = currentRow.querySelector('input.pwd');
                        if (nextInput) nextInput.focus();
                    } else if (target.classList.contains('pwd')) {
                        e.preventDefault();
                        const nextInput = currentRow.querySelector('input.no-do');
                        if (nextInput) nextInput.focus();
                    } else if (target.classList.contains('no-do')) {
                        e.preventDefault();
                        const nextInput = currentRow.querySelector('input.ukuran');
                        if (nextInput) nextInput.focus();
                    } else if (target.classList.contains('ukuran')) {
                        e.preventDefault();
                        const nextInput = currentRow.querySelector('input.harga-jual');
                        if (nextInput) nextInput.focus();
                    } else if (target.classList.contains('harga-jual')) {
                        e.preventDefault();
                        const nextInput = currentRow.querySelector('input.box');
                        if (nextInput) nextInput.focus();
                    } else if (target.classList.contains('box')) {
                        e.preventDefault();
                        const nextInput = currentRow.querySelector('input.lbr');
                        if (nextInput) nextInput.focus();
                    } else if (target.classList.contains('lbr')) {
                        // Jika ini adalah baris terakhir dan semua field terisi
                        if (isLastRow && isRowComplete(currentRow)) {
                            e.preventDefault();
                            
                            // Visual feedback - highlight baris saat ini
                            currentRow.style.backgroundColor = '#e8f5e8';
                            setTimeout(() => {
                                currentRow.style.backgroundColor = '';
                            }, 300);
                            
                            addKacaRow();
                            
                            // Focus ke input Jenis Kaca di baris baru
                            setTimeout(() => {
                                const allRows = tbody.querySelectorAll('tr');
                                const newRow = allRows[allRows.length - 1]; // Ambil baris terakhir (yang baru)
                                const jenisKacaInput = newRow.querySelector('input.jenis-kaca');
                                
                                if (jenisKacaInput) {
                                    jenisKacaInput.focus();
                                    
                                    // Tambahan: scroll ke input jika perlu
                                    jenisKacaInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                } else {
                                    // Fallback: coba focus ke input pertama
                                    const firstInput = newRow.querySelector('input');
                                    if (firstInput) {
                                        firstInput.focus();
                                    }
                                }
                            }, 200);
                        } else {
                            // Jika bukan baris terakhir, pindah ke baris berikutnya
                            e.preventDefault();
                            const nextRow = currentRow.nextElementSibling;
                            if (nextRow) {
                                const nextJenisKacaInput = nextRow.querySelector('input.jenis-kaca');
                                if (nextJenisKacaInput) {
                                    nextJenisKacaInput.focus();
                                    nextJenisKacaInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                }
                            }
                        }
                    }
                }
            }
        });

        // Fungsi untuk mengecek apakah baris sudah terisi lengkap
        function isRowComplete(row) {
            const inputs = row.querySelectorAll('input:not([readonly])');
            let filledCount = 0;
            let totalInputs = 0;
            
            inputs.forEach(input => {
                totalInputs++;
                const value = input.value;
                if (value && typeof value === 'string' && value.trim() !== '') {
                    filledCount++;
                }
            });
            
            // Minimal 3 field harus terisi (jenis kaca, box, lbr)
            // Atau jika user menekan ENTER pada field terakhir yang terisi
            const currentInput = document.activeElement;
            const isLastInput = currentInput === row.querySelector('input:last-of-type');
            
            return filledCount >= 3 || (filledCount >= 2 && isLastInput);
        }

        // Fungsi untuk otomatis menambahkan satuan BOX
        function autoAddBoxUnit(input) {
            const value = input.value.trim();
            if (value && !value.toLowerCase().includes('box')) {
                // Cek apakah input hanya berisi angka
                const numberMatch = value.match(/^(\d+(?:\.\d+)?)$/);
                if (numberMatch) {
                    input.value = value + ' BOX';
                    // Trigger calculation after adding unit
                    calculateTotalLbr(input);
                }
            }
        }

        // Fungsi untuk otomatis menambahkan satuan LBR
        function autoAddLbrUnit(input) {
            const value = input.value.trim();
            if (value && !value.toLowerCase().includes('lbr')) {
                // Cek apakah input hanya berisi angka
                const numberMatch = value.match(/^(\d+(?:\.\d+)?)$/);
                if (numberMatch) {
                    input.value = value + ' LBR';
                    // Trigger calculation after adding unit
                    calculateTotalLbr(input);
                }
            }
        }

        // Fungsi untuk generate daftar toko di quick modal
        function generateQuickTokoList() {
            const quickTokoList = document.getElementById('quickTokoList');
            
            if (databaseTokoLengkap.length === 0) {
                quickTokoList.innerHTML = '<div class="no-results">Belum ada toko yang tersedia</div>';
                return;
            }
            
            let html = '';
            databaseTokoLengkap.forEach((toko, index) => {
                html += `
                    <div class="quick-toko-item" onclick="selectQuickToko('${toko.nama}', '${toko.alamat.replace(/\n/g, '\\n')}')">
                        <div class="quick-toko-name">🏪 ${toko.nama}</div>
                        <div class="quick-toko-address">📍 ${toko.alamat}</div>
                        <div class="quick-toko-actions">
                            <button type="button" class="btn-edit" onclick="event.stopPropagation(); editToko(${index})">✏️ Edit</button>
                            <button type="button" class="btn-delete" onclick="event.stopPropagation(); deleteToko(${index})">🗑️ Hapus</button>
                        </div>
                    </div>
                `;
            });
            
            quickTokoList.innerHTML = html;
        }

        // Export daftar toko (databaseTokoLengkap) ke JSON yang bisa diunduh
        function exportTokoListToJSON() {
            try {
                const data = Array.isArray(databaseTokoLengkap) ? databaseTokoLengkap : [];
                const dataStr = JSON.stringify(data, null, 2);
                const blob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const now = new Date();
                const ts = now.toISOString().slice(0,19).replace(/[:T]/g,'-');
                a.download = `daftar_toko_${ts}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } catch (error) {
                console.error('Gagal export daftar toko:', error);
                alert('Gagal export daftar toko.');
            }
        }

        // Import daftar toko dari file JSON
        async function handleImportTokoListFile(event) {
            try {
                const file = event.target.files && event.target.files[0];
                if (!file) return;
                const text = await file.text();
                let parsed;
                try {
                    parsed = JSON.parse(text);
                } catch (e) {
                    alert('File JSON tidak valid.');
                    return;
                }
                if (!Array.isArray(parsed)) {
                    alert('Format file tidak valid. Harus berupa array daftar toko.');
                    return;
                }
                // Validasi minimal field
                const sanitized = parsed.map(item => ({
                    nama: String((item && (item.nama ?? item.Nama ?? item.name)) || '').trim(),
                    alamat: String((item && (item.alamat ?? item.Alamat ?? item.address)) || '').trim()
                })).filter(it => it.nama && it.alamat);
                if (sanitized.length === 0) {
                    alert('File tidak berisi data toko yang valid.');
                    return;
                }
                // Gabungkan dengan data existing, hindari duplikat nama (case-insensitive)
                const existingByLower = new Map(
                    (Array.isArray(databaseTokoLengkap) ? databaseTokoLengkap : []).map(it => [String(it.nama || '').toLowerCase(), it])
                );
                sanitized.forEach(it => {
                    const key = it.nama.toLowerCase();
                    existingByLower.set(key, { nama: it.nama, alamat: it.alamat });
                });
                // Mutate the existing const array instead of reassigning
                const merged = Array.from(existingByLower.values());
                databaseTokoLengkap.splice(0, databaseTokoLengkap.length, ...merged);
                // Persist ke localStorage
                persistDatabaseTokoFromLengkap();
                persistDatabaseTokoLengkapArray();
                // Refresh UI jika tab daftar terbuka
                const quickModal = document.getElementById('quickAddModalOverlay');
                const quickListTab = document.getElementById('quickListTab');
                if (quickModal && quickModal.style.display === 'flex' && quickListTab && quickListTab.classList.contains('active')) {
                    generateQuickTokoList();
                }
                alert(`Import berhasil. Total toko: ${databaseTokoLengkap.length}`);
                // Reset input untuk bisa import ulang
                const input = document.getElementById('importTokoFileInput');
                if (input) input.value = '';
            } catch (error) {
                console.error('Gagal import daftar toko:', error);
                alert('Gagal import daftar toko. Pastikan file JSON valid.');
            }
        }

        // Fungsi untuk memilih toko dari quick list
        function selectQuickToko(namaToko, alamat) {
            const alamatField = document.getElementById('alamat');
            // Isi form utama
            document.getElementById('namaToko').value = namaToko;
            alamatField.value = alamat.replace(/\\n/g, '\n');
            alamatField.style.backgroundColor = '#f8f9fa';
            
            // Auto-resize textarea
            autoResizeTextarea(alamatField);
            
            // Tutup modal
            hideQuickAddModal();
            
            // Tampilkan feedback
            alert(`Form telah diisi dengan data ${namaToko}!`);
        }

        function getDisplayNameForKey(lowerKey) {
            try {
                const entry = Array.isArray(databaseTokoLengkap)
                    ? databaseTokoLengkap.find(t => (t.nama || '').toLowerCase() === String(lowerKey || ''))
                    : null;
                if (entry && entry.nama) return entry.nama;
            } catch (_) {}
            // Fallback: Title Case dari lowerKey
            return String(lowerKey || '').replace(/\b\w+/g, s => s.charAt(0).toUpperCase() + s.slice(1));
        }

        // Fungsi untuk menampilkan autocomplete
        function showAutocomplete(searchTerm) {
            const dropdown = document.getElementById('autocompleteDropdown');
            const matches = [];
            const map = getDatabaseToko();
            // Cari toko yang cocok berdasarkan nama ATAU alamat (case-insensitive)
            Object.keys(map).forEach(key => {
                const nameLower = key;
                const addressLower = String(map[key] || '').toLowerCase();
                if (nameLower.includes(searchTerm) || addressLower.includes(searchTerm)) {
                    matches.push({
                        namaKey: key,
                        displayName: getDisplayNameForKey(key),
                        alamat: map[key]
                    });
                }
            });
            
            // Generate HTML untuk dropdown
            if (matches.length > 0) {
                let html = '';
                matches.forEach((toko, index) => {
                    html += `
                        <div class="autocomplete-item" data-index="${index}" onclick="selectToko('${toko.displayName.replace(/'/g, "&#39;")}', '${toko.alamat.replace(/\n/g, '\\n').replace(/'/g, "&#39;")}')">
                            <div class="autocomplete-item-icon">🏪</div>
                            <div class="autocomplete-item-text">
                                <div class="autocomplete-item-name">${toko.displayName}</div>
                                <div class="autocomplete-item-address">${toko.alamat.split('\n')[0]}...</div>
                            </div>
                        </div>
                    `;
                });
                dropdown.innerHTML = html;
                dropdown.style.display = 'block';
            } else {
                dropdown.innerHTML = '<div class="no-results">Tidak ada toko yang cocok</div>';
                dropdown.style.display = 'block';
            }
        }

        // Fungsi untuk menyembunyikan autocomplete
        function hideAutocomplete() {
            const dropdown = document.getElementById('autocompleteDropdown');
            dropdown.style.display = 'none';
        }

        // Fungsi untuk memilih toko dari autocomplete
        function selectToko(namaToko, alamat) {
            const alamatField = document.getElementById('alamat');
            document.getElementById('namaToko').value = namaToko;
            alamatField.value = alamat.replace(/\\n/g, '\n');
            alamatField.style.backgroundColor = '#f8f9fa';
            // Auto-resize textarea
            autoResizeTextarea(alamatField);
            hideAutocomplete();
        }

        // Sembunyikan autocomplete saat klik di luar
        document.addEventListener('click', function(e) {
            const autocompleteContainer = document.querySelector('.autocomplete-container');
            if (!autocompleteContainer.contains(e.target)) {
                hideAutocomplete();
            }
        });

        // Keyboard navigation untuk autocomplete
        document.getElementById('namaToko').addEventListener('keydown', function(e) {
            const dropdown = document.getElementById('autocompleteDropdown');
            const items = dropdown.querySelectorAll('.autocomplete-item');
            const selectedItem = dropdown.querySelector('.autocomplete-item.selected');
            
            if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (selectedItem) {
                    selectedItem.classList.remove('selected');
                    const nextItem = selectedItem.nextElementSibling;
                    if (nextItem && nextItem.classList.contains('autocomplete-item')) {
                        nextItem.classList.add('selected');
                    } else {
                        items[0]?.classList.add('selected');
                    }
                } else {
                    items[0]?.classList.add('selected');
                }
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (selectedItem) {
                    selectedItem.classList.remove('selected');
                    const prevItem = selectedItem.previousElementSibling;
                    if (prevItem && prevItem.classList.contains('autocomplete-item')) {
                        prevItem.classList.add('selected');
                    } else {
                        items[items.length - 1]?.classList.add('selected');
                    }
                } else {
                    items[items.length - 1]?.classList.add('selected');
                }
            } else if (e.key === 'Enter' && selectedItem) {
                e.preventDefault();
                selectedItem.click();
            } else if (e.key === 'Escape') {
                hideAutocomplete();
            }
        });

        // Fungsi untuk toggle hide/unhide tombol
        function toggleButtons() {
            const mainActionsContainer = document.getElementById('mainActionsContainer');
            const toggleBtn = document.querySelector('.toggle-buttons-btn');
            const isHidden = mainActionsContainer.classList.contains('hidden');
            
            if (isHidden) {
                // Tampilkan tombol
                mainActionsContainer.classList.remove('hidden');
                toggleBtn.innerHTML = '🔽 Sembunyikan Tombol';
                toggleBtn.style.background = 'linear-gradient(135deg, #6f42c1 0%, #5a32a3 100%)';
            } else {
                // Sembunyikan tombol
                mainActionsContainer.classList.add('hidden');
                toggleBtn.innerHTML = '🔼 Tampilkan Tombol';
                toggleBtn.style.background = 'linear-gradient(135deg, #28a745 0%, #20c997 100%)';
            }
        }

        // Set state awal - tombol tersembunyi
        window.addEventListener('load', function() {
            try {
                // Tombol tersembunyi secara default
                const mainActionsContainer = document.getElementById('mainActionsContainer');
                const toggleBtn = document.querySelector('.toggle-buttons-btn');
                
                if (mainActionsContainer && toggleBtn) {
                    mainActionsContainer.classList.add('hidden');
                    toggleBtn.innerHTML = '🔼 Tampilkan Tombol';
                    toggleBtn.style.background = 'linear-gradient(135deg, #28a745 0%, #20c997 100%)';
                }
                
                // Tambahkan 1 baris default jika belum ada
                setTimeout(() => {
                    const tbody = document.getElementById('kacaTableBody');
                    if (tbody && tbody.children.length === 0) {
                        addKacaRow();
                    }
                }, 200);
                
            } catch (error) {
                console.error('Error during page initialization:', error);
            }
        });

        // Backup initialization untuk memastikan glass data ter-load
        document.addEventListener('DOMContentLoaded', function() {
            try {
                // Cek apakah glass data sudah ada, jika belum, tambahkan 1 baris default
                setTimeout(() => {
                    const kacaTableBody = document.getElementById('kacaTableBody');
                    if (kacaTableBody && kacaTableBody.children.length === 0) {
                        console.log('Glass data not found, adding one default row...');
                        addKacaRow();
                    }
                }, 500);
            } catch (error) {
                console.error('Error during DOMContentLoaded:', error);
            }
        });

        // Debug function untuk testing glass data
        // Removed debugGlassData (not used anymore)

        // Print Modal Functions
        function adjustLayoutForSinglePage() {
            const container = document.querySelector('.print-textarea-container');
            const textElements = container.querySelectorAll('.draggable-text-item');
            
            if (textElements.length === 0) return;
            
            // F4 dimensions in pixels (matching container dimensions)
            const a4Width = 813;
            const a4Height = 1247;
            const margin = 0; // 20px margin on each side
            
            // Calculate available space
            const maxWidth = a4Width - (margin * 2);
            const maxHeight = a4Height - (margin * 2);
            
            // Check if elements need adjustment (only if they're outside bounds or too close together)
            let needsAdjustment = false;
            let previousY = -1;
            
            textElements.forEach((element, index) => {
                const currentX = parseInt(element.style.left) || 20;
                const currentY = parseInt(element.style.top) || 20;
                
                // Check if element is outside F4 bounds
                if (currentX < margin || currentX > maxWidth || currentY < margin || currentY > maxHeight) {
                    needsAdjustment = true;
                }
                
                // Check if elements are too close together (less than 30px spacing)
                if (previousY !== -1 && Math.abs(currentY - previousY) < 30) {
                    needsAdjustment = true;
                }
                
                previousY = currentY;
            });
            
            // Never auto-rearrange user positions; only log the state
            console.log('No layout auto-adjustment applied; preserving user positions');
        }

        // Add event listeners for real-time column spacing updates
        function addColumnSpacingEventListeners() {
            const columnInputs = [
                'colJenisKaca', 'colPwd', 'colNoDo', 'colUkuran', 'colBox', 'colLbr', 'colTotalLbr'
            ];
            
            columnInputs.forEach(inputId => {
                const input = document.getElementById(inputId);
                if (input) {
                    // Remove existing listeners to prevent duplicates
                    input.removeEventListener('input', updateColumnSpacing);
                    input.removeEventListener('change', updateColumnSpacing);
                    
                    // Add new listeners for real-time updates
                    input.addEventListener('input', debounce(updateColumnSpacing, 300));
                    input.addEventListener('change', updateColumnSpacing);
                }
            });
        }

        // Debounce function to prevent too many updates
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Update the showPrintModal function to add event listeners
        function showPrintModal() {
            const modal = document.getElementById('printModalOverlay');
            modal.style.display = 'flex';
            document.body.style.overflow = 'hidden';
            
            // Load font size preference
            loadFontSizePreference();
            loadFontWeightPreference();
            loadFontFamilyPreference();
            
            // Load column spacing preference
            loadColumnSpacingFromStorage();
            
            // Generate print data
            refreshPrintData();
            
            // Add event listeners for column spacing
            setTimeout(() => {
                addColumnSpacingEventListeners();
            }, 100);
            
            // Smart position handling: never auto-adjust; keep user positions as-is
            setTimeout(() => {
                if (Object.keys(savedPositions).length > 0) {
                    preserveUserPositions();
                }
                initDragAndDropForElements();
            }, 100);
            
            // Restore lock button state
            const lockBtn = document.querySelector('.btn-lock-position');
            if (lockBtn) {
                if (positionsLocked) {
                    lockBtn.textContent = '🔓 Unlock Posisi';
                    lockBtn.classList.add('locked');
                } else {
                    lockBtn.textContent = '🔒 Lock Posisi';
                    lockBtn.classList.remove('locked');
                }
            }
        }

        function hidePrintModal() {
            const modal = document.getElementById('printModalOverlay');
            modal.style.display = 'none';
            document.body.style.overflow = 'auto';
        }

        function refreshPrintData() {
            // Use the clean version that doesn't include headers
            refreshPrintDataClean();
        }

        function validateAndAdjustForSinglePage() {
            const container = document.querySelector('.print-textarea-container');
            const textElements = container.querySelectorAll('.draggable-text-item');
            
            if (textElements.length === 0) return;
            
            // F4 dimensions in pixels (matching container dimensions)
            const a4Width = 813;
            const a4Height = 1247;
            const margin = 0;
            
            let needsAdjustment = false;
            let previousY = -1;
            
            // Check if any element is beyond F4 boundaries or too close together
            textElements.forEach(element => {
                const x = parseInt(element.style.left) || 0;
                const y = parseInt(element.style.top) || 0;
                
                // Check if element is outside F4 bounds
                if (x < margin || x > (a4Width - margin) || y < margin || y > (a4Height - margin)) {
                    needsAdjustment = true;
                }
                
                // Check if elements are too close together (less than 40px spacing)
                if (previousY !== -1 && Math.abs(y - previousY) < 40) {
                    needsAdjustment = true;
                }
                
                previousY = y;
            });
            
            // If adjustment is needed, apply single page layout
            // Do not auto-adjust; trust user-defined positions
            console.log('Validation step skipped auto-adjustments; preserving user positions');
        }

        function debugPositions() {
            const container = document.querySelector('.print-textarea-container');
            const textElements = container.querySelectorAll('.draggable-text-item');
            
            console.log('=== Position Debug ===');
            console.log('Container dimensions:', {
                width: container.offsetWidth,
                height: container.offsetHeight,
                scrollLeft: container.scrollLeft,
                scrollTop: container.scrollTop
            });
            
            textElements.forEach((element, index) => {
                const x = parseInt(element.style.left) || 0;
                const y = parseInt(element.style.top) || 0;
                const text = element.querySelector('.text-content')?.textContent || '';
                
                console.log(`Element ${index}:`, {
                    text: text.substring(0, 30) + '...',
                    x: x,
                    y: y,
                    computedLeft: element.style.left,
                    computedTop: element.style.top
                });
            });
        }

        function showPositionOverlay() {
            const container = document.querySelector('.print-textarea-container');
            const textElements = container.querySelectorAll('.draggable-text-item');
            
            // Remove existing overlay
            const existingOverlay = document.querySelector('.position-overlay');
            if (existingOverlay) {
                existingOverlay.remove();
            }
            
            // Create overlay
            const overlay = document.createElement('div');
            overlay.className = 'position-overlay';
            overlay.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(255, 255, 0, 0.1);
                pointer-events: none;
                z-index: 9999;
            `;
            
            textElements.forEach((element, index) => {
                const x = parseInt(element.style.left) || 0;
                const y = parseInt(element.style.top) || 0;
                
                const marker = document.createElement('div');
                marker.style.cssText = `
                    position: absolute;
                    left: ${x}px;
                    top: ${y}px;
                    width: 10px;
                    height: 10px;
                    background: red;
                    border-radius: 50%;
                    z-index: 10000;
                `;
                marker.title = `Element ${index}: x=${x}, y=${y}`;
                overlay.appendChild(marker);
            });
            
            container.appendChild(overlay);
            
            // Remove overlay after 3 seconds
            setTimeout(() => {
                if (overlay.parentNode) {
                    overlay.remove();
                }
            }, 3000);
        }

        function printNow() {
            const container = document.querySelector('.print-textarea-container');
            const textElements = container.querySelectorAll('.draggable-text-item');
            
            if (textElements.length === 0) {
                alert('Tidak ada konten untuk dicetak!');
                return;
            }
            
            // Show position overlay for debugging
            showPositionOverlay();
            
            // Capture positions BEFORE any adjustments
            let positionedTexts = [];
            textElements.forEach(element => {
                const textContent = element.querySelector('.text-content');
                if (textContent && textContent.textContent.trim()) {
                    // Get exact pixel positions from the drag area
                    const x = parseInt(element.style.left) || 0;
                    const y = parseInt(element.style.top) || 0;
                    const type = element.dataset.type || 'data';
                    // Capture both raw text and the exact HTML preview for kaca-data
                    const text = (type === 'kaca-data')
                        ? (element.dataset.rawText || textContent.textContent)
                        : textContent.textContent;
                    const html = (type === 'kaca-data') ? textContent.innerHTML : null;
                    
                    positionedTexts.push({ x, y, text, type, html });
                }
            });
            
            // Debug positions before printing
            debugPositions();
            
            // Create a new window for printing with positioned layout
            const printWindow = window.open('', '_blank');
            
            // Sort by Y position first, then X position for consistent layout
            positionedTexts.sort((a, b) => {
                if (a.y !== b.y) return a.y - b.y;
                return a.x - b.x;
            });
            
            // Create HTML with positioned text elements using exact positions
            let positionedHTML = '';
            positionedTexts.forEach((item, index) => {
                // Clamp to F4 canvas to prevent overflow triggering blank extra page
                const pageWidth = 813;
                const pageHeight = 1247;
                const approxTextHeight = Math.max(currentFontSize, 10) + 8; // include ~8px vertical padding
                const safeX = Math.max(0, Math.min(item.x, pageWidth - 1));
                const safeY = Math.max(0, Math.min(item.y, pageHeight - approxTextHeight));
                const style = `position: absolute; left: ${safeX}px; top: ${safeY}px;`;
                let className = 'print-text-item';
                
                // Add styling based on type
                if (item.type === 'header') {
                    className += ' print-header';
                } else if (item.type === 'total') {
                    className += ' print-total';
                } else if (item.type === 'kaca-data') {
                    className += ' print-kaca-data';
                } else if (item.type === 'timestamp') {
                    className += ' print-timestamp';
                }
                
                if (item.type === 'kaca-data') {
                    // Use the exact preview HTML for perfect column alignment; fallback to rebuild
                    const kdHTML = item.html || buildKacaDataFixedColumnsHTML(item.text, currentFontFamily, currentFontSize);
                    positionedHTML += `<div class="${className}" style="${style}">${kdHTML}</div>`;
                } else {
                    positionedHTML += `<div class="${className}" style="${style}">${item.text}</div>`;
                }
                
                // Debug: Log the exact position being used
                console.log(`Print element ${index}:`, {
                    text: item.text.substring(0, 30) + '...',
                    x: safeX,
                    y: safeY,
                    style: style
                });
            });
            
            printWindow.document.write(`
                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="UTF-8">
                    <link rel="preconnect" href="https://fonts.googleapis.com">
                    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
                    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@300;400;500;600;700&display=swap" rel="stylesheet">
                    <style>
                        @page {
                            size: 215mm 330mm; /* F4 */
                            margin: 0;
                        }
                        html, body {
                            margin: 0;
                            padding: 0;
                            font-family: ${currentFontFamily};
                            font-size: ${currentFontSize}px;
                            font-weight: ${currentFontWeight};
                            line-height: 1.2;
                            background: white;
                            overflow: hidden;
                        }
                        html, body, * { box-sizing: border-box; }
                        .page {
                            position: fixed;
                            top: 0;
                            left: 0;
                            width: 212mm;   /* more conservative to avoid overflow */
                            height: 327mm;  /* more conservative to avoid overflow */
                            overflow: clip;
                            background: white;
                            margin: 0;
                            padding: 0;
                        }
                        .print-text-item { box-sizing: border-box; }
                        .print-text-item {
                            position: absolute;
                            background: transparent;
                            padding: 4px 8px;
                            border: none;
                            white-space: pre-wrap;
                            max-width: none;
                            font-family: ${currentFontFamily};
                            font-size: ${currentFontSize}px;
                            font-weight: ${currentFontWeight};
                        }
                        .print-header {
                            font-weight: 700;
                        }
                        .print-total {
                            font-weight: 700;
                            color: #000 !important; /* force black for TOTAL */
                            font-size: ${currentFontSize}px;
                        }
                        /* Mirror preview's fixed-columns layout exactly in print */
                        .print-kaca-data { font-size: ${Math.max(currentFontSize - 2, 8)}px; max-width: 600px; width: auto; }
                        .kd-block { display: block; }
                        .kd-row { white-space: nowrap; line-height: 1.2; }
                        .kd-cell { display:inline-block; font-family: 'Roboto Mono', 'Courier New', monospace; white-space: nowrap; overflow: hidden; text-overflow: clip; vertical-align: top; }
                        .kd-cell.left{ text-align:left; } .kd-cell.center{ text-align:center; } .kd-cell.right{ text-align:right; }
                        .kd-text{ display:inline; font-family:${currentFontFamily}; font-size:${currentFontSize}px; }
                        .print-timestamp {
                            font-weight: ${currentFontWeight};
                        }
        .print-timestamp {
            font-weight: ${currentFontWeight};
        }
                        @media print {
                            @page {
                                size: 215mm 330mm; /* F4 */
                                margin: 0;
                            }
                            html, body { 
                                margin: 0; 
                                padding: 0;
                                overflow: hidden;
                                font-size: ${currentFontSize}px;
                                font-weight: ${currentFontWeight};
                                font-family: ${currentFontFamily};
                            }
                            .page {
                                width: 212mm;
                                height: 327mm;
                                position: fixed;
                                top: 0;
                                left: 0;
                                overflow: clip;
                                margin: 0;
                                padding: 0;
                            }
                            .print-text-item {
                                page-break-inside: avoid;
                                page-break-before: avoid;
                                page-break-after: avoid;
                                font-family: ${currentFontFamily};
                                font-size: ${currentFontSize}px;
                                font-weight: ${currentFontWeight};
                                /* Ensure no overflow from padding during print */
                                padding: 0;
                                max-width: 212mm;
                            }
                            .print-kaca-data { max-width: 600px !important; width: auto !important; }
                            * {
                                page-break-inside: avoid;
                                page-break-after: avoid;
                                page-break-before: avoid;
                            }
                            /* Hide browser headers and footers */
                            html, body {
                                -webkit-print-color-adjust: exact;
                                print-color-adjust: exact;
                            }
                            /* Force single page */
                            html {
                                height: 100%;
                                overflow: hidden;
                            }
                        }
                    </style>
                </head>
                <body>
                    <div class="page">${positionedHTML}</div>
                </body>
                </html>
            `);
            
            printWindow.document.close();
            
            // Wait for content and web fonts to load before printing
            printWindow.onload = function() {
                try {
                    const timeoutMs = 1500;
                    let timedOut = false;
                    const timeoutId = setTimeout(() => { timedOut = true; printWindow.print(); printWindow.close(); }, timeoutMs);
                    const ready = (printWindow.document.fonts && printWindow.document.fonts.ready) ? printWindow.document.fonts.ready : Promise.resolve();
                    ready.then(() => {
                        if (!timedOut) {
                            clearTimeout(timeoutId);
                            // Slight delay ensures layout with loaded fonts
                            setTimeout(() => { printWindow.print(); printWindow.close(); }, 50);
                        }
                    }).catch(() => {
                        // Fallback if fonts API fails
                        if (!timedOut) {
                            clearTimeout(timeoutId);
                            printWindow.print();
                            printWindow.close();
                        }
                    });
                } catch (_) {
                    // Last resort
                    printWindow.print();
                    printWindow.close();
                }
            };
        }

    </script>
</body></html>
